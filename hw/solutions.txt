TITLE: Software Engineering Mathematics
AUTHOR: Anonymised Submission
SUBTITLE: Software Engineering Programme
DATE: October 2025
INSTITUTION: University of Oxford

BIBLIOGRAPHY: sem.bib
BIBLIOGRAPHY_STYLE: plainnat

PARTS: inline

PAGEBREAK:

CONTENTS:

PAGEBREAK:

** Question 1 **

TEXT: A tautology is a statement that is true for every valuation of the propositional variables it contains. A contradiction is a statement that is false for each such valuation. A contingency is a statement that is neither a tautology nor a contradiction. [cite simpson-notes Page 13].

(a) TRUTH TABLE:                                                                            
p | not p | (not p => p) | p => (not p => p)
T | F | T | T                                  
F | T | F | T

TEXT: p => (not p => p) is a tautology as it is true for every interpretation of p as illustrated by the final column of truth values.

(b) TRUTH TABLE:                                                                            
p | q | (q => p) | not p | not q | (not p => not q) | (not p => not q) <=> (q => p)
t | t | t | f | f | t | t
t | f | t | f | t | t | t
f | t | f | t | f | f | t
f | f | t | t | t | t | t

TEXT: The statements (not p =>  not q), (q => p) are equivalent and (not p =>  not q) <=> (q => p) is a tautology as it is true for every interpretation of p, q as illustrated by the final column of truth values.

(c) TRUTH TABLE:
p | q | r | (p => r) | (q => r) | ((p =>r) and (q => r)) | (p or q) | ((p or q) => r) | ((p => r) and (q => r)) <=> ((p or q) => r)
t | t | t | t | t | t | t | t | t
t | t | f | f | f | f | t | f | t
t | f | t | t | t | t | t | t | t
t | f | f | f | t | f | t | f | t
f | t | t | t | t | t | t | t | t
f | t | f | t | f | f | t | f | t
f | f | t | t | t | t | f | t | t
f | f | f | t | t | t | f | t | t

TEXT: The statements ((p => r) and (q => r)), ((p or q) => r) are equivalent and ((p => r) and (q => r)) <=> ((p or q) => r) is a tautology as it is true for every interpretation of p, q, r as illustrated by the final column of truth values.

** Question 2 **

(a) EQUIV:
p => (not p => p) 
p => (not not p or p) [=> disjunction]
p => (p or p) [negation is an involution]
p => p [idempotence of p]
true [tautology]

TEXT: In this equivalence, we prove that p => (not p => p) by starting with implication disjunction to replace the implication with a logical or [cite simpson-notes page 17]. Next, we use the definition of double negation [cite simpson25a Slide 25] and the application of the idempotence rule to simplify [cite simpson25a Slide 26]. We trivially conclude with the fact that p => p is a tautology. 

PAGEBREAK:

(b) EQUIV:
not p => not q
not not p or not q [=> disjunction]
p or not q [negation is an involution]
not q or p [commutativity of or]
q => p [=> disjunction]

TEXT: In this equivalance proof, we show that (not p => not q) <=> q => p by using implication disjunction to replace implication with logical or, the definition of double negation to simplify, the commutivity property of logical or to change the order of the elements [cite simpson25a Slide 27], and the implication disjunction rule to reintroduce implication.

(c) EQUIV:
(p => r) and (q => r)
(not p or r) and (not q or r) [=> disjunction]
(r or not p) and (r or not q) [commutativity of or]
r or (not p and not q) [distributivity 2]
(not p and not q) or r [commutativity of or]
not (p or q) or r [De Morgan 1]
p or q => r [=> disjunction]

TEXT: In this equivalence proof, we show that ((p => r) and (q => r)) <=> (p or q) => r by using the implication disjunction rule to replace implication with logical or, the commutativity of or rule to change the order of the elements [cite simpson25a Slide 27], the distributivity 2 rule to extract r [cite simpson25a Slide 29], and the commutivity of logical or to change the order of the elements, De Morgan's Law to extract negation for (not p and not q) [cite simpson25a Slide 28], and the implication disjunction rule to reintroduce implication.

** Question 3 **

(a) PROOF: 
  p => (not p => p) [=> intro from 1]
    p [from 1]
    [1] p [assumption]
        not p => p [=> intro from 2]
          [2] not p [assumption]
          p [false elim from 3]
            false [false-intro]
              [1] p [assumption]
              [3] not p [assumption]

TEXT: For this proof we are seeking to prove that p => (not p => p), which we know holds given the truth table in 1(a). Working mechanically from the bottom, we start by applying the implication introduction rule to identify and discharge assumption [1] to gain our conclusion [cite simpson25h Slide 3] and again we use the implication introduction rule to identify and discharge assumption [2] to gain (not p => p).  We note that this statement requires that we have both p and not p as premisses, which implies we need to use false in the proof. With some experimentation, we realize we need three assumptions and we introduce a third assumption [3]. We first use false-intro followed by false-elim1 to discharge assumption [3] [cite simpson25h Slide 6]. In the final proof, all assumptions are discharged properly. We note that this proof bears some similarities with the rules of negation proof in the course notes section 4.8 [cite simpson-notes Pages 41-46] which has multiple degrees of negation of p as assumptions. The key is to have not p as an assumption twice at different scopes. 

PAGEBREAK:

(b) 

TEXT: This proof involves equivalence or bi-implication.

TEXT: In one direction, we are seeking to prove (not p => not q) => (q => p):

PROOF:
  (not p => not q) => (q => p) [=> intro from 1]
    [1] not p => not q [assumption]
    :: q => p [=> intro from 2]
      [2] q [assumption]
      :: p [false elim from 3]
        false [false-intro]
          :: not q [=> elim]
            :: not p => not q [from 1]
            [3] not p [assumption]
          :: q [from 2]

TEXT: I started working mechanically from the bottom by applying the implication introduction rule to construct the conclusion.  This gave me q => p as the key premise to build up, which requires applying the implication introduction rule to q and p. Looking at the need for q and looking at the need for p and (not p => not q) as assumption [1], I felt it would be best to try not p as an assumption to at least get going.  This enabled me to work top down to get not q from the implication elimination rule. From there, I realized that I needed the negation of both not q and not p. I knew the false-intro and false-elim were required, but it took some experimentation to see that I could get both not q and not p transformed into p and q by making not p assumption [3] instead of [2] and introducing q as assumption [2]. Once that insight was made, I could arrive at p as a result of the top of the tree and retain q [2] as an assumption coming out of false-elim. This is what I needed to arrive at q => p and to connect the bottom and top portions of my proof.  All assumptions are properly discharged.

TEXT: and in the other, we are seeking to prove (q => p) => (not p => not q):

PROOF:
  (q => p) => (not p => not q) [=> intro from 1]
    [1] q => p [assumption]
    :: not p => not q [=> intro from 2]
      [2] not p [assumption]
      :: not q [false elim from 3]
        false [false-intro]
          :: p [=> elim]
            :: q => p [from 1]
            [3] q [assumption]
          :: not p [from 2]

TEXT: Working mechanically from the bottom, I apply the implication rule to q => p as assumption [1] to gain the conclusion.  I need (not p => not q), which shows me to use the implication rule again with (not p) as assumption [2].  From there, the question is how to get not q.  

TEXT: Now working from the top, given assumption [1] has q, it makes sense to use the implication elimation rule with q as assumption [3]. This gives me p, when what I want is not q.  I see that if I introduce not p as assumption [3] that I can negate q via the false-intro and false-elim rules and successfully discharge assumption [3]. This gives me not q, which is what I need to connect to the top tree to the bottom of the proof. This proof came more quickly because q => p as assumption [1] gave clear direction for the top portion. All assumptions are discharged and scopes are appropriate.

TEXT: We then combine these two proofs with the <=>-intro rule [cite simpson25h Slide 4], using the results from above to conclude our proof.

PROOF:
  (not p => not q) <=> (q => p) [<=> intro]
    :: (not p => not q) => (q => p)
    :: (q => p) => (not p => not q)

PAGEBREAK:

(c)

TEXT: In one direction, we are seeking to prove ((p => r) and (q => r)) => ((p or q) => r)

PROOF:
  ((p => r) and (q => r)) => ((p or q) => r) [=> intro from 1]
    [1] (p => r) and (q => r) [assumption]
    :: (p or q) => r [=> intro from 2]
      [2] p or q [assumption]
      :: r [or elim from 2]
        :: p or q [from 2]
        case p:
          :: r [=> elim]
            :: p [from 2]
            :: (p => r) [and elim 1]
              (p => r) and (q => r) [from 1]
        case q:
          :: r [=> elim]
            :: q [from 2]
            :: (q => r) [and elim 2]
              (p => r) and (q => r) [from 1]
  
TEXT: In this proof, I start by working from the bottom mechanically, taking (p => r) and (q => r) as assumption [1] and applying the implication introduction rule to arrive at our conclusion and discharge assumption [1]. From there, I can see that I need (p or q) and r as inputs to the implication introduction rule.  I take (p or q) as assumption [2] and discharge this assumption via the implication introduction rule.  That leaves me with r as the result of my bottom up process.  

TEXT: As I have already made assumptions ((p => r) and (q => r)) [1] and (p or q) [2] and they are related, I start by working with both top-down. I begin with (p or q) [2] and create cases for p and q working towards or elimination.  The p and q sub-branches are marked with [2] as the assumption as these are just the cases for (p or q) [2] [cite simpson25c slide 41]. Next, I apply and elimination in each case to get (p => r), (q => r) with the appropriate p or q cases in the sub-branches.  From there, I apply implication elimination to arrive at r in both cases.  This enables me to use the or elimination together with (p or q) [2] to simplify to r.  

TEXT: At this stage, I do not discharge assumption [2], as this is deferred until the next step. I use implication introduction together with (p or q) [2] and r from the or elimination to discharge assumption [2], which connects the top-down and bottom-up process. All assumptions are properly discharged.  

TEXT: In the other direction, we are seeking to prove ((p or q) => r) => ((p => r) and (q => r)):

PROOF:
((p or q) => r) => ((p => r) and (q => r))  [=> intro from 1]
  [1] ((p or q) => r) [assumption]
  :: ((p => r) and (q => r)) [and intro]
    :: p => r [=> intro from 2]
      p [from 2]
      :: r [=> elim]
        :: (p or q) => r [from 1]
        :: p or q [or intro1]
          [2] p [assumption]
    :: q => r [=> intro from 3]
      [3] q [assumption]
      :: r [=> elim]
        :: (p or q) => r [from 1]
        :: p or q [or intro2]
          [3] q [assumption]

TEXT: Working mechanically from the bottom, we start by taking ((p or q) => r) as assumption [1] and applying the implication introduction rule to discharge assumption [1].  This leaves us with ((p => r) and (q => r)), which is derived from p => r, q => r and the application of the and introduction rule. Fairly clearly, we need two sub-branches to be developed top-down. Since we have ((p or q) => r) and we want p => r and q => r, I start with p [2] and q [3] to start the top-down sub-trees.  I struggled here until I recalled that I could use the or intro rule to satisfy (p or q).  I also had to recall that this does not generate additional assumptions to discharge [cite simpson25c slide 38]. From here, it was not difficult to use implication elimation to arrive at r in both sub-trees and to apply p [2] and q [3] in each tree with the implication introduction rule to discharge those assumptions.  This gave me p => r, q => r and I used the and introduction rule to connect the top and bottom portions of the proof. All assumptions are properly discharged.

TEXT: We then combine these two proofs with the <=>-intro rule, using the results from above to conclude our proof:

PROOF:
  ((p => r) and (q => r)) <=> ((p or q) => r) [<=> intro]
    :: ((p => r) and (q => r)) => ((p or q) => r)
    :: ((p or q) => r) => ((p => r) and (q => r)) 

** Question 4 **

TEXT: We are defining a generic function that will return the difference in length between the longest and shorest sequences from an input type that is a non-empty sequences of sequences. The input could be < <x, y, z>, <> > yielding 3 as output or < <x> > yielding 0, for example. I specify three generic functions: maxSeq yields the longest sequence from a non-empty sequence of sequences; minSeq yields the shortest sequence from a non-empty sequence of sequences; and maxDiff, which fulfills the specification for Question 4.

gendef [X]
  maxSeq : seq1 seq X -> seq X ; minSeq : seq1 seq X -> seq X; maxDiff : seq1 seq X -> N
where
  forall ss : seq1 seq X | maxSeq(ss) = (mu s : ran ss | forall t : ran ss | # s >= # t)
  forall ss : seq1 seq X | minSeq(ss) = (mu s : ran ss | forall t : ran ss | # s <= # t)
  forall ss : seq1 seq X | maxDiff(ss) = ((# maxSeq(ss)) - (# minSeq(ss)))
end

TEXT: For maxSeq and minSeq, a mu function is defined that selects a single element meeting the specification based on comparing every sequence s with every sequence t. First, the range operator moves us from a sequence of sequences with ss values such as < 1 |-> <x, y, z>, 2 |-> <> > to sequences s, t with values like <x, y, z>, <> to enable seq operators. maxSeq and minSeq use the  operators and maxDiff uses the length operators with subtraction [cite simpson25f Page 40]. For maxDiff, maxSeq >= minDiff is a valid pre-condition by virtue of maxSeq and minSeq and therefore the subtraction is guaranteed to return a natural number as defined in the specification, making maxSeq() a total function [cite simpson-notes Page 119]. This solution passes fuzz validation.

** Question 5 **

TEXT: The relational composition operator is associative:

LATEX: \hspace*{1em} $(R \circ S) \circ T = R \circ (S \circ T)$

TEXT: if R in W <-> X, S in X <-> Y, and T in Y <-> Z.

TEXT: In this equivalence proof, we show that composition is associative using the definition of relational composition and by repositioning quantifiers and predicates where we are permitted to do so, which is only when there is no impact to the truth value of the predicates involved. Each such repositioning or regrouping will be justified. 

TEXT: Given a relation R in X <-> Y and a second relation S in Y <-> Z, and two elements x in X and z in Z, x |-> z in R o9 S <=> (exists y : Y | x |-> y in R and y |-> z in S) [cite simpson-notes page 107].

EQUIV:
w |-> z in (R o9 S) o9 T
(exists y : Y | w |-> y in (R o9 S) and y |-> z in T)                                       [definition of o9]
(exists y : Y | (exists x : X | w |-> x in R and x |-> y in S) and y |-> z in T)            [definition of o9]
(exists y : Y | (exists x : X | w |-> x in R and x |-> y in S and y |-> z in T))            [x is not free in y |-> z in T]
(exists x : X | w |-> x in R and (exists y : Y | x |-> y in S and y |-> z in T))            [y is not free in w |-> x in R]
(exists x : X | w |-> x in R and x |-> z in (S o9 T))                                       [definition of o9]
w |-> z in R o9 (S o9 T)

TEXT: In step 1, we apply the composition equivalence to the outer composition of (R o9 S) o9 T. In step 2, we apply our equivalence to the inner composition (R o9 S).  In step 3, we include the predicate y |-> z in T in the scope of x : X. We can do this because this does not affect the truth values of y |-> z in T as x is not free in this predicate. In step 4, we reposition the exists y : Y quantifier to be after the w |-> x in R predicate without affecting its truth values because y is not free in w |-> x in R.  In step 5, we apply the equivalence for composition to S o9 T.  In step 6, we apply the equivalence for composition to R o9 (S o9 T).

TEXT: I worked on this proof both top-down and bottom-up.  After doing the obvious equivalence substitutions, I was left with step 3 and 4 to work out. In working out step 3, I could see from step 6 that I wanted S o9 T together.  In working out step 4, I could see that y : Y needed to be repositioned to setup step 6.  The reasoning about both of these steps was not obvious at first, but I realized that these moves had no impact on the truth values of the affected predicates.  This led me to think about free and bound variables and what rules might apply in various cases [cite simpson-notes Pages 54-55].  I was not able to find a specific justification in the materials that maps to the idea that one can reposition quantifiers or predicates provided there is no inpact to the truth values, but this seems logical and sound provided x is not free in P for the affected P. I note the parallels with the logic for substition operations [cite simpson-notes Pages 56-57].

** Question 6 **

TEXT: The following set comprehensions are presented using Z axiomatic definitions to enable direct fuzz validation of the LaTeX.  Further, exponents are written long-hand as fuzz does not  support exponentiation.

(a)
axdef
  SquaresOfEvens : P Z
where
  SquaresOfEvens = { z : Z | z mod 2 = 0 . z * z}
end

(b)
axdef
  CubesOfSquaresOfEvens : P Z
where
  CubesOfSquaresOfEvens = { z : Z | z mod 2 = 0 . (z * z) * (z * z) * (z * z)}
end

(c)
axdef
  SquareCubePairsOfEvens : P (Z cross Z)
where
  SquareCubePairsOfEvens = { z_1, z_2: Z | z_1 mod 2 = 0 and z_2 mod 2 = 0 . (z_1 * z_1, z_2 * z_2 * z_2)}
end

(d)
axdef
  SquareCubeIdentityPairsOfEvens : P (Z cross Z)
where
  SquareCubeIdentityPairsOfEvens = { z : Z | z mod 2 = 0 . (z * z, z * z * z)}
end

(e)
axdef
  SetsOfSquareOrCubeIntegers : P (P (Z))
where
  SetsOfSquareOrCubeIntegers = P { z, z_0 : Z | z = z_0 * z_0 or z = z_0 * z_0 * z_0 . z}
end

PAGEBREAK:

** Question 7 **

TEXT: We are designing a prototype for a new podcast platform and player.  We are given some initial types and abbreviations.  We also define two generic functions fst() and snd() to provide our fuzz compatible and validated solution capabilities equal to tuple projection, which is not supported in fuzz. 

given ShowId, PeopleId
EpisodeId == N1
Timestamp == N

gendef[X, Y]
  fst : X cross Y -> X
where
  forall a : X | forall b : Y | fst(a, b) = a
end

gendef[X, Y]
  snd : X cross Y -> Y
where
  forall a : X | forall b : Y | snd(a, b) = b
end

axdef
  shows : F ShowId
  show_episodes : ShowId +-> F EpisodeId
  episode_info : ShowId cross EpisodeId +-> (F PeopleId cross Timestamp)
  show_info : ShowId +-> F PeopleId
where
  shows subset dom (show_episodes) and dom (show_episodes) subset shows
  forall es : ran show_episodes | (exists n : N | es = 1..n)
  forall s : dom show_episodes | forall e : show_episodes s | \
    (s, e) in dom episode_info <=> s in dom show_episodes
  shows subset dom (show_info) and dom (show_info) subset shows
  forall s : ShowId | forall p : PeopleId | (exists e : EpisodeId | \
    (s, e) in dom episode_info and \
    (p in fst(episode_info(s, e)) <=> p in show_info s))
  forall s : ShowId | forall t_1, t_2 : Timestamp | (forall e_1, e_2 : EpisodeId | \
    ((s, e_1) in dom episode_info and (s, e_2) in dom episode_info) | \
    (e_1 < e_2) => (snd(episode_info(s, e_1)) <= (snd(episode_info(s, e_2)))))
end

TEXT: The above Z is validated using fuzz. Each part is briefly explained below:

(a) shows subset dom (show_episodes) and dom (show_episodes) subset shows
TEXT: If and only if translates to the sets are equal. The same ShowId exist in both.

(b) forall es : ran show_episodes | (exists n : N | es = 1..n)
TEXT: Each finite set of EpisodeId includes an uninterrupted range from 1 to n. 

(c) forall s : dom show_episodes | forall e : show_episodes s | \
    e in show_episode(s) <=> (s, e) in dom episode_info 
TEXT: If and only if implies the condition is a bi-implication.

PAGEBREAK:

(d) shows subset dom (show_info) and dom (show_info) subset shows
TEXT: If and only if translates to the sets are equal. The same ShowId exist in both.

(e) forall s : ShowId | forall p : PeopleId | (exists e : EpisodeId | \
    (s, e) in dom episode_info and \
    (p in fst(episode_info(s, e)) <=> p in show_info s))
TEXT: The specification "exactly when" translates to if and only if and fst(episode_info(s, e)) gives us access to a finite set of PeopleId as does show_info(s) .

(f) forall s : ShowId | forall t_1, t_2 : Timestamp | (forall e_1, e_2 : EpisodeId | \
    ((s, e_1) in dom episode_info and (s, e_2) in dom episode_info) | \
    (e_1 < e_2) => (snd(episode_info(s, e_1)) <= (snd(episode_info(s, e_2)))))
TEXT: We specify how the Timestamp for different episodes of the same show must compare to fulfill the specification by using snd(episode_info(s, e)) to access the Timestamp.

** Question 8 **

TEXT: The following are given as abbreviations to enable fuzz validation, which passes for each expression.

(a) EightA == {s : dom show_episodes | #(show_episodes(s)) >= 100}

TEXT: Shows with at least 100 episodes.  We use the cardinality operator on F EpisodeId after ensuring s is in the domain of show_episodes.

(b) EightB == {p : PeopleId | exists s_1, s_2 : dom show_info | s_1 != s_2 and p in show_info s_1 and p in show_info s_2}

TEXT: The set of PeopleId, which appear in 2 or more shows.  We make sure two such shows are distinct and we validate each PeopleId in F PeopleId.

(c)

axdef
  first_episode_timestamp : ShowId +-> Timestamp
where
  forall s : ShowId | (s, 1) in dom episode_info | first_episode_timestamp(s) = snd(episode_info(s, 1))
end

EightC == first_episode_timestamp(mu s : dom show_info | \
  forall t : dom show_info | s != t and \
  #(show_info s) > #(show_info t))

TEXT: We are given that there is exactly one show with the most people and we want the timestamp for the first episode of that show. This involves two operations, finding the show with the most people and finding the timestamp for the first episode of that show.  For the first operation, we compare the cardinality of the F PeopleId for every pair s, t : ShowId in the domain of show\_info. This is captured in the mu expression, which returns the single matching value.

TEXT: For the second operation, we define a partial function first\_episode\_timestamp that yields the Timestamp for EpisodeId = 1 for s : ShowId.  We are guaranteed that EpisodeId = 1 exists by constraint 7(b). In addition, calling this function with the s from the mu expression is valid because the constraint defined in 7(e) guarantees that the set of EpisodeId in the domain of show\_info and in the first element of the domain of episode\_info are identical.

** Question 9**

PlayedOrNot ::= Played | NotP
SavedOrNot ::= Saved | NotS

axdef
  my_shows : F ShowId
  my_episodes : iseq(ShowId cross EpisodeId)
  status : ShowId cross EpisodeId +-> (PlayedOrNot cross SavedOrNot)
where
  my_shows subset shows
  forall s : ShowId | forall e : EpisodeId | (s, e) in ran my_episodes and \
e in show_episodes s
  forall s : ShowId | forall e : EpisodeId | s in my_shows and \
    (s, e) in ran my_episodes
  forall s : ShowId | forall e : EpisodeId | \
    (s, e) in ran my_episodes => (s, e) in dom status and \
    (s, e) in dom status => (s, e) in ran my_episodes
end

** Question 10 **

Playlist == seq((ShowId cross EpisodeId) cross N)

axdef
  PossiblePlaylist : P Playlist
where
  PossiblePlaylist = seq((dom status) cross N)
end

(a)

axdef
  length : PossiblePlaylist -> N
where
  length(<>) = 0 and \
    forall pl : PossiblePlaylist | (forall ple : ((dom status) cross N) | \
      length(<ple> ^ pl) = snd(ple) + length(pl))
end

(b)

axdef
  unplayed : PossiblePlaylist -> PossiblePlaylist
where
  unplayed(<>) = <> and \
    forall pl : PossiblePlaylist | (forall ple : ((dom status) cross N) | \
      (fst(status(fst(ple))) = Played) => (unplayed(<ple> ^ pl) = unplayed(pl)) and \
      (fst(status(fst(ple))) = NotP) => (unplayed(<ple> ^ pl) = <ple> ^ (unplayed(pl))))
end

(c)

axdef
  played : PossiblePlaylist -> PossiblePlaylist
where
  played(<>) = <> and \
    forall pl : PossiblePlaylist | (forall ple : ((dom status) cross N) | \
      (fst(status(fst(ple))) = NotP) => (played(<ple> ^ pl) = played(pl)) and \
      (fst(status(fst(ple))) = Played) => (played(<ple> ^ pl) = <ple> ^ (played(pl))))
end

**Question 11**

TEXT: To use proof by induction, we need to prove the base case and the inductive case.  A PossiblePlaylist belongs to P Playlist where Playlist is of type seq((ShowId cross EpisodeId) cross N). The base case occurs when p = <>. Therefore, we must first prove length(played(<>)) + length(unplayed(<>)) = length(<>)

EQUIV:
length(played(<>)) + length(unplayed(<>))
length(<>) + length(<>)     [played(<>) = <> and unplayed(<>) = <>]
0 + 0                       [length(<>) = 0]
0                           [0+0 = 0]
length(<>)                  [length(<>) = 0]

TEXT: In the above, we use each of the individual played(), unplayed(), and length() base cases to justify our rewrites.

TEXT: A playlist element is of type ((dom status) cross N).  We now seek to prove the inductive hypothesis, which follows the form of induction for sequences and which is an implication [cite simpson-notes page 157].

zed

forall t : PossiblePlaylist | (forall ple : ((dom status) cross N) | \
  length(played(t)) + length(unplayed(t)) = length(t) => \
  length(played(<ple> ^ t)) + length(unplayed(<ple> ^ t)) = length(<ple> ^ t))

end

TEXT: The status of a playlist element is of type (PlayedOrNot, SavedOrNot). The inductive hypothesis proof begins by establishing that there are two mutually exclusive and exhaustive cases: one where the playlist element's PlayedOrNot free type value is Played and another where it is NotP.  The proof will establish that for both cases, the same conclusion can be proven. The proof relies upon the inductive hypothesis length(played(t)) + length(unplayed(t)) = length(t). 

TEXT: Case 1: The playlist element is played, which is represented by fst(status fst(ple)) = Played, which says take the status of the ple and inspect the first element of the status tuple and determine whether PlayedOrNot = Played.

EQUIV:
length(played(<ple> ^ t)) + length(unplayed(<ple> ^ t))
length(<ple> ^ played(t)) + length(unplayed(<ple> ^ t)) [played(<ple> ^ pl) = <ple> ^ (played(pl))]
length(<ple> ^ played(t)) + length(unplayed(t))         [unplayed(<ple> ^ pl) = unplayed(pl)] 
snd(ple) + length(played(t)) + length(unplayed(t))      [length(<ple> ^ pl) = snd(ple) + length(pl)]
snd(ple) + (length(played(t)) + length(unplayed(t)))    [associativity of addition]
snd(ple) + length (t)                                   [length(played(p)) + length(unplayed(p)) = length(p)]
length(<ple> ^ t)                                       [length(<ple> ^ pl) = snd(ple) + length(pl)]

TEXT: We first rewrite the played term as we know ple is Played and then we simplify the unplayed term as we know ple is not NotP. From here, we apply the definition of length for a single sequence element concatenated to a sequence. Using the associative property of addition, we arrive at a form of the inductive hypothesis that we can simplify.  From there, we apply our definition of length again to arrive at our final form.

TEXT: Case 2: The playlist element is not played, which is represented by fst(status fst(ple)) = NotP, which says take the status of the ple and inspect the first element of the status tuple and determine whether PlayedOrNot = NotP.

EQUIV:
length(played(<ple> ^ t)) + length(unplayed(<ple> ^ t))
length(played(<ple> ^ t)) + length(<ple> ^ unplayed(t)) [unplayed(<ple> ^ pl) = <ple> ^ (unplayed(pl))]
length(played(t)) + length(<ple> ^ unplayed(t))         [played(<ple> ^ pl) = played(pl)]
length(played(t)) + snd(ple) + length(unplayed(t))      [length(<ple> ^ pl) = snd(ple) + length(pl)]
snd(ple) + length(played(t)) + length(unplayed(t))      [commutativity of addition]
snd(ple) + (length(played(t)) + length(unplayed(t)))    [associativity of addition]
snd(ple) + length(t)                                    [length(played(p)) + length(unplayed(p)) = length(p)]
length(<ple> ^ t)                                       [length(<ple> ^ pl) = snd(ple) + length(pl)]

TEXT: We first rewrite the unplayed term as we know ple is NotP and then we simplify the played term as we know ple is not Played. From here, we apply the definition of length for a single sequence element concatenated to a sequence. We must re-arrange our addends using the commutative property of addition.  Next, we use the associative property of addition to arrive at a form of the inductive hypothesis that we can simplify.  From there, we apply our definition of length again to arrive at our final form.

TEXT: Since the base case is proven and both inductive cases result in the same outcome, we can use the implication introduction rule [=> intro] to unify our cases and conclude:

PROOF:
forall p : PossiblePlaylist | length(p)
  forall p : PossiblePlaylist | length(played(p)) + length(unplayed(p))

**Question 12**

TEXT: First, we can create an abbreviation for the elements of our list to make our expressions less cumbersome.

ListElement == (ShowId cross EpisodeId) cross (N cross PlayedOrNot cross SavedOrNot)

TEXT: We restate our List free type definition using the abbreviation as

List ::= nil | join <<ListElement cross List>>

TEXT: For example, such a List could include (join((1, 2), (3600, NotP, Saved), (join((1, 1), (3600, Played, Saved)), nil))) which is of the form (join(e, join(e, nil))).

(a) TEXT: We define the induction principle for this List for the proposition Q, building upon the List of natural numbers example found in section 13.3 of the course notes [cite simpson-notes page 162].

PROOF:
forall l : List | Q l
  :: Q nil
  :: forall e : ListElement | forall l : List | Q l => Q(join(e, l))
  
(b) TEXT: Fuzz does not support Z tuple projection such as e.2. Therefore, we define generic access functions for each element of any triple, which we will use with ListElement, together with the previously specified fst() and snd() for tuples.

gendef [A, B, C]
  fstOfTriple : A cross B cross C -> A
where
  forall a : A | forall b : B | forall c : C | fstOfTriple(a, b, c) = a
end

gendef [A, B, C]
  sndOfTriple : A cross B cross C -> B
where
  forall a : A | forall b : B | forall c : C | sndOfTriple(a, b, c) = b
end

gendef [A, B, C]
  thrdOfTriple : A cross B cross C -> C
where
  forall a : A | forall b : B | forall c : C | thrdOfTriple(a, b, c) = c
end

TEXT: Next, we specify our recursive functions

axdef
  length_L : List -> N
where
  length_L(nil) = 0
  forall e : ListElement | (forall l : List | length_L(join(e, l)) = fstOfTriple(snd(e)) + length_L(l))
end

TEXT: The length of a List is the recursive sum of seconds : N, found in the first position of the triple found in the second element of the tuple of each ListElement.

axdef
  unplayed_L : List -> List
where
  unplayed_L(nil) = nil
  forall e : ListElement | (forall l : List | sndOfTriple(snd(e)) = NotP | unplayed_L(join(e, l)) = join(e, unplayed_L(l)))
  forall e : ListElement | (forall l : List | sndOfTriple(snd(e)) = Played | unplayed_L(join(e, l)) = unplayed_L(l))
end

TEXT: The unplayed list of any given list is a new list, which recursively includes or excludes each ListElement based on the PlayedOrNot free type value of NotP found in the second position of the triple found in the second element of the tuple of each ListElement. 

axdef
  played_L : List -> List
where
  played_L(nil) = nil
  forall e : ListElement | (forall l : List | sndOfTriple(snd(e)) = Played | played_L(join(e, l)) = join(e, played_L(l)))
  forall e : ListElement | (forall l : List | sndOfTriple(snd(e)) = NotP | played_L(join(e, l)) = played_L(l))
end

TEXT: The played list of any given list is a new list, which recursively includes or excludes each ListElement based on the PlayedOrNot free type value of Played found in the second position of the triple found in the second element of the tuple of each ListElement. 

(c) TEXT: To use proof by induction, we need to prove the base case and the inductive case. 

forall l : List | length_L(played_L(l)) + length_L(unplayed_L(l)) = length_L(l)

TEXT: The base case occurs when the List is nil.

EQUIV:
length_L(played_L(nil)) + length_L(unplayed_L(nil))
length_L(nil) + length_L(nil)             [(un)played_L(nil) = nil]
0 + 0                                     [length_L(nil) = 0]
0                                         [arithmetic]
length_L(nil)                             [length_L(nil) = 0]

TEXT: In the above, we use each of the definitions of played_L(nil), unplayed_L(nil), and length_L(nil) to prove our base case.  Now we have to move to our inductive case 

length_L(played(l)) + length_L(unplayed(l)) = length_L(l) => \
  length_L(played(join(e, l))) + length_L(unplayed(join(e, l))) = length_L(join(e, l))

TEXT: To establish this implication is true, we must prove it all cases. For this statement, e : ListElement is included in played_L's output or unplayed_L's output based on the value of its free type PlayedOrNot, which can only have one of two states that map directly to these two outcomes.  Therefore, we have two cases, one where e's PlayedOrNot value is Played and another where the value is NotP.

PAGEBREAK:

TEXT: Case 1: e's PlayedOrNot = Played

EQUIV:
length_L(played(join(e, l))) + length_L(unplayed(join(e, l)))
length_L(played(join(e, l))) + length_L(unplayed(l))                [def of unplayed_L(join(e, l))]
length_L(join(e, played(l))) + length_L(unplayed(l))                [def of played_L(join(e, l))]
fstOfTriple(snd(e)) + length_L(played(l)) + length_L(unplayed(l))   [def of length_L(join(e, l))]
fstOfTriple(snd(e)) + (length_L(played(l)) + length_L(unplayed(l))) [associativity of addition]
fstOfTriple(snd(e)) + length_L(l)                                   [inductive hypothesis]
length_L(join(e, l))                                                [def of length_L(join(e, l))]

TEXT: Case 2: e's PlayedOrNot = NotP

EQUIV:
length_L(played(join(e, l))) + length_L(unplayed(join(e, l)))
length_L(played(l)) + length_L(unplayed(join(e, l)))                [def of played_L(join(e, l))]
length_L(played(l)) + length_L(join(e, unplayed(l)))                [def of unplayed_L(join(e, l))]
length_L(played(l)) + fstOfTriple(snd(e)) + length_L(unplayed(l))   [def of length_L(join(e, l))]
fstOfTriple(snd(e)) + length_L(played(l)) + length_L(unplayed(l))   [commutativity of addition]
fstOfTriple(snd(e)) + (length_L(played(l)) + length_L(unplayed(l))) [associativity of addition]
fstOfTriple(snd(e)) + length_L(l)                                   [inductive hypothesis]
length_L(join(e, l))                                                [def of length_L(join(e, l))]

TEXT: Having shown both cases result in the same outcome, we can unify our cases and conclude:

PROOF:
forall l : List | length_L(played(join(e, l))) + length_L(unplayed(join(e, l))) = length_L(join(e, l))
  forall l : List | length_L(played(l)) + length_L(unplayed(l)) = length_L(l)

TEXT: Since the base case is proven and both inductive cases result in the same outcome, we can use the implication introduction rule [=> intro] to unify our cases (n.b. Length_L is abbreviated L below to spare the reader further font scaling) and conclude:

PROOF:
forall l : List | L(l)
  :: L(nil)
  :: forall l : List | L(played(l)) + L(unplayed(l)) = L(l) => L(played(join(e, l))) + L(unplayed(join(e, l))) = L(join(e, l))

TEXT: we have proven forall l : List | length_L(played_L(l)) + length_L(unplayed_L(l)) = length_L(l)

PAGEBREAK:
