=== Propositional Logic ===

TEXT: N.B. Many answers leverage the grammar's order of precedence (not, and, or, =>, <=>) rather than pedagogical or clarifying parenthesis.

** Question 1 **

(a) TRUTH TABLE:                                                                            
p | not p | (not p => p) | p => (not p => p)
T | F | T | T                                  
F | T | F | T

TEXT: p => (not p => p) is a tautology as it is true for every interpretation of p as illustrated by the final column of truth values.


(b) TRUTH TABLE:                                                                            
p | q | (q => p) | not p | not q | (not p => not q) | (not p => not q) <=> (q => p)
t | t | t | f | f | t | t
t | f | t | f | t | t | t
f | t | f | t | f | f | t
f | f | t | t | t | t | t

TEXT: The statements (not p =>  not q), (q => p) are equivalent and (not p =>  not q) <=> (q => p) is a tautology as it is true for every interpretation of p, q as illustrated by the final column of truth values.

(c) TRUTH TABLE:
p | q | r | (p => r) | (q => r) | ((p =>r) and (q => r)) | (p or q) | ((p or q) => r) | <=>
t | t | t | t | t | t | t | t | t
t | t | f | f | f | f | t | f | t
t | f | t | t | t | t | t | t | t
t | f | f | f | t | f | t | f | t
f | t | t | t | t | t | t | t | t
f | t | f | t | f | f | t | f | t
f | f | t | t | t | t | f | t | t
f | f | f | t | t | t | f | t | t

TEXT: The statements ((p => r) and (q => r)), ((p or q) => r) are equivalent and ((p => r) and (q => r)) <=> ((p or q) => r) is a tautology as it is true for every interpretation of p, q, r as illustrated by the final column of truth values.

** Question 2 **

(a) EQUIV:
p => (not p => p) 
p => (not not p or p) [=> disjunction]
p => (p or p) [not not]
p => p [idempotence of p]
true [tautology]

TEXT: In this equivalence proof, we show that p => (not p => p) by using implication disjunction to replace the implication with a logical or, the definition of double negation to simplify, the application of the idempotence rule to simplify, and the fact that p => p is a tautology. 

(b) EQUIV:
(not p => not q)
(not not p or not q) [=> disjunction]
(p or not q) [not not]
(not q or p) [commutativity of or]
q => p [=> disjunction]

TEXT: In this equivalance proof, we show that (not p => not q) <=> q => p by using implication disjunction to replace implication with logical or, the definition of double negation to simplify, the commutivity property of logical or to change the order of the elements, and the implication disjunction rule to reintroduce implication.

(c) EQUIV:
((p => r) and (q => r))
((not p or r) and (not q or r)) [=> disjunction]
(r or not p) and (r or not q) [commutativity of or]
r or (not p and not q) [distributivity 2]
(not p and not q) or r [commutativity of or]
not (p or q) or r [De Morgan]
p or q => r [=> disjunction]

TEXT: In this equivalence proof, we show that ((p => r) and (q => r)) <=> (p or q) => r by using the implication disjunction rule to replace implication with logical or, the commutativity of or rule to change the order of the elements, the distributivity 2 rule to extract r, and the commutivity of logical or to change the order of the elements, De Morgan to extract negation for (not p and not q), and the implication disjunction rule to reintroduce implication.

** Question 3 **

(a) PROOF: 
  p => (not p => p) [=> intro from 1]
    [1] p [assumption]
        not p => p [=> intro from 2]
          [2] not p [assumption]
          :: p [from 1]

TEXT: In this proof, we assume p, assume not p, use the implication introduction rule to arrive at not p => p and to discharge not p as an assumption, use the implication introduction rule to arrive at p => (not p => p) and to discharge the p assumption.

(b) 

TEXT: This proof involves equivalence or bi-implication, which requires us to show p => q and q => p given this is the definition of p <=> q.

TEXT: In one direction, we are seeking to prove (not p => not q) => q => p:

PROOF:
  (not p => not q) => (q => p) [=> intro from 1]
    [1] not p => not q [assumption]
    :: q => p [=> intro from 2]
      [2] q [assumption]
      :: p [false elim from 3]
        false [false intro]
          :: not q [=> elim]
            :: not p => not q [from 1]
            [3] not p [assumption]
          :: q [from 2]

TEXT: and in the other, we are seeking to prove (q => p) => (not p => not q):

PROOF:
  (q => p) => (not p => not q) [=> intro from 1]
    [1] q => p [assumption]
    :: not p => not q [=> intro from 2]
      [2] not p [assumption]
      :: not q [false elim from 3]
        false [false intro]
          :: p [=> elim]
            :: q => p [from 1]
            [3] q [assumption]
          :: not p [from 2]

TEXT: We then combine these two proofs with the <=>-intro rule, using the results from above:

PROOF:
  (not p => not q) <=> (q => p) [<=> intro]
    :: (not p => not q) => (q => p)
    :: (q => p) => (not p => not q)

(c)

TEXT: In one direction, we are seeking to prove (p => r) and (q => r) => (p or q => r):

PROOF:
  ((p => r) and (q => r)) => ((p or q) => r) [=> intro from 1]
    [1] (p => r) and (q => r) [assumption]
    :: (p or q) => r [=> intro from 2]
      [2] p or q [assumption]
      :: r [or elim from 3]
        case p:
          :: p => r [and elim 1]
            :: (p => r) and (q => r) [from 1]
          :: r [=> elim]
            [3] p [assumption]
        case q:
          :: q => r [and elim 2]
            :: (p => r) and (q => r) [from 1]
          :: r [=> elim]
            [3] q [assumption]

TEXT: In the other direction, we are seeking to prove (p or q => r) => (p => r) and (q => r):

PROOF:
((p or q) => r) => ((p => r) and (q => r))  [=> intro from 1]
  [1] ((p or q) => r) [assumption]
  :: ((p => r) and (q => r)) [and intro]
    :: p => r [=> intro from 2]
      p [from 2]
      :: r [=> elim]
        :: (p or q) => r [from 1]
        :: p or q [or intro1]
          [2] p [assumption]
    :: q => r [=> intro from 3]
      [3] q [assumption]
      :: r [=> elim]
        :: (p or q) => r [from 1]
        :: p or q [or intro1]
          [2] p [assumption]

TEXT: We then combine these two proofs with the <=>-intro rule, using the results from above:

PROOF:
  ((p => r) and (q => r)) <=> ((p or q) => r) [<=> intro]
    :: ((p => r) and (q => r)) => ((p or q) => r)
    :: ((p or q) => r) => ((p => r) and (q => r)) 


PAGEBREAK:

=== Bibliography ===

TEXT: Course Notes

TEXT: Simpson A n.d. From Discrete Mathematics to State-Based Models SEM version. University of Oxford Department of Computer Science. Unpublished course notes.

TEXT: Primary Textbook

TEXT: Woodcock J. and Davies J. 1996 Using Z Specification Refinement and Proof. Upper Saddle River NJ Prentice Hall.

TEXT: Lecture Slides

TEXT: Simpson A 2025a Lecture schedule. Lecture slides for Software Engineering Mathematics. University of Oxford Department of Computer Science. Lecture 00.

TEXT: Simpson A 2025b Introduction and propositions. Lecture slides for Software Engineering Mathematics. University of Oxford Department of Computer Science. Lecture 01.

TEXT: Simpson A 2025c Predicate logic and equality. Lecture slides for Software Engineering Mathematics. University of Oxford Department of Computer Science. Lecture 02.

TEXT: Simpson A 2025d Deductive proofs. Lecture slides for Software Engineering Mathematics. University of Oxford Department of Computer Science. Lecture 03.

TEXT: Simpson A 2025e Sets types and definitions. Lecture slides for Software Engineering Mathematics. University of Oxford Department of Computer Science. Lecture 04.

TEXT: Simpson A 2025f Relations. Lecture slides for Software Engineering Mathematics. University of Oxford Department of Computer Science. Lecture 05.

TEXT: Simpson A 2025g Functions and sequences. Lecture slides for Software Engineering Mathematics. University of Oxford Department of Computer Science. Lecture 06.

TEXT: Simpson A 2025h Free types and induction. Lecture slides for Software Engineering Mathematics. University of Oxford Department of Computer Science. Lecture 07.

TEXT: Course Materials

TEXT: Simpson A 2025i Exercises for Software Engineering Mathematics. University of Oxford Department of Computer Science. Unpublished course materials.

TEXT: Simpson A 2025j Solutions for Software Engineering Mathematics. University of Oxford Department of Computer Science. Unpublished course materials.

TEXT: Additional References from Course Materials

TEXT: Abrial J-R 1996 The B-Book Assigning Meanings to Programs. Cambridge Cambridge University Press.

TEXT: Simpson A.C. 2002 Discrete Mathematics by Example. London McGraw-Hill.

TEXT: Spivey J.M. 1992 The Z Notation A Reference Manual. Upper Saddle River NJ Prentice Hall.