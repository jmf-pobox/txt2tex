\documentclass[a4paper,10pt,fleqn]{article}
\usepackage[margin=1in]{geometry}
\usepackage{amssymb}
\usepackage{adjustbox}
\usepackage{natbib}
\usepackage{fuzz}
\usepackage{zed-maths}
\usepackage{zed-proof}
\usepackage[colorlinks=true,linkcolor=blue,citecolor=blue,urlcolor=blue]{hyperref}
\newdimen\savedleftskip
\title{Software Engineering Mathematics}
\author{Anonymised Submission \thanks{Software Engineering Programme}
\thanks{University of Oxford}}
\date{October 2025}
\begin{document}

\maketitle

\newpage

\setcounter{tocdepth}{1}
\tableofcontents

\newpage

\section*{Question 1}
\addcontentsline{toc}{section}{Question 1}

\noindent A tautology is a statement that is true for every valuation
of the propositional variables it contains. A contradiction is a
statement that is false for each such valuation. A contingency is a
statement that is neither a tautology nor a contradiction.
\citep[Page 13]{simpson-notes}.

\bigskip

\noindent\hspace*{\parindent}(a)

\setlength{\leftskip}{\dimexpr\parindent+2em\relax}
\savedleftskip=\leftskip
\noindent
\adjustbox{max width=\dimexpr\textwidth-\savedleftskip\relax}{%
  \begin{tabular}{c|c|c|c}
    $p$ & $\lnot p$ & $( \lnot p \Rightarrow p )$ & $\mathbf{p
    \Rightarrow ( \lnot p \Rightarrow p )}$ \\
    \hline
    \textit{t} & \textit{f} & \textit{t} & \textbf{t} \\
    \textit{f} & \textit{t} & \textit{f} & \textbf{t} \\
  \end{tabular}%
}
\bigskip

\bigskip

\setlength{\leftskip}{\dimexpr\parindent+2em\relax}
\noindent $p \implies (\lnot p \implies p)$ is a tautology as it is
true for every interpretation of p as illustrated by the final column
of truth values.

\bigskip

\setlength{\leftskip}{0pt}
\medskip

\noindent\hspace*{\parindent}(b)

\setlength{\leftskip}{\dimexpr\parindent+2em\relax}
\savedleftskip=\leftskip
\noindent
\adjustbox{max width=\dimexpr\textwidth-\savedleftskip\relax}{%
  \begin{tabular}{c|c|c|c|c|c|c}
    $p$ & $q$ & $( q \Rightarrow p )$ & $\lnot p$ & $\lnot q$ & $(
    \lnot p \Rightarrow \lnot q )$ & $\mathbf{( \lnot p \Rightarrow
    \lnot q ) \Leftrightarrow ( q \Rightarrow p )}$ \\
    \hline
    \textit{t} & \textit{t} & \textit{t} & \textit{f} & \textit{f} &
    \textit{t} & \textbf{t} \\
    \textit{t} & \textit{f} & \textit{t} & \textit{f} & \textit{t} &
    \textit{t} & \textbf{t} \\
    \textit{f} & \textit{t} & \textit{f} & \textit{t} & \textit{f} &
    \textit{f} & \textbf{t} \\
    \textit{f} & \textit{f} & \textit{t} & \textit{t} & \textit{t} &
    \textit{t} & \textbf{t} \\
  \end{tabular}%
}
\bigskip

\bigskip

\setlength{\leftskip}{\dimexpr\parindent+2em\relax}
\noindent The statements $(\lnot p \implies \lnot q)$, $(q \implies
p)$ are equivalent and $(\lnot p \implies \lnot q) \iff (q \implies
p)$ is a tautology as it is true for every interpretation of p, q as
illustrated by the final column of truth values.

\bigskip

\setlength{\leftskip}{0pt}
\medskip

\noindent\hspace*{\parindent}(c)

\setlength{\leftskip}{\dimexpr\parindent+2em\relax}
\savedleftskip=\leftskip
\noindent
\adjustbox{max width=\dimexpr\textwidth-\savedleftskip\relax}{%
  \begin{tabular}{c|c|c|c|c|c|c|c|c}
    $p$ & $q$ & $r$ & $( p \Rightarrow r )$ & $( q \Rightarrow r )$ &
    $( ( p \Rightarrow r ) \land ( q \Rightarrow r ) )$ & $( p \lor q
    )$ & $( ( p \lor q ) \Rightarrow r )$ & $\mathbf{( ( p
      \Rightarrow r ) \land ( q \Rightarrow r ) ) \Leftrightarrow ( ( p
    \lor q ) \Rightarrow r )}$ \\
    \hline
    \textit{t} & \textit{t} & \textit{t} & \textit{t} & \textit{t} &
    \textit{t} & \textit{t} & \textit{t} & \textbf{t} \\
    \textit{t} & \textit{t} & \textit{f} & \textit{f} & \textit{f} &
    \textit{f} & \textit{t} & \textit{f} & \textbf{t} \\
    \textit{t} & \textit{f} & \textit{t} & \textit{t} & \textit{t} &
    \textit{t} & \textit{t} & \textit{t} & \textbf{t} \\
    \textit{t} & \textit{f} & \textit{f} & \textit{f} & \textit{t} &
    \textit{f} & \textit{t} & \textit{f} & \textbf{t} \\
    \textit{f} & \textit{t} & \textit{t} & \textit{t} & \textit{t} &
    \textit{t} & \textit{t} & \textit{t} & \textbf{t} \\
    \textit{f} & \textit{t} & \textit{f} & \textit{t} & \textit{f} &
    \textit{f} & \textit{t} & \textit{f} & \textbf{t} \\
    \textit{f} & \textit{f} & \textit{t} & \textit{t} & \textit{t} &
    \textit{t} & \textit{f} & \textit{t} & \textbf{t} \\
    \textit{f} & \textit{f} & \textit{f} & \textit{t} & \textit{t} &
    \textit{t} & \textit{f} & \textit{t} & \textbf{t} \\
  \end{tabular}%
}
\bigskip

\bigskip

\setlength{\leftskip}{\dimexpr\parindent+2em\relax}
\noindent The statements $((p \implies r) \land (q \implies r))$,
$((p \lor q) \implies r)$ are equivalent and $((p \implies r) \land
(q \implies r))$ $\Leftrightarrow$ $((p \lor q) \implies r)$ is a
tautology as it is true for every interpretation of p, q, r as
illustrated by the final column of truth values.

\bigskip

\setlength{\leftskip}{0pt}
\section*{Question 2}
\addcontentsline{toc}{section}{Question 2}

\noindent\hspace*{\parindent}(a)
\begin{center}
  \adjustbox{max width=\textwidth}{%
    $\displaystyle
    \begin{array}{l@{\hspace{2em}}r}
      p \implies (\lnot p \implies p) \\
      \Leftrightarrow p \implies (\lnot \lnot p \lor p) &
      [\mbox{$\Rightarrow$ disjunction}] \\
      \Leftrightarrow p \implies (p \lor p) & [\mbox{negation is an
      involution}] \\
      \Leftrightarrow p \implies p & [\mbox{idempotence of p}] \\
      \Leftrightarrow true & [\mbox{tautology}]
    \end{array}$%
  }
\end{center}
\bigskip

\bigskip

\setlength{\leftskip}{\dimexpr\parindent+2em\relax}
\noindent In this equivalence, we prove that $p \implies (\lnot p
\implies p)$ by starting with implication disjunction to replace the
implication with a logical or \citep[page 17]{simpson-notes}. Next,
we use the definition of double negation \citep[Slide 25]{simpson25a}
and the application of the idempotence rule to simplify \citep[Slide
26]{simpson25a}. We trivially conclude with the fact that $p \implies
p$ is a tautology.

\bigskip

\newpage

\setlength{\leftskip}{0pt}
\medskip

\noindent\hspace*{\parindent}(b)
\begin{center}
  \adjustbox{max width=\textwidth}{%
    $\displaystyle
    \begin{array}{l@{\hspace{2em}}r}
      \lnot p \implies \lnot q \\
      \Leftrightarrow \lnot \lnot p \lor \lnot q &
      [\mbox{$\Rightarrow$ disjunction}] \\
      \Leftrightarrow p \lor \lnot q & [\mbox{negation is an involution}] \\
      \Leftrightarrow \lnot q \lor p & [\mbox{commutativity of $\lor$}] \\
      \Leftrightarrow q \implies p & [\mbox{$\Rightarrow$ disjunction}]
    \end{array}$%
  }
\end{center}
\bigskip

\bigskip

\setlength{\leftskip}{\dimexpr\parindent+2em\relax}
\noindent In this equivalance proof, we show that $(\lnot p \implies
\lnot q) \iff q \implies p$ by using implication disjunction to
replace implication with logical or, the definition of double
negation to simplify, the commutivity property of logical or to
change the order of the elements \citep[Slide 27]{simpson25a}, and
the implication disjunction rule to reintroduce implication.

\bigskip

\setlength{\leftskip}{0pt}
\medskip

\noindent\hspace*{\parindent}(c)
\begin{center}
  \adjustbox{max width=\textwidth}{%
    $\displaystyle
    \begin{array}{l@{\hspace{2em}}r}
      (p \implies r) \land (q \implies r) \\
      \Leftrightarrow (\lnot p \lor r) \land (\lnot q \lor r) &
      [\mbox{$\Rightarrow$ disjunction}] \\
      \Leftrightarrow (r \lor \lnot p) \land (r \lor \lnot q) &
      [\mbox{commutativity of $\lor$}] \\
      \Leftrightarrow r \lor (\lnot p \land \lnot q) &
      [\mbox{distributivity 2}] \\
      \Leftrightarrow (\lnot p \land \lnot q) \lor r &
      [\mbox{commutativity of $\lor$}] \\
      \Leftrightarrow \lnot (p \lor q) \lor r & [\mbox{De Morgan 1}] \\
      \Leftrightarrow p \lor q \implies r & [\mbox{$\Rightarrow$ disjunction}]
    \end{array}$%
  }
\end{center}
\bigskip

\bigskip

\setlength{\leftskip}{\dimexpr\parindent+2em\relax}
\noindent In this equivalence proof, we show that $((p \implies r)
\land (q \implies r))$ $\Leftrightarrow$ $(p \lor q)$ $\Rightarrow$ r
by using the implication disjunction rule to replace implication with
logical or, the commutativity of or rule to change the order of the
elements \citep[Slide 27]{simpson25a}, the distributivity 2 rule to
extract r \citep[Slide 29]{simpson25a}, and the commutivity of
logical or to change the order of the elements, De Morgan's Law to
extract negation for $(\lnot p \land \lnot q)$ \citep[Slide
28]{simpson25a}, and the implication disjunction rule to reintroduce
implication.

\bigskip

\setlength{\leftskip}{0pt}
\section*{Question 3}
\addcontentsline{toc}{section}{Question 3}

\noindent\hspace*{\parindent}(a)

\begin{center}
  \adjustbox{max width=\textwidth}{%
    $\displaystyle
    \infer[\Rightarrow\textrm{-intro}^{[1]}]{p \implies (\lnot p \implies p)}{
      \ulcorner p \urcorner^{[1]}
      &
      \infer[\Rightarrow\textrm{-intro}^{[2]}]{\lnot p \implies
      p}{\ulcorner \lnot p \urcorner^{[2]} &
        \infer[false\textrm{-elim}^{[3]}]{p}{\infer[\mathrm{false} -
          \mathrm{intro}]{false}{\ulcorner p \urcorner^{[1]} & \ulcorner
      \lnot p \urcorner^{[3]}}}}
    }
    $%
  }
\end{center}
\bigskip

\bigskip

\setlength{\leftskip}{\dimexpr\parindent+2em\relax}
\noindent For this proof we are seeking to prove that p $\Rightarrow$
$(\lnot p \implies p)$, which we know holds given the truth table in
1(a). Working mechanically from the bottom, we start by applying the
implication introduction rule to identify and discharge assumption
[1] to gain our conclusion \citep[Slide 3]{simpson25h} and again we
use the implication introduction rule to identify and discharge
assumption [2] to gain $(\lnot p \implies p)$.  We note that this
statement requires that we have both p and $\lnot p$ as premisses,
which implies we need to use false in the proof. With some
experimentation, we realize we need three assumptions and we
introduce a third assumption [3]. We first use false-intro followed
by false-elim1 to discharge assumption [3] \citep[Slide
6]{simpson25h}. In the final proof, all assumptions are discharged
properly. We note that this proof bears some similarities with the
rules of negation proof in the course notes section 4.8 \citep[Pages
41-46]{simpson-notes} which has multiple degrees of negation of p as
assumptions. The key is to have $\lnot p$ as an assumption twice at
different scopes.

\bigskip

\newpage

\setlength{\leftskip}{0pt}
\medskip

\noindent\hspace*{\parindent}(b)

\setlength{\leftskip}{\dimexpr\parindent+2em\relax}
\noindent This proof involves equivalence or bi-implication.

\bigskip

\bigskip

\setlength{\leftskip}{\dimexpr\parindent+2em\relax}
\noindent In one direction, we are seeking to prove $(\lnot p
\implies \lnot q)$ $\Rightarrow$ $(q \implies p)$:

\bigskip

\savedleftskip=\leftskip
\noindent
\adjustbox{max width=\dimexpr\textwidth-\savedleftskip\relax}{%
  $\displaystyle
  \infer[\Rightarrow\textrm{-intro}^{[1]}]{(\lnot p \implies \lnot q)
  \implies (q \implies p)}{
    \ulcorner \lnot p \implies \lnot q \urcorner^{[1]}
    &
    \infer[\Rightarrow\textrm{-intro}^{[2]}]{q \implies p}{
      \ulcorner q \urcorner^{[2]}
      &
      \infer[false\textrm{-elim}^{[3]}]{p}{
        \infer[\mathrm{false} - \mathrm{intro}]{false}{
          \infer[\Rightarrow \mathrm{elim}]{\lnot q}{
            \ulcorner \lnot p \implies \lnot q \urcorner^{[1]}
            &
            \ulcorner \lnot p \urcorner^{[3]}
          }
          &
          \ulcorner q \urcorner^{[2]}
        }
      }
    }
  }
  $%
}
\bigskip

\noindent I started working mechanically from the bottom by applying
the implication introduction rule to construct the conclusion.  This
gave me $q \implies p$ as the key premise to build up, which requires
applying the implication introduction rule to q and p. Looking at the
need for q and looking at the need for p and $(\lnot p \implies \lnot
q)$ as assumption [1], I felt it would be best to try $\lnot p$ as an
assumption to at least get going.  This enabled me to work top down
to get $\lnot q$ from the implication elimination rule. From there, I
realized that I needed the negation of both $\lnot q$ and $\lnot p$.
I knew the false-intro and false-elim were required, but it took some
experimentation to see that I could get both $\lnot q$ and $\lnot p$
transformed into p and q by making $\lnot p$ assumption [3] instead
of [2] and introducing q as assumption [2]. Once that insight was
made, I could arrive at p as a result of the top of the tree and
retain q [2] as an assumption coming out of false-elim. This is what
I needed to arrive at $q \implies p$ and to connect the bottom and
top portions of my proof.  All assumptions are properly discharged.

\bigskip

\noindent and in the other, we are seeking to prove $(q \implies p)$
$\Rightarrow$ $(\lnot p \implies \lnot q)$:

\bigskip

\savedleftskip=\leftskip
\noindent
\adjustbox{max width=\dimexpr\textwidth-\savedleftskip\relax}{%
  $\displaystyle
  \infer[\Rightarrow\textrm{-intro}^{[1]}]{(q \implies p) \implies
  (\lnot p \implies \lnot q)}{
    \ulcorner q \implies p \urcorner^{[1]}
    &
    \infer[\Rightarrow\textrm{-intro}^{[2]}]{\lnot p \implies \lnot q}{
      \ulcorner \lnot p \urcorner^{[2]}
      &
      \infer[false\textrm{-elim}^{[3]}]{\lnot q}{
        \infer[\mathrm{false} - \mathrm{intro}]{false}{
          \infer[\Rightarrow \mathrm{elim}]{p}{
            \ulcorner q \implies p \urcorner^{[1]}
            &
            \ulcorner q \urcorner^{[3]}
          }
          &
          \ulcorner \lnot p \urcorner^{[2]}
        }
      }
    }
  }
  $%
}
\bigskip

\noindent Working mechanically from the bottom, I apply the
implication rule to $q \implies p$ as assumption [1] to gain the
conclusion.  I need $(\lnot p \implies \lnot q)$, which shows me to
use the implication rule again with $\lnot p$ as assumption [2].
From there, the question is how to get $\lnot q$.

\bigskip

\noindent Now working from the top, given assumption [1] has q, it
makes sense to use the implication elimation rule with q as
assumption [3]. This gives me p, when what I want is $\lnot q$.  I
see that if I introduce $\lnot p$ as assumption [3] that I can negate
q via the false-intro and false-elim rules and successfully discharge
assumption [3]. This gives me $\lnot q$, which is what I need to
connect to the top tree to the bottom of the proof. This proof came
more quickly because $q \implies p$ as assumption [1] gave clear
direction for the top portion. All assumptions are discharged and
scopes are appropriate.

\bigskip

\noindent We then combine these two proofs with the
$\Leftrightarrow$-intro rule \citep[Slide 4]{simpson25h}, using the
results from above to conclude our proof.

\bigskip

\savedleftskip=\leftskip
\noindent
\adjustbox{max width=\dimexpr\textwidth-\savedleftskip\relax}{%
  $\displaystyle
  \infer[\Leftrightarrow \mathrm{intro}]{(\lnot p \implies \lnot q)
  \iff (q \implies p)}{
    (\lnot p \implies \lnot q) \implies (q \implies p)
    &
    (q \implies p) \implies (\lnot p \implies \lnot q)
  }
  $%
}
\bigskip

\newpage

\setlength{\leftskip}{0pt}
\medskip

\noindent\hspace*{\parindent}(c)

\setlength{\leftskip}{\dimexpr\parindent+2em\relax}
\noindent In one direction, we are seeking to prove $((p \implies r)
\land (q \implies r))$ $\Rightarrow$ $((p \lor q) \implies r)$

\bigskip

\bigskip

\setlength{\leftskip}{\dimexpr\parindent+2em\relax}
\savedleftskip=\leftskip
\noindent
\adjustbox{max width=\dimexpr\textwidth-\savedleftskip\relax}{%
  $\displaystyle
  \infer[\Rightarrow\textrm{-intro}^{[1]}]{((p \implies r) \land (q
  \implies r)) \implies ((p \lor q) \implies r)}{
    \ulcorner (p \implies r) \land (q \implies r) \urcorner^{[1]}
    &
    \infer[\Rightarrow\textrm{-intro}^{[2]}]{(p \lor q) \implies r}{
      \ulcorner p \lor q \urcorner^{[2]}
      &
      \infer[\lor\textrm{-elim}^{[2]}]{r}{
        \ulcorner p \lor q \urcorner^{[2]}
        &
        \raiseproof{12ex}{\infer[\Rightarrow \mathrm{elim}]{r}{
            \ulcorner p \urcorner^{[2]}
            &
            \infer[\land\textrm{-elim-1}]{(p \implies r)}{
              \ulcorner (p \implies r) \land (q \implies r) \urcorner^{[1]}
            }
        }}
        &
        \hskip 6em \raiseproof{30ex}{\infer[\Rightarrow \mathrm{elim}]{r}{
            \ulcorner q \urcorner^{[2]}
            &
            \infer[\land\textrm{-elim-2}]{(q \implies r)}{
              \ulcorner (p \implies r) \land (q \implies r) \urcorner^{[1]}
            }
        }}
      }
    }
  }
  $%
}
\bigskip

\noindent In this proof, I start by working from the bottom
mechanically, taking $(p \implies r) \land (q \implies r)$ as
assumption [1] and applying the implication introduction rule to
arrive at our conclusion and discharge assumption [1]. From there, I
can see that I need $(p \lor q)$ and r as inputs to the implication
introduction rule.  I take $(p \lor q)$ as assumption [2] and
discharge this assumption via the implication introduction rule.
That leaves me with r as the result of my bottom up process.

\bigskip

\noindent As I have already made assumptions $((p \implies r) \land
(q \implies r))$ [1] and $(p \lor q)$ [2] and they are related, I
start by working with both top-down. I begin with $(p \lor q)$ [2]
and create cases for p and q working towards or elimination.  The p
and q sub-branches are marked with [2] as the assumption as these are
just the cases for $(p \lor q)$ [2] \citep[slide 41]{simpson25c}.
Next, I apply and elimination in each case to get $(p \implies r)$,
$(q \implies r)$ with the appropriate p or q cases in the
sub-branches.  From there, I apply implication elimination to arrive
at r in both cases.  This enables me to use the or elimination
together with $(p \lor q)$ [2] to simplify to r.

\bigskip

\noindent At this stage, I do not discharge assumption [2], as this
is deferred until the next step. I use implication introduction
together with $(p \lor q)$ [2] and r from the or elimination to
discharge assumption [2], which connects the top-down and bottom-up
process. All assumptions are properly discharged.

\bigskip

\noindent In the other direction, we are seeking to prove $((p \lor
q) \implies r)$ $\Rightarrow$ $((p \implies r) \land (q \implies r))$:

\bigskip

\savedleftskip=\leftskip
\noindent
\adjustbox{max width=\dimexpr\textwidth-\savedleftskip\relax}{%
  $\displaystyle
  \infer[\Rightarrow\textrm{-intro}^{[1]}]{((p \lor q) \implies r)
  \implies ((p \implies r) \land (q \implies r))}{
    \ulcorner ((p \lor q) \implies r) \urcorner^{[1]}
    &
    \infer[\land \mathrm{intro}]{((p \implies r) \land (q \implies r))}{
      \infer[\Rightarrow\textrm{-intro}^{[2]}]{p \implies r}{
        \ulcorner p \urcorner^{[2]}
        &
        \infer[\Rightarrow \mathrm{elim}]{r}{
          \ulcorner (p \lor q) \implies r \urcorner^{[1]}
          &
          \infer[\lor\textrm{-intro-1}]{p \lor q}{
            \ulcorner p \urcorner^{[2]}
          }
        }
      }
      &
      \infer[\Rightarrow\textrm{-intro}^{[3]}]{q \implies r}{
        \ulcorner q \urcorner^{[3]}
        &
        \infer[\Rightarrow \mathrm{elim}]{r}{
          \ulcorner (p \lor q) \implies r \urcorner^{[1]}
          &
          \infer[\lor\textrm{-intro-2}]{p \lor q}{
            \ulcorner q \urcorner^{[3]}
          }
        }
      }
    }
  }
  $%
}
\bigskip

\noindent Working mechanically from the bottom, we start by taking
$((p \lor q) \implies r)$ as assumption [1] and applying the
implication introduction rule to discharge assumption [1].  This
leaves us with $((p \implies r) \land (q \implies r))$, which is
derived from $p \implies r$, $q \implies r$ and the application of
the and introduction rule. Fairly clearly, we need two sub-branches
to be developed top-down. Since we have $((p \lor q) \implies r)$ and
we want $p \implies r$ and $q \implies r$, I start with p [2] and q
[3] to start the top-down sub-trees.  I struggled here until I
recalled that I could use the or intro rule to satisfy $(p \lor q)$.
I also had to recall that this does not generate additional
assumptions to discharge \citep[slide 38]{simpson25c}. From here, it
was not difficult to use implication elimation to arrive at r in both
sub-trees and to apply p [2] and q [3] in each tree with the
implication introduction rule to discharge those assumptions.  This
gave me $p \implies r$, $q \implies r$ and I used the and
introduction rule to connect the top and bottom portions of the
proof. All assumptions are properly discharged.

\bigskip

\noindent We then combine these two proofs with the
$\Leftrightarrow$-intro rule, using the results from above to
conclude our proof:

\bigskip

\savedleftskip=\leftskip
\noindent
\adjustbox{max width=\dimexpr\textwidth-\savedleftskip\relax}{%
  $\displaystyle
  \infer[\Leftrightarrow \mathrm{intro}]{((p \implies r) \land (q
  \implies r)) \iff ((p \lor q) \implies r)}{
    ((p \implies r) \land (q \implies r)) \implies ((p \lor q) \implies r)
    &
    ((p \lor q) \implies r) \implies ((p \implies r) \land (q \implies r))
  }
  $%
}
\bigskip

\setlength{\leftskip}{0pt}
\section*{Question 4}
\addcontentsline{toc}{section}{Question 4}

\noindent We are defining a generic function that will return the
difference in length between the longest and shorest sequences from
an input type that is a non-empty sequences of sequences. The input
could be $\langle  \langle x, y, z \rangle, \langle \rangle  \rangle$
yielding 3 as output or $\langle \langle x \rangle \rangle$ yielding
0, for example. I specify three generic functions: maxSeq yields the
longest sequence from a non-empty sequence of sequences; minSeq
yields the shortest sequence from a non-empty sequence of sequences;
and maxDiff, which fulfills the specification for Question 4.

\bigskip

\begin{gendef}[X]
  maxSeq: \seq_1 (\seq X) \fun \seq X \\
  minSeq: \seq_1 (\seq X) \fun \seq X \\
  maxDiff: \seq_1 (\seq X) \fun \nat
  \where
  \forall ss : \seq_1 (\seq X) @ maxSeq(ss) = (\mu s : \ran ss |
  \forall t : \ran ss @ \# s \geq \# t) \\
  \forall ss : \seq_1 (\seq X) @ minSeq(ss) = (\mu s : \ran ss |
  \forall t : \ran ss @ \# s \leq \# t) \\
  \forall ss : \seq_1 (\seq X) @ maxDiff(ss) = (\# (maxSeq(ss)) - \#
  (minSeq(ss)))
\end{gendef}

\noindent For maxSeq and minSeq, a mu function is defined that
selects a single element meeting the specification based on comparing
every sequence s with every sequence t. First, the range operator
moves us from a sequence of sequences with ss values such as $\langle
1  \mapsto  \langle x, y, z \rangle, 2  \mapsto  \langle \rangle
\rangle$ to sequences s, t with values like $\langle x, y, z
\rangle$, $\langle \rangle$ to enable seq operators. maxSeq and
minSeq use the  operators and maxDiff uses the length operators with
subtraction \citep[Page 40]{simpson25f}. For maxDiff, $maxSeq \geq
minDiff$ is a valid pre-condition by virtue of maxSeq and minSeq and
therefore the subtraction is guaranteed to return a natural number as
defined in the specification, making maxSeq() a total function
\citep[Page 119]{simpson-notes}. This solution passes fuzz validation.

\bigskip

\section*{Question 5}
\addcontentsline{toc}{section}{Question 5}

\noindent The relational composition operator is associative:

\bigskip

\hspace*{1em} $(R \circ S) \circ T = R \circ (S \circ T)$

\noindent if $R \in W$ $\rel$ X, $S \in X$ $\rel$ Y, and $T \in Y$ $\rel$ Z.

\bigskip

\noindent In this equivalence proof, we show that composition is
associative using the definition of relational composition and by
repositioning quantifiers and predicates where we are permitted to do
so, which is only when there is no impact to the truth value of the
predicates involved. Each such repositioning or regrouping will be justified.

\bigskip

\noindent Given a relation $R \in X$ $\rel$ Y and a second relation
$S \in Y$ $\rel$ Z, and two elements $x \in X$ and $z \in Z$, x
$\mapsto$ $z \in R$ $\circ$ S $\Leftrightarrow$ $\exists y : Y @ x
\mapsto y \in R \land y \mapsto z \in S$ \citep[page 107]{simpson-notes}.

\bigskip

\begin{center}
  \adjustbox{max width=\textwidth}{%
    $\displaystyle
    \begin{array}{l@{\hspace{2em}}r}
      w \mapsto z \in (R \circ S) \circ T \\
      \Leftrightarrow \exists y : Y @ w \mapsto y \in (R \circ S)
      \land y \mapsto z \in T & [\mbox{definition of $\circ$}] \\
      \Leftrightarrow \exists y : Y @ (\exists x : X @ w \mapsto x
      \in R \land x \mapsto y \in S) \land y \mapsto z \in T &
      [\mbox{definition of $\circ$}] \\
      \Leftrightarrow \exists y : Y @ \exists x : X @ w \mapsto x \in
      R \land x \mapsto y \in S \land y \mapsto z \in T & [\mbox{x is
      $\lnot$ free $\in$ y $\mapsto$ z $\in$ T}] \\
      \Leftrightarrow \exists x : X @ w \mapsto x \in R \land
      (\exists y : Y @ x \mapsto y \in S \land y \mapsto z \in T) &
      [\mbox{y is $\lnot$ free $\in$ w $\mapsto$ x $\in$ R}] \\
      \Leftrightarrow \exists x : X @ w \mapsto x \in R \land x
      \mapsto z \in (S \circ T) & [\mbox{definition of $\circ$}] \\
      \Leftrightarrow w \mapsto z \in R \circ (S \circ T)
    \end{array}$%
  }
\end{center}
\bigskip

\noindent In step 1, we apply the composition equivalence to the
outer composition of (R $\circ$ S) $\circ$ T. In step 2, we apply our
equivalence to the inner composition (R $\circ$ S).  In step 3, we
include the predicate y $\mapsto$ $z \in T$ in the scope of x : X. We
can do this because this does not affect the truth values of y
$\mapsto$ $z \in T$ as x is not free in this predicate. In step 4, we
reposition the exists y : Y quantifier to be after the w $\mapsto$ $x
\in R$ predicate without affecting its truth values because y is not
free in w $\mapsto$ $x \in R$.  In step 5, we apply the equivalence
for composition to S $\circ$ T.  In step 6, we apply the equivalence
for composition to R $\circ$ (S $\circ$ T).

\bigskip

\noindent I worked on this proof both top-down and bottom-up.  After
doing the obvious equivalence substitutions, I was left with step 3
and 4 to work out. In working out step 3, I could see from step 6
that I wanted S $\circ$ T together.  In working out step 4, I could
see that y : Y needed to be repositioned to setup step 6.  The
reasoning about both of these steps was not obvious at first, but I
realized that these moves had no impact on the truth values of the
affected predicates.  This led me to think about free and bound
variables and what rules might apply in various cases \citep[Pages
54-55]{simpson-notes}.  I was not able to find a specific
justification in the materials that maps to the idea that one can
reposition quantifiers or predicates provided there is no inpact to
the truth values, but this seems logical and sound provided x is not
$free \in P$ for the affected P. I note the parallels with the logic
for substition operations \citep[Pages 56-57]{simpson-notes}.

\bigskip

\section*{Question 6}
\addcontentsline{toc}{section}{Question 6}

\noindent The following set comprehensions are presented using Z
axiomatic definitions to enable direct fuzz validation of the LaTeX.
Further, exponents are written long-hand as fuzz does not  support
exponentation.

\bigskip

\noindent\hspace*{\parindent}(a)
\begin{axdef}
  SquaresOfEvens : \power \num
  \where
  SquaresOfEvens = \{ z : \num | z \mod 2 = 0 @ z * z \}
\end{axdef}

\medskip

\noindent\hspace*{\parindent}(b)
\begin{axdef}
  CubesOfSquaresOfEvens : \power \num
  \where
  CubesOfSquaresOfEvens = \{ z : \num | z \mod 2 = 0 @ (z * z) * (z *
  z) * (z * z) \}
\end{axdef}

\medskip

\noindent\hspace*{\parindent}(c)
\begin{axdef}
  SquareCubePairsOfEvens : \power (\num \cross \num)
  \where
  SquareCubePairsOfEvens = \{ z_1, z_2 : \num | z_1 \mod 2 = 0 \land
  z_2 \mod 2 = 0 @ (z_1 * z_1, z_2 * z_2 * z_2) \}
\end{axdef}

\medskip

\noindent\hspace*{\parindent}(d)
\begin{axdef}
  SquareCubeIdentityPairsOfEvens : \power (\num \cross \num)
  \where
  SquareCubeIdentityPairsOfEvens = \{ z : \num | z \mod 2 = 0 @ (z *
  z, z * z * z) \}
\end{axdef}

\medskip

\noindent\hspace*{\parindent}(e)
\begin{axdef}
  SetsOfSquareOrCubeIntegers : \power (\power  \num)
  \where
  SetsOfSquareOrCubeIntegers = \power \{ z, z_0 : \num | z = z_0 *
  z_0 \lor z = z_0 * z_0 * z_0 @ z \}
\end{axdef}

\bigskip

\setlength{\leftskip}{\dimexpr\parindent+2em\relax}
\newpage

\setlength{\leftskip}{0pt}
\section*{Question 7}
\addcontentsline{toc}{section}{Question 7}

\begin{zed}[ShowId, PeopleId]
\end{zed}

\begin{zed}
  EpisodeId == \nat_1
\end{zed}

\begin{zed}
  Timestamp == \nat
\end{zed}

\begin{gendef}[X, Y]
  fst: X \cross Y \fun X
  \where
  \forall a : X @ \forall b : Y @ fst(a, b) = a
\end{gendef}

\begin{gendef}[X, Y]
  snd: X \cross Y \fun Y
  \where
  \forall a : X @ \forall b : Y @ snd(a, b) = b
\end{gendef}

\begin{axdef}
  shows : \finset ShowId \\
  show\_episodes : ShowId \pfun \finset EpisodeId \\
  episode\_info : ShowId \cross EpisodeId \pfun (\finset PeopleId
  \cross Timestamp) \\
  show\_info : ShowId \pfun \finset PeopleId
  \where
  shows \subseteq \dom show\_episodes \land \dom show\_episodes
  \subseteq shows \\
  \forall es : \ran show\_episodes @ \exists n : \nat @ es = 1 \upto n \\
  \forall s : \dom show\_episodes @ \forall e : show\_episodes(s) @ \\
  \quad (s, e) \in \dom episode\_info \iff s \in \dom show\_episodes \\
  shows \subseteq \dom show\_info \land \dom show\_info \subseteq shows \\
  \forall s : ShowId @ \forall p : PeopleId @ \exists e : EpisodeId @ \\
  \quad (s, e) \in \dom episode\_info \land \\
  \quad (p \in fst(episode\_info(s, e)) \iff p \in show\_info(s)) \\
  \forall s : ShowId @ \forall t_1, t_2 : Timestamp @ \forall e_1,
  e_2 : EpisodeId @ \\
  \quad ((s, e_1) \in \dom episode\_info \land (s, e_2) \in \dom
  episode\_info) \land \\
  \quad ((e_1 < e_2) \implies (snd(episode\_info(s, e_1)) \leq
  snd(episode\_info(s, e_2))))
\end{axdef}

\noindent\hspace*{\parindent}(a) $shows \subseteq \dom show\_episodes
\land \dom show\_episodes \subseteq shows$

\medskip

\noindent\hspace*{\parindent}(b) $\forall es : \ran show\_episodes @
\exists n : \nat @ es = 1 \upto n$

\medskip

\noindent\hspace*{\parindent}(c)

\setlength{\leftskip}{\dimexpr\parindent+2em\relax}
\savedleftskip=\leftskip
\noindent
$\displaystyle
\begin{array}{l}
  \forall s : \dom show\_episodes @ \forall e : show\_episodes(s) @ \\
  \quad (s, e) \in \dom episode\_info \iff s \in \dom show\_episodes
\end{array}$

\bigskip

\setlength{\leftskip}{0pt}
\medskip

\noindent\hspace*{\parindent}(d) $shows \subseteq \dom show\_info
\land \dom show\_info \subseteq shows$

\medskip

\noindent\hspace*{\parindent}(e)

\setlength{\leftskip}{\dimexpr\parindent+2em\relax}
\savedleftskip=\leftskip
\noindent
$\displaystyle
\begin{array}{l}
  \forall s : ShowId @ \forall p : PeopleId @ \exists e : EpisodeId @ \\
  \quad (s, e) \in \dom episode\_info \land \\
  \quad (p \in fst(episode\_info(s, e)) \iff p \in show\_info(s))
\end{array}$

\bigskip

\setlength{\leftskip}{0pt}
\medskip

\noindent\hspace*{\parindent}(f)

\setlength{\leftskip}{\dimexpr\parindent+2em\relax}
\savedleftskip=\leftskip
\noindent
$\displaystyle
\begin{array}{l}
  \forall s : ShowId @ \forall t_1, t_2 : Timestamp @ \forall e_1,
  e_2 : EpisodeId @ \\
  \quad ((s, e_1) \in \dom episode\_info \land (s, e_2) \in \dom
  episode\_info) \land \\
  \quad ((e_1 < e_2) \implies (snd(episode\_info(s, e_1)) \leq
  snd(episode\_info(s, e_2))))
\end{array}$

\bigskip

\bigskip

\setlength{\leftskip}{\dimexpr\parindent+2em\relax}
\newpage

\setlength{\leftskip}{0pt}
\section*{Question 8}
\addcontentsline{toc}{section}{Question 8}

\noindent The following are given as abbreviations to enable fuzz
validation, which passes for each expression.

\bigskip

\begin{zed}
  EightA == \{ s : \dom show\_episodes | \# (show\_episodes(s)) \geq 100 \}
\end{zed}

\noindent Shows with at least 100 episodes.  We use the cardinality
operator on F EpisodeId after ensuring s is in the domain of show\_episodes.

\bigskip

\begin{zed}
  EightB == \{ p : PeopleId | \exists s_1, s_2 : \dom show\_info @
  s_1 \neq s_2 \land p \in show\_info(s_1) \land p \in show\_info(s_2) \}
\end{zed}

\noindent The set of PeopleId, which appear in 2 or more shows.  We
make sure two such shows are distinct and we validate each $PeopleId
\in F$ PeopleId.

\bigskip

\begin{axdef}
  first\_episode\_timestamp : ShowId \pfun Timestamp
  \where
  \forall s : ShowId @ (s, 1) \in \dom episode\_info \land
  first\_episode\_timestamp(s) = snd(episode\_info(s, 1))
\end{axdef}

\begin{zed}
  EightC == first\_episode\_timestamp((\mu s : \dom show\_info | \\
      \quad \forall t : \dom show\_info @ s \neq t \land \\
  \quad \# (show\_info(s)) > \# (show\_info(t))))
\end{zed}

\noindent We are given that there is exactly one show with the most
people and we want the timestamp for the first episode of that show.
This involves two operations, finding the show with the most people
and finding the timestamp for the first episode of that show.  For
the first operation, we compare the cardinality of the F PeopleId for
every pair s, t : ShowId in the domain of show\_info. This is
captured in the mu expression, which returns the single matching value.

\bigskip

\noindent For the second operation, we define a partial function
first\_episode\_timestamp that yields the Timestamp for $EpisodeId =
1$ for $s : ShowId$.  We are guaranteed that $EpisodeId = 1$ exists
by constraint 7(b). In addition, calling this function with the s
from the mu expression is valid because the constraint defined in
7(e) guarantees that the set of EpisodeId in the domain of show\_info
and in the first element of the domain of episode\_info are identical.

\bigskip

\section*{Question 9}
\addcontentsline{toc}{section}{Question 9}

\begin{zed}PlayedOrNot ::= Played | NotP
\end{zed}

\begin{zed}SavedOrNot ::= Saved | NotS
\end{zed}

\begin{axdef}
  my\_shows : \finset ShowId \\
  my\_episodes : \iseq (ShowId \cross EpisodeId) \\
  status : ShowId \cross EpisodeId \pfun (PlayedOrNot \cross SavedOrNot)
  \where
  my\_shows \subseteq shows \\
  \forall s : ShowId @ \forall e : EpisodeId @ (s, e) \in \ran
  my\_episodes \land \\
  \quad e \in show\_episodes(s) \\
  \forall s : ShowId @ \forall e : EpisodeId @ s \in my\_shows \land \\
  \quad (s, e) \in \ran my\_episodes \\
  \forall s : ShowId @ \forall e : EpisodeId @ \\
  \quad (s, e) \in \ran my\_episodes \implies ((s, e) \in \dom status \land \\
  \quad (s, e) \in \dom status \implies (s, e) \in \ran my\_episodes)
\end{axdef}

\newpage

\section*{Question 10}
\addcontentsline{toc}{section}{Question 10}

\begin{zed}
  Playlist == \seq ((ShowId \cross EpisodeId) \cross \nat)
\end{zed}

\begin{axdef}
  PossiblePlaylist : \power Playlist
  \where
  PossiblePlaylist = \seq (\dom status \cross \nat)
\end{axdef}

\noindent\hspace*{\parindent}(a)
\begin{axdef}
  length : PossiblePlaylist \fun \nat
  \where
  length(\langle \rangle) = 0 \land \\
  \quad (\forall pl : PossiblePlaylist @ \forall ple : (\dom status
    \cross \nat) @ \\
  \quad length(\langle ple \rangle \cat pl) = snd(ple) + length(pl))
\end{axdef}

\medskip

\noindent\hspace*{\parindent}(b)
\begin{axdef}
  unplayed : PossiblePlaylist \fun PossiblePlaylist
  \where
  unplayed(\langle \rangle) = \langle \rangle \land \\
  \quad (\forall pl : PossiblePlaylist @ \forall ple : (\dom status
    \cross \nat) @ \\
    \quad (fst(status(fst(ple))) = Played) \implies
    ((unplayed(\langle ple \rangle \cat pl) = unplayed(pl)) \land \\
      \quad (fst(status(fst(ple))) = NotP) \implies (unplayed(\langle ple
  \rangle \cat pl) = \langle ple \rangle \cat unplayed(pl))))
\end{axdef}

\medskip

\noindent\hspace*{\parindent}(c)
\begin{axdef}
  played : PossiblePlaylist \fun PossiblePlaylist
  \where
  played(\langle \rangle) = \langle \rangle \land \\
  \quad (\forall pl : PossiblePlaylist @ \forall ple : (\dom status
    \cross \nat) @ \\
    \quad (fst(status(fst(ple))) = NotP) \implies ((played(\langle
      ple \rangle \cat pl) = played(pl)) \land \\
      \quad (fst(status(fst(ple))) = Played) \implies (played(\langle ple
  \rangle \cat pl) = \langle ple \rangle \cat played(pl))))
\end{axdef}

\section*{Question 11}
\addcontentsline{toc}{section}{Question 11}

\noindent To use proof by induction, we need to prove the base case
and the inductive case.  A PossiblePlaylist belongs to P Playlist
where Playlist is of type seq((ShowId cross EpisodeId) cross N). The
base case occurs when p = $\langle \rangle$. Therefore, we must first
prove length(played($\langle \rangle$)) + length(unplayed($\langle
\rangle$)) = length($\langle \rangle$)

\bigskip

\begin{center}
  \adjustbox{max width=\textwidth}{%
    $\displaystyle
    \begin{array}{l@{\hspace{2em}}r}
      length(played(\langle \rangle)) + length(unplayed(\langle \rangle)) \\
      \Leftrightarrow length(\langle \rangle) + length(\langle
      \rangle) & [\mbox{played($\langle \rangle$)=$\langle \rangle$
      $\land$ unplayed($\langle \rangle$)=$\langle \rangle$}] \\
      \Leftrightarrow 0 + 0 & [\mbox{length($\langle \rangle$)=0}] \\
      \Leftrightarrow 0 & [\mbox{0 + 0=0}] \\
      \Leftrightarrow length(\langle \rangle) &
      [\mbox{length($\langle \rangle$)=0}]
    \end{array}$%
  }
\end{center}
\bigskip

\noindent In the above, we use each of the individual played(),
unplayed(), and length() base cases to justify our rewrites.

\bigskip

\noindent A playlist element is of type ((dom status) cross N).  We
now seek to prove the inductive hypothesis, which follows the form of
induction for sequences and which is an implication \citep[page
157]{simpson-notes}.

\bigskip

\begin{zed}
  \forall t : PossiblePlaylist @ \forall ple : (\dom status \cross \nat) @ \\
  \quad length(played(t)) + length(unplayed(t)) = length(t) \implies \\
  \quad length(played(\langle ple \rangle \cat t)) +
  length(unplayed(\langle ple \rangle \cat t)) = length(\langle ple
  \rangle \cat t)
\end{zed}

\noindent The status of a playlist element is of type (PlayedOrNot,
SavedOrNot). The inductive hypothesis proof begins by establishing
that there are two mutually exclusive and exhaustive cases: one where
the playlist element's PlayedOrNot free type value is Played and
another where it is NotP.  The proof will establish that for both
cases, the same conclusion can be proven. The proof relies upon the
inductive hypothesis length(played(t)) + length(unplayed(t)) = length(t).

\bigskip

\noindent Case 1: The playlist element is played, which is
represented by fst(status fst(ple)) = Played, which says take the
status of the ple and inspect the first element of the status tuple
and determine whether $PlayedOrNot = Played$.

\bigskip

\begin{center}
  \adjustbox{max width=\textwidth}{%
    $\displaystyle
    \begin{array}{l@{\hspace{2em}}r}
      length(played(\langle ple \rangle \cat t)) +
      length(unplayed(\langle ple \rangle \cat t)) \\
      \Leftrightarrow length(\langle ple \rangle \cat played(t)) +
      length(unplayed(\langle ple \rangle \cat t)) &
      [\mbox{played($\langle  ple  \rangle$ $\cat$ pl)=$\langle  ple
      \rangle$ $\cat$(played(pl))}] \\
      \Leftrightarrow length(\langle ple \rangle \cat played(t)) +
      length(unplayed(t)) & [\mbox{unplayed($\langle  ple  \rangle$
      $\cat$ pl)=unplayed(pl)}] \\
      \Leftrightarrow snd(ple) + length(played(t)) +
      length(unplayed(t)) & [\mbox{length($\langle  ple  \rangle$
      $\cat$ pl)=snd(ple)+ length(pl)}] \\
      \Leftrightarrow snd(ple) + (length(played(t)) +
      length(unplayed(t))) & [\mbox{associativity of addition}] \\
      \Leftrightarrow snd(ple) + length(t) &
      [\mbox{length(played(p))+ length(unplayed(p))=length(p)}] \\
      \Leftrightarrow length(\langle ple \rangle \cat t) &
      [\mbox{length($\langle  ple  \rangle$ $\cat$ pl)=snd(ple)+ length(pl)}]
    \end{array}$%
  }
\end{center}
\bigskip

\noindent We first rewrite the played term as we know ple is Played
and then we simplify the unplayed term as we know ple is not NotP.
From here, we apply the definition of length for a single sequence
element concatenated to a sequence. Using the associative property of
addition, we arrive at a form of the inductive hypothesis that we can
simplify.  From there, we apply our definition of length again to
arrive at our final form.

\bigskip

\noindent Case 2: The playlist element is not played, which is
represented by fst(status fst(ple)) = NotP, which says take the
status of the ple and inspect the first element of the status tuple
and determine whether $PlayedOrNot = NotP$.

\bigskip

\begin{center}
  \adjustbox{max width=\textwidth}{%
    $\displaystyle
    \begin{array}{l@{\hspace{2em}}r}
      length(played(\langle ple \rangle \cat t)) +
      length(unplayed(\langle ple \rangle \cat t)) \\
      \Leftrightarrow length(played(\langle ple \rangle \cat t)) +
      length(\langle ple \rangle \cat unplayed(t)) &
      [\mbox{unplayed($\langle  ple  \rangle$ $\cat$ pl)=$\langle
      ple  \rangle$ $\cat$(unplayed(pl))}] \\
      \Leftrightarrow length(played(t)) + length(\langle ple \rangle
      \cat unplayed(t)) & [\mbox{played($\langle  ple  \rangle$
      $\cat$ pl)=played(pl)}] \\
      \Leftrightarrow length(played(t)) + snd(ple) +
      length(unplayed(t)) & [\mbox{length($\langle  ple  \rangle$
      $\cat$ pl)=snd(ple)+ length(pl)}] \\
      \Leftrightarrow snd(ple) + length(played(t)) +
      length(unplayed(t)) & [\mbox{commutativity of addition}] \\
      \Leftrightarrow snd(ple) + (length(played(t)) +
      length(unplayed(t))) & [\mbox{associativity of addition}] \\
      \Leftrightarrow snd(ple) + length(t) &
      [\mbox{length(played(p))+ length(unplayed(p))=length(p)}] \\
      \Leftrightarrow length(\langle ple \rangle \cat t) &
      [\mbox{length($\langle  ple  \rangle$ $\cat$ pl)=snd(ple)+ length(pl)}]
    \end{array}$%
  }
\end{center}
\bigskip

\noindent We first rewrite the unplayed term as we know ple is NotP
and then we simplify the played term as we know ple is not Played.
From here, we apply the definition of length for a single sequence
element concatenated to a sequence. We must re-arrange our addends
using the commutative property of addition.  Next, we use the
associative property of addition to arrive at a form of the inductive
hypothesis that we can simplify.  From there, we apply our definition
of length again to arrive at our final form.

\bigskip

\noindent Since the base case is proven and both inductive cases
result in the same outcome, we can use the implication introduction
rule [$\Rightarrow$ intro] to unify our cases and conclude:

\bigskip

\begin{center}
  \adjustbox{max width=\textwidth}{%
    $\displaystyle
    \infer{\forall p : PossiblePlaylist @ length(p)}{
      \forall p : PossiblePlaylist @ length(played(p)) + length(unplayed(p))
    }
    $%
  }
\end{center}
\bigskip

\newpage

\section*{Question 12}
\addcontentsline{toc}{section}{Question 12}

\noindent First, we can create an abbreviation for the elements of
our list to make our expressions less cumbersome.

\bigskip

\begin{zed}
  ListElement == (ShowId \cross EpisodeId) \cross (\nat \cross
  PlayedOrNot \cross SavedOrNot)
\end{zed}

\noindent We restate our List free type definition using the abbreviation as

\bigskip

\begin{zed}List ::= nil | join \ldata ListElement \cross List \rdata
\end{zed}

\noindent For example, such a List could include (join((1, 2), (3600,
NotP, Saved), (join((1, 1), (3600, Played, Saved)), nil))) which is
of the form (join(e, join(e, nil))).

\bigskip

\noindent\hspace*{\parindent}(a)

\setlength{\leftskip}{\dimexpr\parindent+2em\relax}
\noindent We define the induction principle for this List for the
proposition Q, building upon the List of natural numbers example
found in section 13.3 of the course notes \citep[page 162]{simpson-notes}.

\bigskip

\bigskip

\setlength{\leftskip}{\dimexpr\parindent+2em\relax}
\savedleftskip=\leftskip
\noindent
\adjustbox{max width=\dimexpr\textwidth-\savedleftskip\relax}{%
  $\displaystyle
  \infer{\forall l : List @ Q(l)}{
    Q(nil)
    &
    \forall e : ListElement @ \forall l : List @ Q(l) \implies Q(join(e, l))
  }
  $%
}
\bigskip

\setlength{\leftskip}{0pt}
\medskip

\noindent\hspace*{\parindent}(b)

\setlength{\leftskip}{\dimexpr\parindent+2em\relax}
\noindent Fuzz does not support Z tuple projection such as e.2.
Therefore, we define generic access functions for each element of any
triple, which we will use with ListElement, together with the
previously specified fst() and snd() for tuples.

\bigskip

\bigskip

\setlength{\leftskip}{\dimexpr\parindent+2em\relax}
\begin{gendef}[A, B, C]
  fstOfTriple: A \cross B \cross C \fun A
  \where
  \forall a : A @ \forall b : B @ \forall c : C @ fstOfTriple(a, b, c) = a
\end{gendef}

\begin{gendef}[A, B, C]
  sndOfTriple: A \cross B \cross C \fun B
  \where
  \forall a : A @ \forall b : B @ \forall c : C @ sndOfTriple(a, b, c) = b
\end{gendef}

\begin{gendef}[A, B, C]
  thrdOfTriple: A \cross B \cross C \fun C
  \where
  \forall a : A @ \forall b : B @ \forall c : C @ thrdOfTriple(a, b, c) = c
\end{gendef}

\noindent Next, we specify our recursive functions

\bigskip

\begin{axdef}
  length\_L : List \fun \nat
  \where
  length\_L(nil) = 0 \\
  \forall e : ListElement @ \forall l : List @ length\_L(join(e, l))
  = fstOfTriple(snd(e)) + length\_L(l)
\end{axdef}

\noindent The length of a List is the recursive sum of seconds : N,
found in the first position of the triple found in the second element
of the tuple of each ListElement.

\bigskip

\begin{axdef}
  unplayed\_L : List \fun List
  \where
  unplayed\_L(nil) = nil \\
  \forall e : ListElement @ \forall l : List @ sndOfTriple(snd(e)) =
  NotP \land unplayed\_L(join(e, l)) = join(e, unplayed\_L(l)) \\
  \forall e : ListElement @ \forall l : List @ sndOfTriple(snd(e)) =
  Played \land unplayed\_L(join(e, l)) = unplayed\_L(l)
\end{axdef}

\noindent The unplayed list of any given list is a new list, which
recursively includes or excludes each ListElement based on the
PlayedOrNot free type value of NotP found in the second position of
the triple found in the second element of the tuple of each ListElement.

\bigskip

\begin{axdef}
  played\_L : List \fun List
  \where
  played\_L(nil) = nil \\
  \forall e : ListElement @ \forall l : List @ sndOfTriple(snd(e)) =
  Played \land played\_L(join(e, l)) = join(e, played\_L(l)) \\
  \forall e : ListElement @ \forall l : List @ sndOfTriple(snd(e)) =
  NotP \land played\_L(join(e, l)) = played\_L(l)
\end{axdef}

\noindent The played list of any given list is a new list, which
recursively includes or excludes each ListElement based on the
PlayedOrNot free type value of Played found in the second position of
the triple found in the second element of the tuple of each ListElement.

\bigskip

\setlength{\leftskip}{0pt}
\medskip

\noindent\hspace*{\parindent}(c)

\setlength{\leftskip}{\dimexpr\parindent+2em\relax}
\noindent To use proof by induction, we need to prove the base case
and the inductive case.

\bigskip

\bigskip

\setlength{\leftskip}{\dimexpr\parindent+2em\relax}
\noindent
$\forall l : List @ length\_L(played\_L(l)) +
length\_L(unplayed\_L(l)) = length\_L(l)$

\noindent The base case occurs when the List is nil.

\bigskip

\savedleftskip=\leftskip
\noindent
\adjustbox{max width=\dimexpr\textwidth-\savedleftskip\relax}{%
  $\displaystyle
  \begin{array}{l@{\hspace{2em}}r}
    length\_L(played\_L(nil)) + length\_L(unplayed\_L(nil)) \\
    \Leftrightarrow length\_L(nil) + length\_L(nil) &
    [\mbox{(un)played\_L(nil)=nil}] \\
    \Leftrightarrow 0 + 0 & [\mbox{length\_L(nil)=0}] \\
    \Leftrightarrow 0 & [\mbox{arithmetic}] \\
    \Leftrightarrow length\_L(nil) & [\mbox{length\_L(nil)=0}]
  \end{array}$%
}
\bigskip

\noindent In the above, we use each of the definitions of
played\_L(nil), unplayed\_L(nil), and length\_L(nil) to prove our
base case.  Now we have to move to our inductive case

\bigskip

\savedleftskip=\leftskip
\noindent
$\displaystyle
\begin{array}{l}
  length\_L(played(l)) + length\_L(unplayed(l)) = length\_L(l) \implies \\
  \quad length\_L(played(join(e, l))) + length\_L(unplayed(join(e,
  l))) = length\_L(join(e, l))
\end{array}$

\bigskip

\noindent To establish this implication is true, we must prove it all
cases. For this statement, e : ListElement is included in played\_L's
output or unplayed\_L's output based on the value of its free type
PlayedOrNot, which can only have one of two states that map directly
to these two outcomes.  Therefore, we have two cases, one where e's
PlayedOrNot value is Played and another where the value is NotP.

\bigskip

\newpage

\noindent Case 1: e's $PlayedOrNot = Played$

\bigskip

\savedleftskip=\leftskip
\noindent
\adjustbox{max width=\dimexpr\textwidth-\savedleftskip\relax}{%
  $\displaystyle
  \begin{array}{l@{\hspace{2em}}r}
    length\_L(played(join(e, l))) + length\_L(unplayed(join(e, l))) \\
    \Leftrightarrow length\_L(played(join(e, l))) +
    length\_L(unplayed(l)) & [\mbox{def of unplayed\_L(join(e,l))}] \\
    \Leftrightarrow length\_L(join(e, played(l))) +
    length\_L(unplayed(l)) & [\mbox{def of played\_L(join(e,l))}] \\
    \Leftrightarrow fstOfTriple(snd(e)) + length\_L(played(l)) +
    length\_L(unplayed(l)) & [\mbox{def of length\_L(join(e,l))}] \\
    \Leftrightarrow fstOfTriple(snd(e)) + (length\_L(played(l)) +
    length\_L(unplayed(l))) & [\mbox{associativity of addition}] \\
    \Leftrightarrow fstOfTriple(snd(e)) + length\_L(l) &
    [\mbox{inductive hypothesis}] \\
    \Leftrightarrow length\_L(join(e, l)) & [\mbox{def of length\_L(join(e,l))}]
  \end{array}$%
}
\bigskip

\noindent Case 2: e's $PlayedOrNot = NotP$

\bigskip

\savedleftskip=\leftskip
\noindent
\adjustbox{max width=\dimexpr\textwidth-\savedleftskip\relax}{%
  $\displaystyle
  \begin{array}{l@{\hspace{2em}}r}
    length\_L(played(join(e, l))) + length\_L(unplayed(join(e, l))) \\
    \Leftrightarrow length\_L(played(l)) + length\_L(unplayed(join(e,
    l))) & [\mbox{def of played\_L(join(e,l))}] \\
    \Leftrightarrow length\_L(played(l)) + length\_L(join(e,
    unplayed(l))) & [\mbox{def of unplayed\_L(join(e,l))}] \\
    \Leftrightarrow length\_L(played(l)) + fstOfTriple(snd(e)) +
    length\_L(unplayed(l)) & [\mbox{def of length\_L(join(e,l))}] \\
    \Leftrightarrow fstOfTriple(snd(e)) + length\_L(played(l)) +
    length\_L(unplayed(l)) & [\mbox{commutativity of addition}] \\
    \Leftrightarrow fstOfTriple(snd(e)) + (length\_L(played(l)) +
    length\_L(unplayed(l))) & [\mbox{associativity of addition}] \\
    \Leftrightarrow fstOfTriple(snd(e)) + length\_L(l) &
    [\mbox{inductive hypothesis}] \\
    \Leftrightarrow length\_L(join(e, l)) & [\mbox{def of length\_L(join(e,l))}]
  \end{array}$%
}
\bigskip

\noindent Having shown both cases result in the same outcome, we can
unify our cases and conclude:

\bigskip

\savedleftskip=\leftskip
\noindent
\adjustbox{max width=\dimexpr\textwidth-\savedleftskip\relax}{%
  $\displaystyle
  \infer{\forall l : List @ length\_L(played(join(e, l))) +
  length\_L(unplayed(join(e, l))) = length\_L(join(e, l))}{
    \forall l : List @ length\_L(played(l)) + length\_L(unplayed(l))
    = length\_L(l)
  }
  $%
}
\bigskip

\noindent Since the base case is proven and both inductive cases
result in the same outcome, we can use the implication introduction
rule [$\Rightarrow$ intro] to unify our cases and conclude:

\bigskip

\savedleftskip=\leftskip
\noindent
\adjustbox{max width=\dimexpr\textwidth-\savedleftskip\relax}{%
  $\displaystyle
  \infer{\forall l : List @ L(l)}{
    L(nil)
    &
    \forall l : List @ L(played(l)) + L(unplayed(l)) = L(l) \implies
    L(played(join(e, l))) + L(unplayed(join(e, l))) = L(join(e, l))
  }
  $%
}
\bigskip

\noindent we have proven $\forall l : List @ length\_L(played\_L(l))
+ length\_L(unplayed\_L(l)) = length\_L(l)$

\bigskip

\newpage

\setlength{\leftskip}{0pt}

\begin{thebibliography}{Simpson, n.d.}

  \bibitem[Simpson, n.d.]{simpson-notes} Simpson, A. (n.d.).
  \textit{From Discrete Mathematics to State-Based Models, SEM
  version}. University of Oxford Department of Computer Science.
  Unpublished course notes.

  \bibitem[Simpson, 2002]{simpson02} Simpson, A.C. (2002).
  \textit{Discrete Mathematics by Example}. London: McGraw-Hill.

  \bibitem[Simpson, 2025a]{simpson25a} Simpson, A. (2025a).
  \textit{Introduction and propositions}. Lecture slides for Software
  Engineering Mathematics. University of Oxford Department of
  Computer Science. Lecture 01.

  \bibitem[Simpson, 2025b]{simpson25b} Simpson, A. (2025b).
  \textit{Predicate logic and equality}. Lecture slides for Software
  Engineering Mathematics. University of Oxford Department of
  Computer Science. Lecture 02.

  \bibitem[Simpson, 2025c]{simpson25c} Simpson, A. (2025c).
  \textit{Deductive proofs}. Lecture slides for Software Engineering
  Mathematics. University of Oxford Department of Computer Science. Lecture 03.

  \bibitem[Simpson, 2025d]{simpson25d} Simpson, A. (2025d).
  \textit{Sets, types and definitions}. Lecture slides for Software
  Engineering Mathematics. University of Oxford Department of
  Computer Science. Lecture 04.

  \bibitem[Simpson, 2025e]{simpson25e} Simpson, A. (2025e).
  \textit{Relations}. Lecture slides for Software Engineering
  Mathematics. University of Oxford Department of Computer Science. Lecture 05.

  \bibitem[Simpson, 2025f]{simpson25f} Simpson, A. (2025f).
  \textit{Functions and sequences}. Lecture slides for Software
  Engineering Mathematics. University of Oxford Department of
  Computer Science. Lecture 06.

  \bibitem[Simpson, 2025g]{simpson25g} Simpson, A. (2025g).
  \textit{Free types and induction}. Lecture slides for Software
  Engineering Mathematics. University of Oxford Department of
  Computer Science. Lecture 07.

  \bibitem[Simpson, 2025h]{simpson25h} Simpson, A. (2025g).
  \textit{Proof rules}. Lecture slides for Software Engineering
  Mathematics. University of Oxford Department of Computer Science. Lecture 03.

  \bibitem[Spivey, 1992]{spivey92} Spivey, J.M. (1992). \textit{The Z
  Notation: A Reference Manual}. Upper Saddle River, NJ: Prentice Hall.

  \bibitem[Woodcock and Davies, 1996]{woodcock96} Woodcock, J. and
  Davies, J. (1996). \textit{Using Z: Specification, Refinement and
  Proof}. Upper Saddle River, NJ: Prentice Hall.

\end{thebibliography}

\setlength{\leftskip}{0pt}
\end{document}
