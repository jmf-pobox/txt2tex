\documentclass[a4paper,10pt,fleqn]{article}
\usepackage[margin=1in]{geometry}
\usepackage{amssymb}
\usepackage{natbib}
\usepackage{zed-cm}
\usepackage{zed-maths}
\usepackage{zed-proof}
\begin{document}

\section*{Software Engineering Mathematics}

\bigskip

October 2025

\bigskip

\bigskip

Answers use the order of precedence ($\lnot$, $\land$, $\lor$,
$\Rightarrow$, $\Leftrightarrow$) \citep[Slide 20]{simpson25a}.

\bigskip

\bigskip
\noindent
\textbf{Question 1}

\medskip

\bigskip

Lecture 1 - Propositions

\bigskip

(a)
\par
\vspace{11pt}
\begin{tabular}{c|c|c|c}
  $p$ & $\lnot p$ & $( \lnot p \Rightarrow p )$ & $\mathbf{p
  \Rightarrow ( \lnot p \Rightarrow p )}$ \\
  \hline
  \textit{t} & \textit{f} & \textit{t} & \textbf{t} \\
  \textit{f} & \textit{t} & \textit{f} & \textbf{t} \\
\end{tabular}

\bigskip

$p \Rightarrow (\lnot p \Rightarrow p)$ is a tautology as it is true
for every interpretation of p as illustrated by the final column of
truth values.

\bigskip

\medskip

(b)
\par
\vspace{11pt}
\begin{tabular}{c|c|c|c|c|c|c}
  $p$ & $q$ & $( q \Rightarrow p )$ & $\lnot p$ & $\lnot q$ & $(
  \lnot p \Rightarrow \lnot q )$ & $\mathbf{( \lnot p \Rightarrow
  \lnot q ) \Leftrightarrow ( q \Rightarrow p )}$ \\
  \hline
  \textit{t} & \textit{t} & \textit{t} & \textit{f} & \textit{f} &
  \textit{t} & \textbf{t} \\
  \textit{t} & \textit{f} & \textit{t} & \textit{f} & \textit{t} &
  \textit{t} & \textbf{t} \\
  \textit{f} & \textit{t} & \textit{f} & \textit{t} & \textit{f} &
  \textit{f} & \textbf{t} \\
  \textit{f} & \textit{f} & \textit{t} & \textit{t} & \textit{t} &
  \textit{t} & \textbf{t} \\
\end{tabular}

\bigskip

The statements $(\lnot p \Rightarrow \lnot q)$, $(q \Rightarrow p)$
are equivalent and $(\lnot p \Rightarrow \lnot q) \Leftrightarrow (q
\Rightarrow p)$ is a tautology as it is true for every interpretation
of p, q as illustrated by the final column of truth values.

\bigskip

\medskip

(c)
\par
\vspace{11pt}
\begin{tabular}{c|c|c|c|c|c|c|c|c}
  $p$ & $q$ & $r$ & $( p \Rightarrow r )$ & $( q \Rightarrow r )$ &
  $( ( p \Rightarrow r ) \land ( q \Rightarrow r ) )$ & $( p \lor q
  )$ & $( ( p \lor q ) \Rightarrow r )$ & $\mathbf{\Leftrightarrow}$ \\
  \hline
  \textit{t} & \textit{t} & \textit{t} & \textit{t} & \textit{t} &
  \textit{t} & \textit{t} & \textit{t} & \textbf{t} \\
  \textit{t} & \textit{t} & \textit{f} & \textit{f} & \textit{f} &
  \textit{f} & \textit{t} & \textit{f} & \textbf{t} \\
  \textit{t} & \textit{f} & \textit{t} & \textit{t} & \textit{t} &
  \textit{t} & \textit{t} & \textit{t} & \textbf{t} \\
  \textit{t} & \textit{f} & \textit{f} & \textit{f} & \textit{t} &
  \textit{f} & \textit{t} & \textit{f} & \textbf{t} \\
  \textit{f} & \textit{t} & \textit{t} & \textit{t} & \textit{t} &
  \textit{t} & \textit{t} & \textit{t} & \textbf{t} \\
  \textit{f} & \textit{t} & \textit{f} & \textit{t} & \textit{f} &
  \textit{f} & \textit{t} & \textit{f} & \textbf{t} \\
  \textit{f} & \textit{f} & \textit{t} & \textit{t} & \textit{t} &
  \textit{t} & \textit{f} & \textit{t} & \textbf{t} \\
  \textit{f} & \textit{f} & \textit{f} & \textit{t} & \textit{t} &
  \textit{t} & \textit{f} & \textit{t} & \textbf{t} \\
\end{tabular}

\bigskip

The statements $((p \Rightarrow r) \land (q \Rightarrow r))$, $((p
\lor q) \Rightarrow r)$ are equivalent and $((p \Rightarrow r) \land
(q \Rightarrow r))$ $\Leftrightarrow$ $((p \lor q) \Rightarrow r)$ is
a tautology as it is true for every interpretation of p, q, r as
illustrated by the final column of truth values.

\bigskip

\newpage

\medskip

\bigskip
\noindent
\textbf{Question 2}

\medskip

\bigskip

Lecture 1 - Propositions

\bigskip

(a)
\par
\vspace{11pt}
\[
  \begin{array}{ll@{\hspace{2em}}l}
    & p \Rightarrow (\lnot p \Rightarrow p) \\
    &\Leftrightarrow p \Rightarrow (\lnot \lnot p \lor p) &
    [\mbox{$\Rightarrow$ disjunction}] \\
    &\Leftrightarrow p \Rightarrow (p \lor p) & [\mbox{$\lnot$ $\lnot$}] \\
    &\Leftrightarrow p \Rightarrow p & [\mbox{idempotence of p}] \\
    &\Leftrightarrow true & [\mbox{tautology}]
  \end{array}
\]

\bigskip

In this equivalence proof, we show that $p \Rightarrow (\lnot p
\Rightarrow p)$ by using implication disjunction to replace the
implication with a logical or, the definition of double negation to
simplify, the application of the idempotence rule to simplify, and
the fact that $p \Rightarrow p$ is a tautology.

\bigskip

\medskip

(b)
\par
\vspace{11pt}
\[
  \begin{array}{ll@{\hspace{2em}}l}
    & (\lnot p \Rightarrow \lnot q) \\
    &\Leftrightarrow (\lnot \lnot p \lor \lnot q) &
    [\mbox{$\Rightarrow$ disjunction}] \\
    &\Leftrightarrow (p \lor \lnot q) & [\mbox{$\lnot$ $\lnot$}] \\
    &\Leftrightarrow (\lnot q \lor p) & [\mbox{commutativity of $\lor$}] \\
    &\Leftrightarrow q \Rightarrow p & [\mbox{$\Rightarrow$ disjunction}]
  \end{array}
\]

\bigskip

In this equivalance proof, we show that $(\lnot p \Rightarrow \lnot
q) \Leftrightarrow q \Rightarrow p$ by using implication disjunction
to replace implication with logical or, the definition of double
negation to simplify, the commutivity property of logical or to
change the order of the elements, and the implication disjunction
rule to reintroduce implication.

\bigskip

\medskip

(c)
\par
\vspace{11pt}
\[
  \begin{array}{ll@{\hspace{2em}}l}
    & ((p \Rightarrow r) \land (q \Rightarrow r)) \\
    &\Leftrightarrow ((\lnot p \lor r) \land (\lnot q \lor r)) &
    [\mbox{$\Rightarrow$ disjunction}] \\
    &\Leftrightarrow (r \lor \lnot p) \land (r \lor \lnot q) &
    [\mbox{commutativity of $\lor$}] \\
    &\Leftrightarrow r \lor (\lnot p \land \lnot q) &
    [\mbox{distributivity 2}] \\
    &\Leftrightarrow (\lnot p \land \lnot q) \lor r &
    [\mbox{commutativity of $\lor$}] \\
    &\Leftrightarrow \lnot (p \lor q) \lor r & [\mbox{De Morgan}] \\
    &\Leftrightarrow p \lor q \Rightarrow r & [\mbox{$\Rightarrow$ disjunction}]
  \end{array}
\]

\bigskip

In this equivalence proof, we show that $((p \Rightarrow r) \land (q
\Rightarrow r))$ $\Leftrightarrow$ $(p \lor q)$ $\Rightarrow$ r by
using the implication disjunction rule to replace implication with
logical or, the commutativity of or rule to change the order of the
elements, the distributivity 2 rule to extract r, and the commutivity
of logical or to change the order of the elements, De Morgan to
extract negation for $(\lnot p \land \lnot q)$, and the implication
disjunction rule to reintroduce implication.

\bigskip

\newpage

\medskip

\bigskip
\noindent
\textbf{Question 3}

\medskip

\bigskip

Lecture 3 - Deductive Proofs

\bigskip

(a)
\par
\vspace{11pt}
\noindent
$\displaystyle
\infer[\Rightarrow\textrm{-intro}^{[1]}]{p \Rightarrow (\lnot p \Rightarrow p)}{
  \ulcorner p \urcorner^{[1]}
  &
  \infer[\Rightarrow\textrm{-intro}^{[2]}]{\lnot p \Rightarrow
  p}{\ulcorner p \urcorner^{[1]} &
    \infer[false\textrm{-elim}^{[3]}]{\lnot p}{\infer[\mathrm{false} -
      \mathrm{intro}]{false}{\ulcorner \lnot p \urcorner^{[2]} &
  \ulcorner p \urcorner^{[3]}}}}
}
$

\bigskip

For this proof we are seeking to prove that p $\Rightarrow$ $(\lnot p
\Rightarrow p)$, which we know holds given the truth table in 1(a).
Working mechanically from the bottom, I started by applying the
implication introduction rule with assumption [1] to gain our
conclusion, implication introduction rule with assumption [2] to gain
$(\lnot p \Rightarrow p)$.  This statement requires that I have both
p and $\lnot p$ as premisses, which is a bit odd and implied I needed
to use false in the proof.  Since I had p as assumption [1], I knew I
wanted $\lnot p$ as the output of the false rules.  It took some
experimentation, but eventually I realized I needed three assumptions
not two and it was obvious that I wanted to preserve $\lnot p$ as
assumption [2], which meant I needed p as assumption [3] and that
assumption [3] would be discharged by the false-elim rule.  In the
final proof, all assumptions are discharged properly. The key insight
was to have p as an assumption twice at different scopes.

\bigskip

\medskip

(b)
\par
\vspace{11pt}
\bigskip

This proof involves equivalence or bi-implication, which requires us
to show $p \Rightarrow q$ and $q \Rightarrow p$ given this is the
definition of $p \Leftrightarrow q$.

\bigskip

\bigskip

In one direction, we are seeking to prove $(\lnot p \Rightarrow \lnot
q)$ $\Rightarrow$ $(q \Rightarrow p)$:

\bigskip

\noindent
$\displaystyle
\infer[\Rightarrow\textrm{-intro}^{[1]}]{(\lnot p \Rightarrow \lnot
q) \Rightarrow (q \Rightarrow p)}{
  \ulcorner \lnot p \Rightarrow \lnot q \urcorner^{[1]}
  &
  \infer[\Rightarrow\textrm{-intro}^{[2]}]{q \Rightarrow p}{
    \ulcorner q \urcorner^{[2]}
    &
    \infer[false\textrm{-elim}^{[3]}]{p}{
      \infer[\mathrm{false} - \mathrm{intro}]{false}{
        \infer[\Rightarrow \mathrm{elim}]{\lnot q}{
          \ulcorner \lnot p \Rightarrow \lnot q \urcorner^{[1]}
          &
          \ulcorner \lnot p \urcorner^{[3]}
        }
        &
        \ulcorner q \urcorner^{[2]}
      }
    }
  }
}
$

\bigskip

I started working mechanically from the bottom by applying the
implication introduction rule to construct the conclusion.  This gave
me $q \Rightarrow p$ as the key premise to build up, which requires
applying the implication introduction rule to q and p. Looking at the
need for q and looking at the need for p and $(\lnot p \Rightarrow
\lnot q)$ as assumption [1], I felt it would be best to try $\lnot p$
as an assumption to at least get going.  This enabled me to work top
down to get $\lnot q$ from the implication elimination rule. From
there, I realized that I needed the negation of both $\lnot q$ and
$\lnot p$. I knew the false-intro and false-elim were required, but
it took some experimentation to see that I could get both $\lnot q$
and $\lnot p$ transformed into p and q by making $\lnot p$ assumption
[3] instead of [2] and introducing q as assumption [2]. Once that
insight was made, I could arrive at p as a result of the top of the
tree and retain q [2] as an assumption coming out of false-elim. This
is what I needed to arrive at $q \Rightarrow p$ and to connect the
bottom and top portions of my proof.  All assumptions are properly discharged.

\bigskip

\bigskip

and in the other, we are seeking to prove $(q \Rightarrow p)$
$\Rightarrow$ $(\lnot p \Rightarrow \lnot q)$:

\bigskip

\noindent
$\displaystyle
\infer[\Rightarrow\textrm{-intro}^{[1]}]{(q \Rightarrow p)
\Rightarrow (\lnot p \Rightarrow \lnot q)}{
  \ulcorner q \Rightarrow p \urcorner^{[1]}
  &
  \infer[\Rightarrow\textrm{-intro}^{[2]}]{\lnot p \Rightarrow \lnot q}{
    \ulcorner \lnot p \urcorner^{[2]}
    &
    \infer[false\textrm{-elim}^{[3]}]{\lnot q}{
      \infer[\mathrm{false} - \mathrm{intro}]{false}{
        \infer[\Rightarrow \mathrm{elim}]{p}{
          \ulcorner q \Rightarrow p \urcorner^{[1]}
          &
          \ulcorner q \urcorner^{[3]}
        }
        &
        \ulcorner \lnot p \urcorner^{[2]}
      }
    }
  }
}
$

\bigskip

Working mechanically from the bottom, I apply the implication rule to
$q \Rightarrow p$ as assumption [1] to gain the conclusion.  I need
$(\lnot p \Rightarrow \lnot q)$, which shows me to use the
implication rule again with $\lnot p$ as assumption [2].  From there,
the question is how to get $\lnot q$.  Now working from the top,
given assumption [1] has q, it makes sense to use the implication
elimation rule with q as assumption [3]. This gives me p, when what I
want is $\lnot q$.  I see that if I introduce $\lnot p$ as assumption
[3] that I can negate q via the false-intro and false-elim rules and
successfully discharge assumption [3]. This gives me $\lnot q$, which
is what I need to connect to the top tree to the bottom of the proof.
This proof came more quickly because $q \Rightarrow p$ as assumption
[1] gave clear direction for the top portion. All assumptions are
discharged and scopes are appropriate.

\bigskip

\bigskip

We then combine these two proofs with the $\Leftrightarrow$-intro
rule, using the results from above:

\bigskip

\noindent
$\displaystyle
\infer[\Leftrightarrow \mathrm{intro}]{(\lnot p \Rightarrow \lnot q)
\Leftrightarrow (q \Rightarrow p)}{
  (\lnot p \Rightarrow \lnot q) \Rightarrow (q \Rightarrow p)
  &
  (q \Rightarrow p) \Rightarrow (\lnot p \Rightarrow \lnot q)
}
$

\medskip

(c)
\par
\vspace{11pt}
\bigskip

In one direction, we are seeking to prove $(p \Rightarrow r)$ and $(q
\Rightarrow r)$ $\Rightarrow$ $(p \lor q \Rightarrow r)$:

\bigskip

\noindent
$\displaystyle
\infer[\Rightarrow\textrm{-intro}^{[1]}]{((p \Rightarrow r) \land (q
\Rightarrow r)) \Rightarrow ((p \lor q) \Rightarrow r)}{
  \ulcorner (p \Rightarrow r) \land (q \Rightarrow r) \urcorner^{[1]}
  &
  \infer[\Rightarrow\textrm{-intro}^{[2]}]{(p \lor q) \Rightarrow r}{
    \ulcorner p \lor q \urcorner^{[2]}
    &
    \infer[\lor\textrm{-elim}^{[2]}]{r}{
      \ulcorner p \lor q \urcorner^{[2]}
      &
      \raiseproof{12ex}{\infer[\Rightarrow \mathrm{elim}]{r}{
          \ulcorner p \urcorner^{[2]}
          &
          \infer[\land\textrm{-elim-1}]{(p \Rightarrow r)}{
            \ulcorner (p \Rightarrow r) \land (q \Rightarrow r) \urcorner^{[1]}
          }
      }}
      &
      \hskip 6em \raiseproof{30ex}{\infer[\Rightarrow \mathrm{elim}]{r}{
          \ulcorner q \urcorner^{[2]}
          &
          \infer[\land\textrm{-elim-2}]{(q \Rightarrow r)}{
            \ulcorner (p \Rightarrow r) \land (q \Rightarrow r) \urcorner^{[1]}
          }
      }}
    }
  }
}
$

\bigskip

In this proof, I start by working from the bottom mechanically,
taking $(p \Rightarrow r) \land (q \Rightarrow r)$ as assumption [1]
and applying the implication introduction rule to arrive at our
conclusion and discharge assumption [1]. From there, I can see that I
need $(p \lor q)$ and r as inputs to the implication introduction
rule.  I take $(p \lor q)$ as assumption [2] and discharge this
assumption via this rule.  That leaves me with r as the result of my
bottom up process.  As I have already made assumptions $((p
\Rightarrow r) \land (q \Rightarrow r))$ [1] and $(p \lor q)$ [2] and
they are related, I start by working with both top-down. I begin with
$(p \lor q)$ [2] and create cases for p and q working towards or
elimination.  The p and q sub-branches are marked with [2] as the
assumption as these are just the cases for $(p \lor q)$ [2]
\citep[slide 41]{simpson25c}. First, I apply and elimination in each
case to get $(p \Rightarrow r)$, $(q \Rightarrow r)$ with p, q
respectively in the sub-branches.  From there, I apply implication
elimination to arrive at r in both cases.  This enables me to use the
or elimation together with $(p \lor q)$ [2] to simplify to r.  At
this stage, I do not discharge assumption [2], as this is deferred
until the next step. I use implication introduction together with $(p
\lor q)$ [2] and r from the or elimination to discharge assumption
[2], which connects the top-down and bottom-up process. All
assumptions are properly discharged.

\bigskip

\bigskip

In the other direction, we are seeking to prove $(p \lor q
\Rightarrow r)$ $\Rightarrow$ $((p \Rightarrow r) \land (q \Rightarrow r))$:

\bigskip

\noindent
$\displaystyle
\infer[\Rightarrow\textrm{-intro}^{[1]}]{((p \lor q) \Rightarrow r)
\Rightarrow ((p \Rightarrow r) \land (q \Rightarrow r))}{
  \ulcorner ((p \lor q) \Rightarrow r) \urcorner^{[1]}
  &
  \infer[\land \mathrm{intro}]{((p \Rightarrow r) \land (q \Rightarrow r))}{
    \infer[\Rightarrow\textrm{-intro}^{[2]}]{p \Rightarrow r}{
      \ulcorner p \urcorner^{[2]}
      &
      \infer[\Rightarrow \mathrm{elim}]{r}{
        \ulcorner (p \lor q) \Rightarrow r \urcorner^{[1]}
        &
        \infer[\lor\textrm{-intro-1}]{p \lor q}{
          \ulcorner p \urcorner^{[2]}
        }
      }
    }
    &
    \infer[\Rightarrow\textrm{-intro}^{[3]}]{q \Rightarrow r}{
      \ulcorner q \urcorner^{[3]}
      &
      \infer[\Rightarrow \mathrm{elim}]{r}{
        \ulcorner (p \lor q) \Rightarrow r \urcorner^{[1]}
        &
        \infer[\lor\textrm{-intro-2}]{p \lor q}{
          \ulcorner q \urcorner^{[3]}
        }
      }
    }
  }
}
$

\bigskip

Working mechanically from the bottom, we start by taking $(p \lor q
\Rightarrow r)$ as assumption [1] and applying the implication
introduction rule to discharge assumption [1].  This leaves us with
$(p \Rightarrow r)$ and $(q \Rightarrow r)$, which is derived from $p
\Rightarrow r$, $q \Rightarrow r$ and the application of the and
introduction rule. Fairly clearly, we need two sub-branches to be
developed top-down. Since we have $(p \lor q \Rightarrow r)$ and we
want $p \Rightarrow r$ and $q \Rightarrow r$, I start with p [2] and
q [3] to start the top-down sub-trees.  I struggled here until I
recalled that I could use the or intro rule to satisfy $(p \lor q)$.
I also had to recall that this does not generate additional
assumptions to discharge \citep[slide 38]{simpson25c}. From here, it
was not difficult to use implication elimation to arrive at r in both
sub-trees and to apply p [2] and q [3] in each tree respectively with
the implication introduction rule to discharge those assumptions.
This gave me $p \Rightarrow r$, $q \Rightarrow r$ and I used the and
introduction rule to connect the top and bottom portions of the
proof. All assumptions are properly discharged.

\bigskip

\bigskip

We then combine these two proofs with the $\Leftrightarrow$-intro
rule, using the results from above:

\bigskip

\noindent
$\displaystyle
\infer[\Leftrightarrow \mathrm{intro}]{((p \Rightarrow r) \land (q
\Rightarrow r)) \Leftrightarrow ((p \lor q) \Rightarrow r)}{
  ((p \Rightarrow r) \land (q \Rightarrow r)) \Rightarrow ((p \lor q)
  \Rightarrow r)
  &
  ((p \lor q) \Rightarrow r) \Rightarrow ((p \Rightarrow r) \land (q
  \Rightarrow r))
}
$

\medskip

\bigskip
\noindent
\textbf{Question 4}

\medskip

\bigskip

We are defining a generic function that will tell us the difference
in length between the longest and shorest sequences from an input
type that is a non-empty sequences of sequences. The input could be
$\langle  \langle x, y, z \rangle, \langle \rangle  \rangle$ yielding
3 as output or $\langle \langle x \rangle \rangle$ yielding 0, for
example. I specify three generic functions: maxSeq yields the longest
sequence from a non-empty sequence of sequences; minSeq yields the
shortest sequence from a non-empty sequence of sequences; and
maxDiff, which fulfills the specification for Question 4.

\bigskip

\begin{gendef}[X]
  maxSeq: \seq_1 (\seq X) \fun \seq X \\
  minSeq: \seq_1 (\seq X) \fun \seq X \\
  maxDiff: \seq_1 (\seq X) \fun \mathbb{N}
  \where
  \forall ss \colon \seq_1 (\seq X) \bullet maxSeq(ss) = (\mu s
  \colon \ran ss \bullet \forall t \colon \ran ss \bullet \# s \geq \# t)
  \forall ss \colon \seq_1 (\seq X) \bullet minSeq(ss) = (\mu s
  \colon \ran ss \bullet \forall t \colon \ran ss \bullet \# s \leq \# t)
  \forall ss \colon \seq_1 (\seq X) \bullet maxDiff(ss) = (\#
  maxSeq(ss) - \# minSeq(ss))
\end{gendef}

\bigskip

For maxSeq and minSeq, a mu function is defined that selects a single
element meeting the specification based on comparing each sequence s
with every sequence t. First, the range operator moves us from a
sequence of sequences with ss values such as $\langle  1  \mapsto
\langle x, y, z \rangle, 2  \mapsto  \langle \rangle  \rangle$ to
sequences s, t with values like $\langle x, y, z \rangle$, $\langle
\rangle$ to enable seq operators. maxSeq and minSeq use the length
operators and maxDiff uses the length operators with subtraction. For
maxDiff, $maxSeq \geq minDiff$ is a valid pre-condition by virtue of
maxSeq and minSeq and therefore the subtraction is guaranteed to
return a natural number as defined in the specification. This
solution passes fuzz validation.

\bigskip

\bigskip
\noindent
\textbf{Question 5}

\medskip

\bigskip

The relational composition operator is associative:

\bigskip

\hspace*{1em} $(R \circ S) \circ T = R \circ (S \circ T)$

\bigskip

if $R \in W$ $\rel$ X, $S \in X$ $\rel$ Y, and $T \in Y$ $\rel$ Z.

\bigskip

\bigskip

In this equivalence proof, we show that composition is associative
using the definition of relational composition and by repositioning
quantifiers and predicates where we are permitted to do so, which is
only when there is no impact to the truthity of the predicates
involved. Each such repositioning or regrouping will be justified.

\bigskip

\bigskip

Given a relation $R \in X$ $\rel$ Y and a second relation $S \in Y$
$\rel$ Z, and two elements $x \in X$ and $z \in Z$, x $\mapsto$ $z
\in R$ $\circ$ S $\Leftrightarrow$ $\exists y \colon Y \bullet x
\mapsto y \in R \land y \mapsto z \in S$ \citep[page 107]{simpson-notes}.

\bigskip

\[
  \begin{array}{ll@{\hspace{2em}}l}
    & w \mapsto z \in (R \circ S) \circ T \\
    &\Leftrightarrow \exists y \colon Y \bullet w \mapsto y \in (R
    \circ S) \land y \mapsto z \in T & [\mbox{definition of $\circ$}] \\
    &\Leftrightarrow \exists y \colon Y \bullet (\exists x \colon X
    \bullet w \mapsto x \in R \land x \mapsto y \in S) \land y
    \mapsto z \in T & [\mbox{definition of $\circ$}] \\
    &\Leftrightarrow \exists y \colon Y \bullet \exists x \colon X
    \bullet w \mapsto x \in R \land x \mapsto y \in S \land y \mapsto
    z \in T & [\mbox{x is $\lnot$ free $\in$ y $\mapsto$ z $\in$ T}] \\
    &\Leftrightarrow \exists x \colon X \bullet w \mapsto x \in R
    \land (\exists y \colon Y \bullet x \mapsto y \in S \land y
    \mapsto z \in T) & [\mbox{y is $\lnot$ free $\in$ w $\mapsto$ x $\in$ R}] \\
    &\Leftrightarrow \exists x \colon X \bullet w \mapsto x \in R
    \land x \mapsto z \in (S \circ T) & [\mbox{definition of $\circ$}] \\
    &\Leftrightarrow w \mapsto z \in R \circ (S \circ T)
  \end{array}
\]

\bigskip

In step 1, we apply the composition equivalence to the outer
composition of (R $\circ$ S) $\circ$ T. In step 2, we apply our
equivalence to the inner composition (R $\circ$ S).  In step 3, we
include the predicate y $\mapsto$ $z \in T$ in the scope of x : X. We
can do this because this does not affect the truthity of y $\mapsto$
$z \in T$ as x is not free in this predicate. In step 4, we
reposition the exists y : Y quantifier to be after the w $\mapsto$ $x
\in R$ predicate without affecting its truthity because y is not free
in w $\mapsto$ $x \in R$.  In step 5, we apply the equivalence for
composition to S $\circ$ T.  In step 6, we apply the equivalence for
composition to R $\circ$ (S $\circ$ T).

\bigskip

\bigskip

I worked on this proof both top-down and bottom-up.  After doing the
obvious equivalence substitutions, I was left with step 3 and 4 to
work out. In working out step 3, I could see from step 6 that I
wanted S $\circ$ T together.  In working out step 4, I could see that
y : Y needed to be repositioned to setup step 6.  The reasoning about
both of these steps was not obvious at first, but I realized that
these moves had no impact on the truth values of the affected
predicates.  This led me to think about free and bound variables and
what rules might apply in various cases.  I was not able to find a
specific justification in the materials that maps to the idea that
one can reposition quantifiers or predicates provided there is no
inpact to the truthity, but this seems logical and sound provided x
is not $free \in P$ for the affected P.

\bigskip

\newpage

\bigskip
\noindent
\textbf{Question 6}

\medskip

\bigskip

Lecture 4 - Sets, Types, and Definitions

\bigskip

(a)
\par
\vspace{11pt}
\begin{axdef}
  SquaresOfEvens : \power \mathbb{Z}
  \where
  SquaresOfEvens = \{ z \colon \mathbb{Z} \mid z \mod 2 = 0 \bullet z * z \}
\end{axdef}

\medskip

(b)
\par
\vspace{11pt}
\begin{axdef}
  CubesOfSquaresOfEvens : \power \mathbb{Z}
  \where
  CubesOfSquaresOfEvens = \{ z \colon \mathbb{Z} \mid z \mod 2 = 0
  \bullet (z * z) * (z * z) * (z * z) \}
\end{axdef}

\medskip

(c)
\par
\vspace{11pt}
\begin{axdef}
  SquareCubePairsOfEvens : \power (\mathbb{Z} \cross \mathbb{Z})
  \where
  SquareCubePairsOfEvens = \{ z_1, z_2 \colon \mathbb{Z} \mid z_1
  \mod 2 = 0 \land z_2 \mod 2 = 0 \bullet (z_1 * z_1, z_2 * z_2 * z_2) \}
\end{axdef}

\medskip

(d)
\par
\vspace{11pt}
\begin{axdef}
  SquareCubeIdentityPairsOfEvens : \power (\mathbb{Z} \cross \mathbb{Z})
  \where
  SquareCubeIdentityPairsOfEvens = \{ z \colon \mathbb{Z} \mid z \mod
  2 = 0 \bullet (z * z, z * z * z) \}
\end{axdef}

\medskip

(e)
\par
\vspace{11pt}
\begin{axdef}
  SquareOrCubeIntegers : \power \mathbb{Z}
  \where
  SquareOrCubeIntegers = \{ z, z_0 \colon \mathbb{Z} \mid z = z_0 *
  z_0 \lor z = z_0 * z_0 * z_0 \bullet z \}
\end{axdef}

\newpage

\medskip

\bigskip
\noindent
\textbf{Question 7}

\medskip

\begin{zed}[ShowId, PeopleId]
\end{zed}

\begin{zed}
  EpisodeId == \mathbb{N}_1
\end{zed}

\begin{zed}
  Timestamp == \mathbb{N}
\end{zed}

\begin{gendef}[X, Y]
  fst: X \cross Y \fun X
  \where
  \forall a \colon X \bullet \forall b \colon Y \bullet fst(a, b) = a
\end{gendef}

\begin{gendef}[X, Y]
  snd: X \cross Y \fun Y
  \where
  \forall a \colon X \bullet \forall b \colon Y \bullet snd(a, b) = b
\end{gendef}

\begin{axdef}
  shows : \finset ShowId \\
  \mathit{show\_episodes} : ShowId \pfun \finset EpisodeId \\
  \mathit{episode\_info} : ShowId \cross EpisodeId \pfun (\finset
  PeopleId \cross Timestamp) \\
  \mathit{show\_info} : ShowId \pfun \finset PeopleId
  \where
  shows \subseteq \dom \mathit{show\_episodes} \land \dom
  \mathit{show\_episodes} \subseteq shows \\
  \forall es \colon \ran \mathit{show\_episodes} \bullet \exists n
  \colon \mathbb{N} \bullet es = 1 \upto n \\
  \forall s \colon \dom \mathit{show\_episodes} \bullet \forall e
  \colon \mathit{show\_episodes}(s) \bullet \\
  \quad (s, e) \in \dom \mathit{episode\_info} \Leftrightarrow s \in
  \dom \mathit{show\_episodes} \\
  shows \subseteq \dom \mathit{show\_info} \land \dom
  \mathit{show\_info} \subseteq shows \\
  \forall s \colon ShowId \bullet \forall p \colon PeopleId \bullet
  \exists e \colon EpisodeId \bullet \\
  \quad (s, e) \in \dom \mathit{episode\_info} \land \\
  \quad (p \in fst(\mathit{episode\_info}(s, e)) \Leftrightarrow p
  \in \mathit{show\_info}(s)) \\
  \forall s \colon ShowId \bullet \forall t_1, t_2 \colon Timestamp
  \bullet \forall e_1, e_2 \colon EpisodeId \bullet \\
  \quad ((s, e_1) \in \dom \mathit{episode\_info} \land (s, e_2) \in
  \dom \mathit{episode\_info}) \land \\
  \quad ((e_1 < e_2) \Rightarrow (snd(\mathit{episode\_info}(s, e_1))
  \leq snd(\mathit{episode\_info}(s, e_2))))
\end{axdef}

\noindent
\hangindent=2em
(a) $shows \subseteq \dom \mathit{show\_episodes} \land \dom
\mathit{show\_episodes} \subseteq shows$

\medskip
\noindent
\hangindent=2em
(b) $\forall es \colon \ran \mathit{show\_episodes} \bullet \exists n
\colon \mathbb{N} \bullet es = 1 \upto n$

\medskip
\noindent
\hangindent=2em
(c) $\forall s \colon \dom \mathit{show\_episodes} \bullet \forall e
\colon \mathit{show\_episodes}(s) \bullet \\
\quad (s, e) \in \dom \mathit{episode\_info} \Leftrightarrow s \in
\dom \mathit{show\_episodes}$

\medskip
\noindent
\hangindent=2em
(d) $shows \subseteq \dom \mathit{show\_info} \land \dom
\mathit{show\_info} \subseteq shows$

\medskip
\noindent
\hangindent=2em
(e) $\forall s \colon ShowId \bullet \forall p \colon PeopleId
\bullet \exists e \colon EpisodeId \bullet \\
\quad (s, e) \in \dom \mathit{episode\_info} \land \\
\quad (p \in fst(\mathit{episode\_info}(s, e)) \Leftrightarrow p \in
\mathit{show\_info}(s))$

\medskip
\noindent
\hangindent=2em
(f) $\forall s \colon ShowId \bullet \forall t_1, t_2 \colon
Timestamp \bullet \forall e_1, e_2 \colon EpisodeId \bullet \\
\quad ((s, e_1) \in \dom \mathit{episode\_info} \land (s, e_2) \in
\dom \mathit{episode\_info}) \land \\
\quad ((e_1 < e_2) \Rightarrow (snd(\mathit{episode\_info}(s, e_1))
\leq snd(\mathit{episode\_info}(s, e_2))))$

\newpage

\medskip

\bigskip
\noindent
\textbf{Question 8}

\medskip

\bigskip

The following are given as abbreviations to enable fuzz validation,
which passes for each expression.

\bigskip

\begin{zed}
  EightA == \{ s \colon \dom \mathit{show\_episodes} \mid \#
  \mathit{show\_episodes}(s) \geq 100 \}
\end{zed}

\bigskip

Shows with at least 100 episodes.  We use the cardinality operator on
F EpisodeId after ensuring s is in the domain of show\_episodes.

\bigskip

\begin{zed}
  EightB == \{ p \colon PeopleId \mid \exists s_1, s_2 \colon \dom
    \mathit{show\_info} \bullet s_1 \neq s_2 \land p \in
  \mathit{show\_info}(s_1) \land p \in \mathit{show\_info}(s_2) \}
\end{zed}

\bigskip

The set of PeopleId, which appear in 2 or more shows.  We make sure
two such shows are distinct and we validate each $PeopleId \in F$ PeopleId.

\bigskip

\begin{axdef}
  \mathit{first\_episode\_timestamp} : ShowId \pfun Timestamp
  \where
  \forall s \colon ShowId \bullet (s, 1) \in \dom
  \mathit{episode\_info} \land \mathit{first\_episode\_timestamp}(s)
  = snd(\mathit{episode\_info}(s, 1))
\end{axdef}

\begin{zed}
  EightC == \mathit{first\_episode\_timestamp}(\mu s \colon \dom
    \mathit{show\_info} \bullet \\
    \quad \forall t \colon \dom \mathit{show\_info} \bullet s \neq t \land \\
  \quad \# \mathit{show\_info}(s) > \# \mathit{show\_info}(t))
\end{zed}

\bigskip

We are given that there is exactly one show with the most people and
we want the timestamp for the first episode of that show. This
involves two operations, finding the show with the most people and
finding the timestamp for the first episode of that show.  For the
first operation, we compare the cardinality of the F PeopleId for
every pair s, t : ShowId in the domain of show\_info. This is
captured in the mu expression, which returns the single matching value.

\bigskip

\bigskip

For the second operation, we define a partial function
first\_episode\_timestamp that yields the Timestamp for $EpisodeId =
1$ for $s : ShowId$.  We are guaranteed that $EpisodeId = 1$ exists
by constraint 7(b). In addition, calling this function with the s
from the mu expression is valid because the constraint defined in
7(e) guarantees that the set of EpisodeId in the domain of show\_info
and in the first element of the domain of episode\_info are identical.

\bigskip

\bigskip
\noindent
\textbf{Question 9}

\medskip

\begin{zed}PlayedOrNot ::= Played | NotP
\end{zed}

\begin{zed}SavedOrNot ::= Saved | NotS
\end{zed}

\begin{axdef}
  \mathit{my\_shows} : \finset ShowId \\
  \mathit{my\_episodes} : \iseq (ShowId \cross EpisodeId) \\
  status : ShowId \cross EpisodeId \pfun (PlayedOrNot \cross SavedOrNot)
  \where
  \mathit{my\_shows} \subseteq shows \\
  \forall s \colon ShowId \bullet \forall e \colon EpisodeId \bullet
  (s, e) \in \ran \mathit{my\_episodes} \land \\
  \quad e \in \mathit{show\_episodes}(s) \\
  \forall s \colon ShowId \bullet \forall e \colon EpisodeId \bullet
  s \in \mathit{my\_shows} \land \\
  \quad (s, e) \in \ran \mathit{my\_episodes} \\
  \forall s \colon ShowId \bullet \forall e \colon EpisodeId \bullet \\
  \quad (s, e) \in \ran \mathit{my\_episodes} \Rightarrow ((s, e) \in
    \dom status \land \\
    \quad (s, e) \in \dom status \Rightarrow (s, e) \in \ran
  \mathit{my\_episodes})
\end{axdef}

\newpage

\bigskip
\noindent
\textbf{Question 10}

\medskip

\begin{zed}
  Playlist == \seq ((ShowId \cross EpisodeId) \cross \mathbb{N})
\end{zed}

\begin{axdef}
  PossiblePlaylist : \power Playlist
  \where
  PossiblePlaylist = \seq (\dom status \cross \mathbb{N})
\end{axdef}

(a)
\par
\vspace{11pt}
\begin{axdef}
  length : PossiblePlaylist \fun \mathbb{N}
  \where
  length(\langle \rangle) = 0 \land \\
  \quad (\forall pl \colon PossiblePlaylist \bullet \forall ple
    \colon (\dom status \cross \mathbb{N}) \bullet \\
  \quad length(\langle ple \rangle \cat pl) = snd(ple) + length(pl))
\end{axdef}

\medskip

(b)
\par
\vspace{11pt}
\begin{axdef}
  unplayed : PossiblePlaylist \fun PossiblePlaylist
  \where
  unplayed(\langle \rangle) = \langle \rangle \land \\
  \quad (\forall pl \colon PossiblePlaylist \bullet \forall ple
    \colon (\dom status \cross \mathbb{N}) \bullet \\
    \quad (fst(status(fst(ple))) = Played) \Rightarrow
    ((unplayed(\langle ple \rangle \cat pl) = unplayed(pl)) \land \\
      \quad (fst(status(fst(ple))) = NotP) \Rightarrow (unplayed(\langle
  ple \rangle \cat pl) = \langle ple \rangle \cat unplayed(pl))))
\end{axdef}

\medskip

(c)
\par
\vspace{11pt}
\begin{axdef}
  played : PossiblePlaylist \fun PossiblePlaylist
  \where
  played(\langle \rangle) = \langle \rangle \land \\
  \quad (\forall pl \colon PossiblePlaylist \bullet \forall ple
    \colon (\dom status \cross \mathbb{N}) \bullet \\
    \quad (fst(status(fst(ple))) = NotP) \Rightarrow ((played(\langle
      ple \rangle \cat pl) = played(pl)) \land \\
      \quad (fst(status(fst(ple))) = Played) \Rightarrow (played(\langle
  ple \rangle \cat pl) = \langle ple \rangle \cat played(pl))))
\end{axdef}

\medskip

\bigskip
\noindent
\textbf{Question 11}

\medskip

\bigskip

To use proof by induction, we need to prove the base case and the
inductive case.  A PossiblePlaylist belongs to P Playlist where
Playlist is of type seq((ShowId cross EpisodeId) cross N). The base
case occurs when p = $\langle \rangle$. Therefore, we must first
prove length(played($\langle \rangle$)) + length(unplayed($\langle
\rangle$)) = length($\langle \rangle$)

\bigskip

\[
  \begin{array}{ll@{\hspace{2em}}l}
    & length(played(\langle \rangle)) + length(unplayed(\langle \rangle)) \\
    &\Leftrightarrow length(\langle \rangle) + length(\langle
    \rangle) & [\mbox{played($\langle \rangle$)=$\langle \rangle$
    $\land$ unplayed($\langle \rangle$)=$\langle \rangle$}] \\
    &\Leftrightarrow 0 + 0 & [\mbox{length($\langle \rangle$)=0}] \\
    &\Leftrightarrow 0 & [\mbox{0 + 0=0}] \\
    &\Leftrightarrow length(\langle \rangle) & [\mbox{length($\langle
    \rangle$)=0}]
  \end{array}
\]

\bigskip

In the above, we use each of the individual played(), unplayed(), and
length() base cases to justify our rewrites.

\bigskip

\bigskip

A playlist element is of type ((dom status) cross N).  We now seek to
prove the inductive hypothesis, which follows the form of induction
for sequences and which is an implication \citep[page 157]{simpson-notes}.

\bigskip

\noindent
$\forall t \colon PossiblePlaylist \bullet \forall ple \colon (\dom
status \cross \mathbb{N}) \bullet \\
\quad length(played(t)) + length(unplayed(t)) = length(t) \Rightarrow \\
\quad length(played(\langle ple \rangle \cat t)) +
length(unplayed(\langle ple \rangle \cat t)) = length(\langle ple
\rangle \cat t)$

\bigskip

The status of a playlist element is of type (PlayedOrNot,
SavedOrNot). The inductive hypothesis proof begins by establishing
that there are two mutually exclusive and exhaustive cases: one where
the playlist element's PlayedOrNot free type value is Played and
another where it is NotP.  The proof will establish that for both
cases, the same conclusion can be proven. The proof relies upon the
inductive hypothesis length(played(t)) + length(unplayed(t)) = length(t).

\bigskip

\bigskip

Case 1: The playlist element is played, which is represented by
fst(status fst(ple)) = Played, which says take the status of the ple
and inspect the first element of the status tuple and determine
whether $PlayedOrNot = Played$.

\bigskip

\[
  \begin{array}{ll@{\hspace{2em}}l}
    & length(played(\langle ple \rangle \cat t)) +
    length(unplayed(\langle ple \rangle \cat t)) \\
    &\Leftrightarrow length(\langle ple \rangle \cat played(t)) +
    length(unplayed(\langle ple \rangle \cat t)) &
    [\mbox{played($\langle  ple  \rangle$ $\cat$ pl)=$\langle  ple
    \rangle$ $\cat$(played(pl))}] \\
    &\Leftrightarrow length(\langle ple \rangle \cat played(t)) +
    length(unplayed(t)) & [\mbox{unplayed($\langle  ple  \rangle$
    $\cat$ pl)=unplayed(pl)}] \\
    &\Leftrightarrow snd(ple) + length(played(t)) +
    length(unplayed(t)) & [\mbox{length($\langle  ple  \rangle$
    $\cat$ pl)=snd(ple)+ length(pl)}] \\
    &\Leftrightarrow snd(ple) + (length(played(t)) +
    length(unplayed(t))) & [\mbox{associativity of addition}] \\
    &\Leftrightarrow snd(ple) + length(t) & [\mbox{length(played(p))+
    length(unplayed(p))=length(p)}] \\
    &\Leftrightarrow length(\langle ple \rangle \cat t) &
    [\mbox{length($\langle  ple  \rangle$ $\cat$ pl)=snd(ple)+ length(pl)}]
  \end{array}
\]

\bigskip

We first rewrite the played term as we know ple is Played and then we
simplify the unplayed term as we know ple is not NotP. From here, we
apply the definition of length for a single sequence element
concatenated to a sequence. Using the associative property of
addition, we arrive at a form of the inductive hypothesis that we can
simplify.  From there, we apply our definition of length again to
arrive at our final form.

\bigskip

\bigskip

Case 2: The playlist element is not played, which is represented by
fst(status fst(ple)) = NotP, which says take the status of the ple
and inspect the first element of the status tuple and determine
whether $PlayedOrNot = NotP$.

\bigskip

\[
  \begin{array}{ll@{\hspace{2em}}l}
    & length(played(\langle ple \rangle \cat t)) +
    length(unplayed(\langle ple \rangle \cat t)) \\
    &\Leftrightarrow length(played(\langle ple \rangle \cat t)) +
    length(\langle ple \rangle \cat unplayed(t)) &
    [\mbox{unplayed($\langle  ple  \rangle$ $\cat$ pl)=$\langle  ple
    \rangle$ $\cat$(unplayed(pl))}] \\
    &\Leftrightarrow length(played(t)) + length(\langle ple \rangle
    \cat unplayed(t)) & [\mbox{played($\langle  ple  \rangle$ $\cat$
    pl)=played(pl)}] \\
    &\Leftrightarrow length(played(t)) + snd(ple) +
    length(unplayed(t)) & [\mbox{length($\langle  ple  \rangle$
    $\cat$ pl)=snd(ple)+ length(pl)}] \\
    &\Leftrightarrow snd(ple) + length(played(t)) +
    length(unplayed(t)) & [\mbox{commutativity of addition}] \\
    &\Leftrightarrow snd(ple) + (length(played(t)) +
    length(unplayed(t))) & [\mbox{associativity of addition}] \\
    &\Leftrightarrow snd(ple) + length(t) & [\mbox{length(played(p))+
    length(unplayed(p))=length(p)}] \\
    &\Leftrightarrow length(\langle ple \rangle \cat t) &
    [\mbox{length($\langle  ple  \rangle$ $\cat$ pl)=snd(ple)+ length(pl)}]
  \end{array}
\]

\bigskip

We first rewrite the unplayed term as we know ple is NotP and then we
simplify the played term as we know ple is not Played. From here, we
apply the definition of length for a single sequence element
concatenated to a sequence. We must re-arrange our addends using the
commutative property of addition.  Next, we use the associative
property of addition to arrive at a form of the inductive hypothesis
that we can simplify.  From there, we apply our definition of length
again to arrive at our final form.

\bigskip

\bigskip

Since the base case is proven and both inductive cases result in the
same outcome, we can use the implication introduction rule
[$\Rightarrow$ intro] to unify our cases and conclude:

\bigskip

\noindent
$\displaystyle
\infer{\forall p \colon PossiblePlaylist \bullet length(p)}{
  \forall p \colon PossiblePlaylist \bullet length(played(p)) +
  length(unplayed(p))
}
$

\newpage

\bigskip
\noindent
\textbf{Question 12}

\medskip

\bigskip

First, we can create an abbreviation for the elements of our list to
make our expressions less cumbersome.

\bigskip

\begin{zed}
  ListElement == (ShowId \cross EpisodeId) \cross (\mathbb{N} \cross
  PlayedOrNot \cross SavedOrNot)
\end{zed}

\bigskip

We restate our List free type definition using the abbreviation as

\bigskip

\begin{zed}List ::= nil | join \ldata ListElement \cross List \rdata
\end{zed}

\bigskip

For example, such a List could include (join((1, 2), (3600, NotP,
Saved), (join((1, 1), (3600, Played, Saved)), nil))) which is of the
form (join(e, join(e, nil))).

\bigskip

(a)
\par
\vspace{11pt}
\bigskip

We define the induction principle for this List for the proposition
Q, building upon the List of natural numbers example found in section
13.3 of the course notes \citep[page 162]{simpson-notes}.

\bigskip

\noindent
$\displaystyle
\infer{\forall l \colon List \bullet Q(l)}{
  Q(nil)
  &
  \forall e \colon ListElement \bullet \forall l \colon List \bullet
  Q(l) \Rightarrow Q(join(e, l))
}
$

\medskip

(b)
\par
\vspace{11pt}
\bigskip

Fuzz does not support Z tuple projection such as e.2. Therefore, we
define generic access functions for each element of any triple, which
we will use with ListElement, together with the previously specified
fst() and snd() for tuples.

\bigskip

\begin{gendef}[A, B, C]
  fstOfTriple: A \cross B \cross C \fun A
  \where
  \forall a \colon A \bullet \forall b \colon B \bullet \forall c
  \colon C \bullet fstOfTriple(a, b, c) = a
\end{gendef}

\begin{gendef}[A, B, C]
  sndOfTriple: A \cross B \cross C \fun B
  \where
  \forall a \colon A \bullet \forall b \colon B \bullet \forall c
  \colon C \bullet sndOfTriple(a, b, c) = b
\end{gendef}

\begin{gendef}[A, B, C]
  thrdOfTriple: A \cross B \cross C \fun C
  \where
  \forall a \colon A \bullet \forall b \colon B \bullet \forall c
  \colon C \bullet thrdOfTriple(a, b, c) = c
\end{gendef}

\bigskip

Next, we specify our recursive functions

\bigskip

\begin{axdef}
  length_L : List \fun \mathbb{N}
  \where
  length_L(nil) = 0 \\
  \forall e \colon ListElement \bullet \forall l \colon List \bullet
  length_L(join(e, l)) = fstOfTriple(snd(e)) + length_L(l)
\end{axdef}

\bigskip

The length of a List is the recursive sum of seconds : N, found in
the first position of the triple found in the second element of the
tuple of each ListElement.

\bigskip

\begin{axdef}
  unplayed_L : List \fun List
  \where
  unplayed_L(nil) = nil \\
  \forall e \colon ListElement \bullet \forall l \colon List \bullet
  sndOfTriple(snd(e)) = NotP \land unplayed_L(join(e, l)) = join(e,
  unplayed_L(l)) \\
  \forall e \colon ListElement \bullet \forall l \colon List \bullet
  sndOfTriple(snd(e)) = Played \land unplayed_L(join(e, l)) = unplayed_L(l)
\end{axdef}

\bigskip

The unplayed list of any given list is a new list, which recursively
includes or excludes each ListElement based on the PlayedOrNot free
type value of NotP found in the second position of the triple found
in the second element of the tuple of each ListElement.

\bigskip

\begin{axdef}
  played_L : List \fun List
  \where
  played_L(nil) = nil \\
  \forall e \colon ListElement \bullet \forall l \colon List \bullet
  sndOfTriple(snd(e)) = Played \land played_L(join(e, l)) = join(e,
  played_L(l)) \\
  \forall e \colon ListElement \bullet \forall l \colon List \bullet
  sndOfTriple(snd(e)) = NotP \land played_L(join(e, l)) = played_L(l)
\end{axdef}

\bigskip

The played list of any given list is a new list, which recursively
includes or excludes each ListElement based on the PlayedOrNot free
type value of Played found in the second position of the triple found
in the second element of the tuple of each ListElement.

\bigskip

\medskip

\noindent
\hangindent=2em
(c) $\forall l \colon List \bullet length_L(played_L(l)) +
length_L(unplayed_L(l)) = length_L(l)$

\bigskip

To use proof by induction, we need to prove the base case and the
inductive case. The base case occurs when the List is nil.

\bigskip

\[
  \begin{array}{ll@{\hspace{2em}}l}
    & length_L(played_L(nil)) + length_L(unplayed_L(nil)) \\
    &\Leftrightarrow length_L(nil) + length_L(nil) &
    [\mbox{(un)played(nil)=nil}] \\
    &\Leftrightarrow 0 + 0 & [\mbox{length(nil)=0}] \\
    &\Leftrightarrow 0 & [\mbox{arithmetic}] \\
    &\Leftrightarrow length_L(nil) & [\mbox{length(nil)=0}]
  \end{array}
\]

\bigskip

In the above, we use each of the definitions of played(nil),
unplayed(nil), and length(nil) to prove our base case.

\bigskip

\newpage

\medskip

\section*{Bibliography}

\begin{thebibliography}{Simpson, n.d.}

  \bibitem[Simpson, n.d.]{simpson-notes} Simpson, A. (n.d.).
  \textit{From Discrete Mathematics to State-Based Models, SEM
  version}. University of Oxford Department of Computer Science.
  Unpublished course notes.

  \bibitem[Simpson, 2002]{simpson02} Simpson, A.C. (2002).
  \textit{Discrete Mathematics by Example}. London: McGraw-Hill.

  \bibitem[Simpson, 2025a]{simpson25a} Simpson, A. (2025a).
  \textit{Introduction and propositions}. Lecture slides for Software
  Engineering Mathematics. University of Oxford Department of
  Computer Science. Lecture 01.

  \bibitem[Simpson, 2025b]{simpson25b} Simpson, A. (2025b).
  \textit{Predicate logic and equality}. Lecture slides for Software
  Engineering Mathematics. University of Oxford Department of
  Computer Science. Lecture 02.

  \bibitem[Simpson, 2025c]{simpson25c} Simpson, A. (2025c).
  \textit{Deductive proofs}. Lecture slides for Software Engineering
  Mathematics. University of Oxford Department of Computer Science. Lecture 03.

  \bibitem[Simpson, 2025d]{simpson25d} Simpson, A. (2025d).
  \textit{Sets, types and definitions}. Lecture slides for Software
  Engineering Mathematics. University of Oxford Department of
  Computer Science. Lecture 04.

  \bibitem[Simpson, 2025e]{simpson25e} Simpson, A. (2025e).
  \textit{Relations}. Lecture slides for Software Engineering
  Mathematics. University of Oxford Department of Computer Science. Lecture 05.

  \bibitem[Simpson, 2025f]{simpson25f} Simpson, A. (2025f).
  \textit{Functions and sequences}. Lecture slides for Software
  Engineering Mathematics. University of Oxford Department of
  Computer Science. Lecture 06.

  \bibitem[Simpson, 2025g]{simpson25g} Simpson, A. (2025g).
  \textit{Free types and induction}. Lecture slides for Software
  Engineering Mathematics. University of Oxford Department of
  Computer Science. Lecture 07.

  \bibitem[Spivey, 1992]{spivey92} Spivey, J.M. (1992). \textit{The Z
  Notation: A Reference Manual}. Upper Saddle River, NJ: Prentice Hall.

  \bibitem[Woodcock and Davies, 1996]{woodcock96} Woodcock, J. and
  Davies, J. (1996). \textit{Using Z: Specification, Refinement and
  Proof}. Upper Saddle River, NJ: Prentice Hall.

\end{thebibliography}

\end{document}
