// ============================================================================
// Example: Function Composition
// ============================================================================
// Demonstrates:
//   - Forward composition (o9 or ;)
//   - Backward composition (o or comp)
//   - Composition laws and properties
//   - Chaining multiple functions
//   - Composition with relations
//
// Features:
//   - f o9 g [forward composition: f then g]
//   - f o g [backward composition: g then f]
//   - Associativity
//   - Identity laws
//
// See: docs/USER_GUIDE.md - Section "Functions" > "Composition"
// ============================================================================

=== Function Composition ===

** Example 1: Basic Forward Composition **

TEXT: Forward composition applies f first, then g:

axdef
  f : N -> N
  g : N -> N
  h : N -> N
where
  forall n : N | f(n) = n + 1
  forall n : N | g(n) = n * 2
  h = f o9 g
end

TEXT: h(n) = g(f(n)) = g(n + 1) = (n + 1) * 2 = 2n + 2

** Example 2: Backward Composition **

TEXT: Backward composition applies the second function first:

axdef
  f2 : N -> N
  g2 : N -> N
  h2 : N -> N
where
  forall n : N | f2(n) = n + 1
  forall n : N | g2(n) = n * 2
  h2 = f2 o g2
end

TEXT: h2(n) = f2(g2(n)) = f2(n * 2) = (n * 2) + 1 = 2n + 1

** Example 3: Comparison - Forward vs Backward **

TEXT: Forward composition f o9 g:
TEXT: Input → f → g → Output
TEXT: (f o9 g)(x) = g(f(x))

TEXT: Backward composition f o g:
TEXT: Input → g → f → Output
TEXT: (f o g)(x) = f(g(x))

TEXT: Notice the reversal: o9 applies left-to-right, o applies right-to-left.

** Example 4: Three-Function Composition **

axdef
  addOne : N -> N
  double : N -> N
  square : N -> N
  pipeline : N -> N
where
  forall n : N | addOne(n) = n + 1
  forall n : N | double(n) = 2 * n
  forall n : N | square(n) = n * n
  pipeline = addOne o9 double o9 square
end

TEXT: pipeline(n) = square(double(addOne(n))) = square(double(n + 1)) = square(2(n + 1)) = (2(n + 1))^2

** Example 5: Identity Composition Laws **

axdef
  identity : N -> N
  anyFunc : N -> N
  leftId : N -> N
  rightId : N -> N
where
  forall n : N | identity(n) = n
  forall n : N | anyFunc(n) = n * n
  leftId = identity o9 anyFunc
  rightId = anyFunc o9 identity
end

TEXT: leftId = anyFunc (identity is left identity for o9)
TEXT: rightId = anyFunc (identity is right identity for o9)

** Example 6: Associativity **

TEXT: Composition is associative:

TEXT: (f o9 g) o9 h = f o9 (g o9 h)

TEXT: You can group compositions in any order—the result is the same.

axdef
  f3, g3, h3 : N -> N
  comp1, comp2 : N -> N
where
  forall n : N | f3(n) = n + 1
  forall n : N | g3(n) = n * 2
  forall n : N | h3(n) = n * n
  comp1 = (f3 o9 g3) o9 h3
  comp2 = f3 o9 (g3 o9 h3)
end

TEXT: comp1 = comp2 for all inputs.

** Example 7: Composition with Partial Functions **

axdef
  safeSqrt : N +-> N
  addTen : N -> N
  composed : N +-> N
where
  forall n : N | n * n = n => safeSqrt(n) = n
  forall n : N | addTen(n) = n + 10
  composed = safeSqrt o9 addTen
end

TEXT: composed is only defined where safeSqrt is defined, then adds 10 to the result.

** Example 8: Relation Composition **

TEXT: Composition works for relations too:

axdef
  parent : Person <-> Person
  grandparent : Person <-> Person
where
  grandparent = parent o9 parent
end

given Person

TEXT: grandparent relates a person to their grandparents via two parent links.

** Example 9: Function Pipeline Example **

axdef
  toLowerCase : seq Char -> seq Char
  trim : seq Char -> seq Char
  reverse : seq Char -> seq Char
  process : seq Char -> seq Char
where
  process = toLowerCase o9 trim o9 reverse
end

TEXT: Process a string by converting to lowercase, trimming whitespace, then reversing.

** Example 10: Mathematical Functions **

axdef
  exp : N -> N
  log : N +-> N
  roundTrip : N +-> N
where
  forall n : N | exp(n) = 2^n
  forall n : N | 2^(log(n)) = n and log(n) = (mu k : N | 2^k = n)
  roundTrip = exp o9 log
end

TEXT: roundTrip is (approximately) the identity on powers of 2.

** Example 11: Inverse via Composition **

axdef
  encrypt : seq Char -> seq Char
  decrypt : seq Char -> seq Char
  identity_check : seq Char -> seq Char
where
  identity_check = encrypt o9 decrypt
end

TEXT: If encrypt and decrypt are inverses, then identity_check should be the identity function.

** Example 12: Partial Composition **

TEXT: When composing f : A -> B and g : C -> D, we need ran f subseteq dom g.

axdef
  f4 : N +-> N
  g4 : N +-> N
  h4 : N +-> N
where
  f4 = {1 |-> 10, 2 |-> 20}
  g4 = {10 |-> 100, 20 |-> 200}
  h4 = f4 o9 g4
end

TEXT: h4 = {1 |-> 100, 2 |-> 200}. Composition is defined where ranges align.

** Example 13: Monoid Structure **

TEXT: Functions from A -> A with composition form a monoid:
TEXT: 1. Composition is associative: (f o9 g) o9 h = f o9 (g o9 h)
TEXT: 2. Identity element: id(x) = x, id o9 f = f = f o9 id
TEXT: 3. Closure: composing A -> A functions gives another A -> A function

** Example 14: Practical Example - Data Processing Pipeline **

given Record, ValidatedRecord, ProcessedRecord, Output

axdef
  validate : Record +-> ValidatedRecord
  process : ValidatedRecord -> ProcessedRecord
  format : ProcessedRecord -> Output
  fullPipeline : Record +-> Output
where
  fullPipeline = validate o9 process o9 format
end

TEXT: A three-stage data pipeline: validate, process, format. Composition makes the complete pipeline explicit.

** Example 15: Composition Operator Precedence **

TEXT: Composition operators bind tighter than logical operators:

TEXT: f o9 g = h means (f o9 g) = h, not f o9 (g = h)

TEXT: Use parentheses to clarify: (f o9 g) or f o9 (g o9 h)

** Example 16: Self-Composition **

axdef
  doubleIt : N -> N
  quadrupleIt : N -> N
where
  forall n : N | doubleIt(n) = 2 * n
  quadrupleIt = doubleIt o9 doubleIt
end

TEXT: quadrupleIt(n) = doubleIt(doubleIt(n)) = 2 * (2 * n) = 4n

** Example 17: Iterated Composition **

axdef
  increment : N -> N
  addFive : N -> N
where
  forall n : N | increment(n) = n + 1
  addFive = increment o9 increment o9 increment o9 increment o9 increment
end

TEXT: Composing increment 5 times gives addFive.

** Example 18: Functional Programming Style **

TEXT: Composition enables a functional programming style:

TEXT: Instead of: result = h(g(f(x)))
TEXT: Use: pipeline = f o9 g o9 h; result = pipeline(x)

TEXT: This separates pipeline definition from application, improving modularity.

** Example 19: Composition with Type Changes **

axdef
  length : seq N -> N
  isEven : N -> B
  seqIsEvenLength : seq N -> B
where
  forall s : seq N | length(s) = # s
  forall n : N | isEven(n) = (n mod 2 = 0)
  seqIsEvenLength = length o9 isEven
end

TEXT: Compose functions with different types: seq N -> N -> B.

** Example 20: Best Practices **

TEXT: When using composition:
TEXT: 1. Choose forward (o9) or backward (o) consistently in your codebase
TEXT: 2. Document the data flow direction
TEXT: 3. Break complex pipelines into named intermediate steps
TEXT: 4. Type-check that domains and ranges align
TEXT: 5. Use composition to create reusable pipelines
TEXT: 6. Test individual functions before composing them
TEXT: 7. Remember: o9 reads left-to-right (natural for pipelines), o reads right-to-left (traditional math notation)
