// ============================================================================
// Example: Finite Partial Functions (77->)
// ============================================================================
// Demonstrates:
//   - Finite partial function type (77->)
//   - Functions with bounded finite domains
//   - Use case: modeling limited capacity resources
//   - Comparison with other function types
//
// Features:
//   - X 77-> Y [finite partial function]
//   - Partial: not all inputs mapped
//   - Finite: domain has finite cardinality
//   - Functional: each input maps to at most one output
//
// See: docs/USER_GUIDE.md - Section "Functions" > "Function Types"
// ============================================================================

=== Phase 34: Finite Partial Functions ===

TEXT: Finite partial functions are partial functions with a finite domain. The operator 77-> denotes a finite partial function, meaning the function may not be defined everywhere, and its domain must be finite.

** Example 1: Basic Finite Function Type **

TEXT: A finite partial function from X to Y is a partial function whose domain is finite. This is useful when modeling resources with limited capacity or databases with a bounded number of entries.

zed
  given Year, TableFF
end


axdef
  records : Year 77-> TableFF
where
  # (dom records) <= 1000
end

TEXT: The records relation is a finite partial function because:
TEXT: 1. It is partial: not all years need to have a table
TEXT: 2. Its domain is finite: at most 1000 years have records
TEXT: 3. It is functional: each year maps to at most one table

** Example 2: Comparison with Other Function Types **

TEXT: Comparison of function type operators:

TEXT: - Total function (->): defined for all inputs, domain is entire source set
TEXT: - Partial function (+->): may not be defined for all inputs, domain may be infinite
TEXT: - Finite partial function (77->): partial function with finite domain
TEXT: - Total bijection (>->>): defined everywhere, injective and surjective

zed
  given X, Y
end


axdef
  totalFunc : X -> Y
  partialFunc : X +-> Y
  finitePartialFunc : X 77-> Y
  totalBij : X >->> Y
where
  dom totalFunc = X land dom totalBij = X land (forall x1, x2 : X | totalBij(x1) = totalBij(x2) . x1 = x2) land ran totalBij = Y
end

** Example 3: Finite Functions elem Practice **

TEXT: Real-world example: A database table storing customer preferences.

zed
  given CustomerID, Preference
end


axdef
  preferences : CustomerID 77-> Preference
where
  # (dom preferences) <= 10000
end

TEXT: This models a preference database where:
TEXT: - Not all customers have preferences recorded (partial)
TEXT: - The database has a capacity limit (finite domain)
TEXT: - Each customer maps to one preference value (functional)

** Example 4: Operations on Finite Functions **

axdef
  f : N 77-> N
  g : N 77-> N
where
  f = {1 |-> 10, 2 |-> 20, 3 |-> 30} land g = {10 |-> 100, 20 |-> 200} land # (dom f) = 3 land # (dom g) = 2
end

TEXT: We can compose finite functions, but the result may not be finite unless proven.

axdef
  f_composed : N 77-> N
where
  f_composed = g o9 f land # (dom f_composed) <= # (dom f)
end

TEXT: The composition has a domain size bounded by the domain of f, since we can only compose where f's range intersects g's domain.

** Example 5: Domain Restrictions land Finiteness **

zed
  given Title, Length, ViewDate
end


axdef
  viewed : Title 77-> ViewDate
  recent_viewed : Title 77-> ViewDate
  recentSet : P Title
where
  recentSet = {t : Title | t elem dom viewed} land recent_viewed = recentSet <| viewed land # (dom recent_viewed) <= # (dom viewed)
end

TEXT: Restricting a finite partial function preserves finiteness. The recent_viewed function has a domain that is a subset of viewed's domain, so it remains finite.
