\documentclass[a4paper,10pt,fleqn]{article}
\usepackage[margin=1in]{geometry}
\usepackage{amssymb}
\usepackage{natbib}
\usepackage{fuzz}
\usepackage{zed-maths}
\usepackage{zed-proof}
\begin{document}

\section*{Function Definitions}

\bigskip

This file demonstrates various types of function $definitions \in Z$ notation, from simple total functions to complex generic and higher-order functions.

\bigskip

\bigskip
\noindent
\textbf{Example 1 : Simple Total Functions}

\medskip

\bigskip

Total functions are defined over their entire domain. Every input has a corresponding output.

\bigskip

\begin{axdef}
square : \nat \fun \nat
\where
\forall n : \nat @ square(n) = n * n
\end{axdef}

\begin{axdef}
successor : \nat \fun \nat
\where
\forall n : \nat @ successor(n) = n + 1
\end{axdef}

\begin{axdef}
isEven : \nat \fun \nat
\where
\forall n : \nat @ (isEven(n) = 1 \Leftrightarrow (\exists k : \nat @ n = 2 * k)) \land (isEven(n) = 0 \lor isEven(n) = 1)
\end{axdef}

\bigskip

isEven returns 1 for even numbers and 0 for odd numbers.

\bigskip

\bigskip
\noindent
\textbf{Example 2 : Partial Functions}

\medskip

\bigskip

Partial functions are not defined over their entire domain. Some inputs may not have outputs.

\bigskip

\begin{axdef}
double : \nat \fun \nat
\where
\forall n : \nat @ double(n) = 2 * n
\end{axdef}

\bigskip

double is a total function that multiplies its input by 2.

\bigskip

\begin{axdef}
predecessor : \nat \pfun \nat
\where
\forall n : \nat @ n > 0 \implies predecessor(n) = n - 1
\end{axdef}

\bigskip

predecessor is partial on natural numbers since 0 has no $predecessor \in N$.

\bigskip

\begin{axdef}
half : \nat \pfun \nat
\where
\forall n : \nat @ n \mod 2 = 0 \implies half(n) * 2 = n
\end{axdef}

\bigskip

half is partial because only even numbers have integer halves.

\bigskip

\bigskip
\noindent
\textbf{Example 3 : Generic ( Polymorphic ) Functions}

\medskip

\bigskip

Generic functions work with any type parameter.

\bigskip

\begin{gendef}[X]
  identity: X \fun X
\where
  \forall x : X @ identity(x) = x
\end{gendef}

\begin{gendef}[X]
  constant: X \cross X \fun X
\where
  \forall x, y : X @ constant(x, y) = x
\end{gendef}

\begin{gendef}[X, Y]
  first: X \cross Y \fun X
\where
  \forall x : X @ \forall y : Y @ first(x, y) = x
\end{gendef}

\begin{gendef}[X, Y]
  second: X \cross Y \fun Y
\where
  \forall x : X @ \forall y : Y @ second(x, y) = y
\end{gendef}

\begin{gendef}[X]
  swap: X \cross X \fun X \cross X
\where
  \forall x, y : X @ swap(x, y) = (y, x)
\end{gendef}

\bigskip
\noindent
\textbf{Example 4 : Functions on Sequences}

\medskip

\bigskip

Functions that operate on sequences.

\bigskip

\begin{gendef}[X]
  append: \seq X \cross X \fun \seq X
\where
  \forall s : \seq X @ \forall x : X @ append(s, x) = s^{\langle x \rangle}
\end{gendef}

\begin{gendef}[X]
  first: \seq X \pfun X
\where
  \forall s : \seq X @ s \neq \langle \rangle \implies first(s) = \head s
\end{gendef}

\bigskip

first is partial because it is not defined on the empty sequence.

\bigskip

\begin{gendef}[X]
  rest: \seq X \pfun \seq X
\where
  \forall s : \seq X @ s \neq \langle \rangle \implies rest(s) = \tail s
\end{gendef}

\bigskip

For pattern matching examples with recursive definitions, see examples/09_sequences/pattern_matching.txt

\bigskip

\bigskip
\noindent
\textbf{Example 5 : Higher - Order Functions}

\medskip

\bigskip

Higher-order functions take other functions as arguments or return functions. These are advanced constructs that may require specialized type system support.

\bigskip

\bigskip

Example signatures (axiomatization omitted for simplicity):

\bigskip

\begin{gendef}[X]
  apply: X \fun X \cross X \fun X
\end{gendef}

\begin{gendef}[X, Y, Z]
  compose: Y \fun \num \cross X \fun Y \fun (X \fun \num)
\end{gendef}

\begin{gendef}[X]
  twice: X \fun X \fun (X \fun X)
\end{gendef}

\bigskip

Note: Full axiomatization of higher-order functions requires quantification over function types, which may have limited support in some Z type checkers.

\bigskip

\bigskip
\noindent
\textbf{Example 6 : Functions with Complex Domains}

\medskip

\bigskip

Functions can have complex domain constraints.

\bigskip

\begin{zed}[Person, Date]\end{zed}

\begin{axdef}
age : Person \cross Date \fun \nat
\where
\forall p : Person @ \forall d : Date @ age(p, d) \geq 0
\end{axdef}

\begin{axdef}
eligible : Person \cross Date \fun \nat
\where
\forall p : Person @ \forall d : Date @ (eligible(p, d) = 1 \Leftrightarrow age(p, d) \geq 18) \land (eligible(p, d) = 0 \lor eligible(p, d) = 1)
\end{axdef}

\bigskip

eligible returns 1 if the person is 18 or older on the given date, 0 otherwise.

\bigskip

\bigskip
\noindent
\textbf{Example 7 : Set - Valued Functions}

\medskip

\bigskip

Functions can return sets as their range.

\bigskip

\begin{gendef}[X]
  powerset: \power X \fun \power \power X
\where
  \forall s : \power X @ powerset(s) = \power s
\end{gendef}

\begin{zed}[Student, Course]\end{zed}

\begin{axdef}
enrolled : Student \fun \power Course
\where
\forall s : Student @ \# (enrolled(s)) \leq 8
\end{axdef}

\bigskip

Each student is enrolled in at most 8 courses.

\bigskip

\bigskip
\noindent
\textbf{Example 8 : Injective Functions}

\medskip

\bigskip

Injective (one-to-one) functions map distinct inputs to distinct outputs.

\bigskip

\begin{zed}[StudentId, Student]\end{zed}

\begin{axdef}
studentRecord : StudentId \inj Student
\where
\forall id1, id2 : StudentId @ id1 \neq id2 \implies studentRecord(id1) \neq studentRecord(id2)
\end{axdef}

\bigskip

Each student ID maps to a unique student record.

\bigskip

\bigskip
\noindent
\textbf{Example 9 : Surjective Functions}

\medskip

\bigskip

Surjective (onto) functions cover the entire range.

\bigskip

\begin{axdef}
modulo3 : \nat \surj \{0, 1, 2\}
\where
\forall n : \nat @ modulo3(n) = n \mod 3
\end{axdef}

\bigskip

modulo3 is surjective because every value in $\{0, 1, 2\}$ is reached.

\bigskip

\bigskip
\noindent
\textbf{Example 10 : Bijective Functions}

\medskip

\bigskip

Bijective functions are both injective and surjective.

\bigskip

\begin{axdef}
encode : \nat \bij \nat
\where
\forall n : \nat @ encode(n) = 2 * n + 1
\end{axdef}

\bigskip

This encodes natural numbers to odd numbers bijectively.

\bigskip

\bigskip
\noindent
\textbf{Example 11 : Recursive Functions on Natural Numbers}

\medskip

\bigskip

Functions defined recursively using mathematical induction.

\bigskip

\begin{axdef}
triple : \nat \fun \nat
\where
\forall n : \nat @ triple(n) = 3 * n
\end{axdef}

\begin{axdef}
powerOfTwo : \nat \fun \nat
\where
\forall n : \nat @ powerOfTwo(n) = 2 * powerOfTwo(n - 1) \land powerOfTwo(0) = 1
\end{axdef}

\bigskip

Note: More complex recursive definitions like factorial and fibonacci typically require pattern matching or additional axioms not shown here.

\bigskip

\bigskip
\noindent
\textbf{Example 12 : Functions Using mu ( Definite Description )}

\medskip

\bigskip

The mu operator selects the unique element satisfying a property.

\bigskip

\begin{gendef}[X]
  minimum: \seq_1 X \fun X
\where
  \forall s : \seq_1 X @ minimum(s) = (\mu x : X | x \in \ran s \land (\forall y : X @ y \in \ran s \implies x \leq y))
\end{gendef}

\bigskip

minimum selects the unique smallest element from a non-empty sequence.

\bigskip

\bigskip
\noindent
\textbf{Example 13 : Piecewise - Defined Functions}

\medskip

\bigskip

Functions defined by cases using conditional expressions.

\bigskip

\begin{axdef}
absolute : \num \fun \nat
\where
\forall n : \num @ absolute(n) = \IF n \geq 0 \THEN n \ELSE -n
\end{axdef}

\begin{axdef}
signum : \num \fun \{-1, 0, 1\}
\where
\forall n : \num @ signum(n) = \IF n > 0 \THEN 1 \ELSE \IF n = 0 \THEN 0 \ELSE -1
\end{axdef}

\begin{axdef}
max : \nat \cross \nat \fun \nat
\where
\forall a, b : \nat @ max(a, b) = \IF a \geq b \THEN a \ELSE b
\end{axdef}

\begin{axdef}
min : \nat \cross \nat \fun \nat
\where
\forall a, b : \nat @ min(a, b) = \IF a \leq b \THEN a \ELSE b
\end{axdef}

\end{document}