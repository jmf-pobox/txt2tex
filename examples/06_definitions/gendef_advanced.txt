// ============================================================================
// Example: Generic Definitions (Advanced)
// ============================================================================
// Demonstrates:
//   - Complex generic patterns
//   - Multiple type parameters
//   - Generic schemas
//   - Higher-order generic functions
//   - Nested generic types
//
// Features:
//   - gendef with 2-3 type parameters
//   - Generic schemas and state
//   - Function types as parameters
//   - Generic data structures
//
// See: docs/USER_GUIDE.md - Section "Generic Definitions" > "Advanced Patterns"
// ============================================================================

=== Advanced Generic Definitions ===

zed
  given BGA
end


** Example 1: Generic Three-Way Product **

TEXT: Generic function for three-component tuples:

gendef [X, Y, Z]
  triple : X cross Y cross Z -> X cross Y cross Z
  getFirst : X cross Y cross Z -> X
  getSecond : X cross Y cross Z -> Y
  getThird : X cross Y cross Z -> Z
where
  forall x : X; y : Y; z : Z |
    triple(x, y, z) = (x, y, z) land
    getFirst(x, y, z) = x land
    getSecond(x, y, z) = y land
    getThird(x, y, z) = z
end

TEXT: Projection functions for triples.

** Example 2: Generic Binary Tree (Conceptual) **

TEXT: Binary trees are typically defined for specific types in Z notation rather than as fully polymorphic structures. For a concrete type like N, you would define: Tree ::= leaf | node⟨N cross Tree cross Tree⟩. Generic trees require complex workarounds beyond standard gendef blocks, as free types in fuzz are not easily parameterized.

** Example 6: Generic State Schema **

TEXT: A generic container with capacity:
TEXT:
TEXT: Note: Fuzz supports generic schemas using the schema[X] syntax (not gendef):

schema Container[X]
  contents : seq X
  capacity : N
where
  # contents <= capacity
end

TEXT: This schema is parameterized by the element type X.
TEXT: It can be instantiated as Container[N], Container[Char], etc.

** Example 7: Generic Relation Operations **

TEXT: Relational composition for any types:

gendef [X, Y, Z]
  compose : (X <-> Y) cross (Y <-> Z) -> (X <-> Z)
where
  forall R : X <-> Y; S : Y <-> Z |
    compose(R, S) = R comp S
end

TEXT: Composes two relations using forward composition.

** Example 8: Generic Option Type (Conceptual) **

TEXT: Optional values (like Maybe or Option in other languages) are challenging to express generically in Z notation due to limitations with parameterized free types. For a specific type, you would define: Option ::= none | some⟨T⟩. Fully generic option types with operations require advanced patterns beyond standard gendef blocks.

** Example 9: Generic Stack Schema **

TEXT: Note: Define generic schema separately, then declare operations in gendef:

schema Stack[X]
  items : seq X
  maxSize : N
where
  # items <= maxSize
end

gendef [X]
  emptyStack : Stack[X]
  stackSize : Stack[X] -> N
where
  emptyStack.items = ⟨⟩ land emptyStack.maxSize = 100
  forall s : Stack[X] | stackSize(s) = # (s.items)
end

TEXT: Generic stack with query operations.
TEXT: The schema is defined separately using schema[X] syntax, then operations use gendef.

** Example 10: Generic Pair Schema **

TEXT: Use schema[X, Y] syntax for generic schemas:

schema OrderedPair[X, Y]
  first : X
  second : Y
end

TEXT: A generic pair type.
TEXT: The schema has two type parameters and can be instantiated as OrderedPair[N, Char], etc.

** Example 11: Generic Zip Function **

TEXT: Combine two sequences into a sequence of pairs:

gendef [X, Y]
  zip : seq X cross seq Y -> seq(X cross Y)
where
  zip(⟨⟩, ⟨⟩) = ⟨⟩
  forall x : X; y : Y; xs : seq X; ys : seq Y |
    zip(⟨x⟩ ⌢ xs, ⟨y⟩ ⌢ ys) = ⟨(x, y)⟩ ⌢ zip(xs, ys)
  forall xs : seq X | zip(xs, ⟨⟩) = ⟨⟩
  forall ys : seq Y | zip(⟨⟩, ys) = ⟨⟩
end

TEXT: Pairs up corresponding elements from two sequences.

** Example 12: Practical Example - Generic Database TableGA **

TEXT: Note: Define generic schema separately, then query operations in gendef:

zed
  given Key, Value
end


schema TableGA[Key, Value]
  entries : Key +-> Value
  size : N
where
  size = # (dom entries)
end

gendef [Key, Value]
  emptyTable : TableGA[Key, Value]
  tableSize : TableGA[Key, Value] -> N
  allKeys : TableGA[Key, Value] -> P Key
where
  emptyTable.entries = {} land emptyTable.size = 0
  forall t : TableGA[Key, Value] | tableSize(t) = t.size
  forall t : TableGA[Key, Value] | allKeys(t) = dom (t.entries)
end

TEXT: A generic key-value table with query operations. This demonstrates how generic definitions enable reusable, type-safe data structures.
TEXT: The TableGA schema is defined with schema[Key, Value] syntax, allowing proper fuzz typechecking.
