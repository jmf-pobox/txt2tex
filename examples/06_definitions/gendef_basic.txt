// ============================================================================
// Example: Generic Definitions (Basic)
// ============================================================================
// Demonstrates:
//   - gendef syntax for polymorphic definitions
//   - Single type parameter [X]
//   - Generic functions and constants
//   - Type instantiation
//   - Basic generic patterns
//
// Features:
//   - gendef [X] ... end [generic definition]
//   - Generic identity function
//   - Generic pairing functions
//   - seq[T], P[T] type instantiation
//
// See: docs/USER_GUIDE.md - Section "Generic Definitions"
// ============================================================================

=== Basic Generic Definitions ===

** Example 1: Generic Identity Function **

TEXT: The identity function works for any type:

gendef [X]
  identity : X -> X
where
  forall x : X | identity(x) = x
end

TEXT: This defines identity polymorphically. It can be used with any type: identity applied to a natural number returns that number, identity applied to a set returns that set, etc.

** Example 2: Generic Constant **

TEXT: A generic empty set:

gendef [X]
  empty : P X
where
  empty = {}
end

TEXT: The empty set can be instantiated for any type X.

** Example 3: Generic Pair Functions **

TEXT: Extract the first element of a pair:

gendef [X, Y]
  fst : X cross Y -> X
where
  forall x : X; y : Y | fst(x, y) = x
end

TEXT: Extract the second element:

gendef [X, Y]
  snd : X cross Y -> Y
where
  forall x : X; y : Y | snd(x, y) = y
end

TEXT: These work for pairs of any types.

** Example 4: Generic Singleton Set **

TEXT: Create a set containing a single element:

gendef [X]
  singleton : X -> P X
where
  forall x : X | singleton(x) = {x}
end

TEXT: Given any value, singleton produces a set containing just that value.

** Example 5: Generic Sequence Operations **

TEXT: The head of a sequence (generic version):

gendef [X]
  headOf : seq X -> X
where
  forall s : seq X | # s > 0 . headOf(s) = s(1)
end

TEXT: This is defined only for non-empty sequences.

** Example 6: Generic Set Membership (Conceptual) **

TEXT: Set membership can be tested using the built-in 'in' operator in Z notation. In other contexts, you might define a membership test function, but Z notation provides this as a primitive predicate: x in S is true exactly when x is an element of S.

** Example 7: Generic Optional Type (Conceptual) **

TEXT: Optional values can be modeled with free types in Z notation. For a specific type, you would define: Option ::= none | some⟨T⟩. Generic optional types require more complex setup beyond basic gendef blocks, as free types in Z are typically defined for specific types rather than being polymorphic.

** Example 8: Generic Swap Function **

TEXT: Swap the components of a pair:

gendef [X, Y]
  swap : X cross Y -> Y cross X
where
  forall x : X; y : Y | swap(x, y) = (y, x)
end

TEXT: Converts (x, y) to (y, x).

** Example 9: Generic Cardinality **

TEXT: Size of a set (for finite sets):

gendef [X]
  size : P X -> N
where
  forall S : P X | size(S) = # S
end

TEXT: Returns the number of elements in a finite set.

** Example 10: Generic List Construction **

TEXT: Construct a singleton sequence:

gendef [X]
  single : X -> seq X
where
  forall x : X | single(x) = ⟨x⟩
end

TEXT: Wraps a value in a single-element sequence.

** Example 11: Using Generic Definitions **

TEXT: Once defined, generic functions can be instantiated for specific types:

axdef
  id_nat : N -> N
  id_set : P N -> P N
where
  id_nat = identity[N]
  id_set = identity[P N]
end

TEXT: Here identity[N] is the identity function instantiated for natural numbers, and identity[P N] is instantiated for sets of natural numbers.

** Example 12: Generic Constants **

TEXT: Define a generic empty sequence:

gendef [X]
  emptySeq : seq X
where
  emptySeq = ⟨⟩
end

TEXT: This can be instantiated as emptySeq[N] for an empty sequence of naturals, emptySeq[Person] for an empty sequence of persons, etc.
