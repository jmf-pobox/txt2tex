\documentclass[a4paper,10pt,fleqn]{article}
\usepackage[margin=1in]{geometry}
\usepackage{amssymb}
\usepackage{adjustbox}
\usepackage{natbib}
\usepackage{fuzz}
\usepackage{zed-maths}
\usepackage{zed-proof}
\usepackage[colorlinks=true,linkcolor=blue,citecolor=blue,urlcolor=blue]{hyperref}
\newdimen\savedleftskip
\begin{document}

\section*{Advanced Generic Definitions}

\begin{zed}[B]
\end{zed}

\section*{Example 1 : Generic Three - Way Product}
\addcontentsline{toc}{section}{Example 1 : Generic Three - Way Product}

\noindent Generic function for three-component tuples:

\bigskip

\begin{gendef}[X, Y, Z]
  triple: X \cross Y \cross \num \fun X \cross Y \cross \num \\
  getFirst: X \cross Y \cross \num \fun X \\
  getSecond: X \cross Y \cross \num \fun Y \\
  getThird: X \cross Y \cross \num \fun \num
  \where
  \forall x : X @ \forall y : Y @ \forall z : \num @ triple(x, y, z)
  = (x, y, z) \land \\
  \quad getFirst(x, y, z) = x \land \\
  \quad getSecond(x, y, z) = y \land \\
  \quad getThird(x, y, z) = z
\end{gendef}

\noindent Projection functions for triples.

\bigskip

\section*{Example 2 : Generic Binary Tree ( Conceptual )}
\addcontentsline{toc}{section}{Example 2 : Generic Binary Tree ( Conceptual )}

\noindent Binary trees are typically defined for specific $types \in
Z$ notation rather than as fully polymorphic structures. For a
concrete type like N, you would $define : Tree$ ::= leaf $\mid$
node⟨N cross Tree cross Tree⟩. Generic trees require complex
workarounds beyond standard gendef blocks, as free types in fuzz are
not easily parameterized.

\bigskip

\section*{Example 6 : Generic State Schema}
\addcontentsline{toc}{section}{Example 6 : Generic State Schema}

\noindent A generic container with capacity:

\bigskip

\noindent

\bigskip

\noindent Note: Fuzz supports generic schemas using the schema[X]
syntax (not gendef):

\bigskip

\begin{schema}{Container}[X]
  contents : \seq X \\
  capacity : \nat
  \where
  \# contents \leq capacity
\end{schema}

\noindent This schema is parameterized by the element type X.

\bigskip

\noindent It can be instantiated as Container[N], Container[Char], etc.

\bigskip

\section*{Example 7 : Generic Relation Operations}
\addcontentsline{toc}{section}{Example 7 : Generic Relation Operations}

\noindent Relational composition for any types:

\bigskip

\begin{gendef}[X, Y, Z]
  compose: (X \rel Y) \cross (Y \rel \num) \fun (X \rel \num)
  \where
  \forall R : X \rel Y @ \forall S : Y \rel \num @ compose(R, S) = R \comp S
\end{gendef}

\noindent Composes two relations using forward composition.

\bigskip

\section*{Example 8 : Generic Option Type ( Conceptual )}
\addcontentsline{toc}{section}{Example 8 : Generic Option Type ( Conceptual )}

\noindent Optional values $(like(Maybe) \lor Option \in
other(languages))$ are challenging to express $generically \in Z$
notation due to limitations with parameterized free types. For a
specific type, you would $define : Option$ ::= none $\mid$ some⟨T⟩.
Fully generic option types with operations require advanced patterns
beyond standard gendef blocks.

\bigskip

\section*{Example 9 : Generic Stack Schema}
\addcontentsline{toc}{section}{Example 9 : Generic Stack Schema}

\noindent Note: Define generic schema separately, then declare
operations in gendef:

\bigskip

\begin{schema}{Stack}[X]
  items : \seq X \\
  maxSize : \nat
  \where
  \# items \leq maxSize
\end{schema}

\begin{gendef}[X]
  emptyStack: Stack[X] \\
  stackSize: Stack[X] \fun \nat
  \where
  emptyStack.items = \langle \rangle \land emptyStack.maxSize = 100 \\
  \forall s : Stack[X] @ stackSize(s) = \# s.items
\end{gendef}

\noindent Generic stack with query operations.

\bigskip

\noindent The schema is defined separately using schema[X] syntax,
then operations use gendef.

\bigskip

\section*{Example 10 : Generic Pair Schema}
\addcontentsline{toc}{section}{Example 10 : Generic Pair Schema}

\noindent Use schema[X, Y] syntax for generic schemas:

\bigskip

\begin{schema}{OrderedPair}[X, Y]
  first : X \\
  second : Y
\end{schema}

\noindent A generic pair type.

\bigskip

\noindent The schema has two type parameters and can be instantiated
as OrderedPair[N, Char], etc.

\bigskip

\section*{Example 11 : Generic Zip Function}
\addcontentsline{toc}{section}{Example 11 : Generic Zip Function}

\noindent Combine two sequences into a sequence of pairs:

\bigskip

\begin{gendef}[X, Y]
  zip: \seq X \cross \seq Y \fun \seq (X \cross Y)
  \where
  zip(\langle \rangle, \langle \rangle) = \langle \rangle \\
  \forall x : X @ \forall y : Y @ \forall xs : \seq X @ \forall ys :
  \seq Y @ zip(\langle x \rangle \cat xs, \langle y \rangle \cat ys)
  = \langle (x, y) \rangle \cat zip(xs, ys) \\
  \forall xs : \seq X @ zip(xs, \langle \rangle) = \langle \rangle \\
  \forall ys : \seq Y @ zip(\langle \rangle, ys) = \langle \rangle
\end{gendef}

\noindent Pairs up corresponding elements from two sequences.

\bigskip

\section*{Example 12 : Practical Example - Generic Database Table}
\addcontentsline{toc}{section}{Example 12 : Practical Example -
Generic Database Table}

\noindent Note: Define generic schema separately, then query
operations in gendef:

\bigskip

\begin{zed}[Key, Value]
\end{zed}

\begin{schema}{Table}[Key, Value]
  entries : Key \pfun Value \\
  size : \nat
  \where
  size = \# (\dom entries)
\end{schema}

\begin{gendef}[Key, Value]
  emptyTable: Table[Key, Value] \\
  tableSize: Table[Key, Value] \fun \nat \\
  allKeys: Table[Key, Value] \fun \power Key
  \where
  emptyTable.entries = \{\} \land emptyTable.size = 0 \\
  \forall t : Table[Key, Value] @ tableSize(t) = t.size \\
  \forall t : Table[Key, Value] @ allKeys(t) = \dom t.entries
\end{gendef}

\noindent A generic key-value table with query operations. This
demonstrates how generic definitions enable reusable, type-safe data structures.

\bigskip

\noindent The Table schema is defined with schema[Key, Value] syntax,
allowing proper fuzz typechecking.

\bigskip

\end{document}
