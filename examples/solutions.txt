=== Propositional logic ===

** Solution 1 **

(a)

TEXT: false (as (true => false) <=> false)

(b)

TEXT: true (as (false => false) <=> true)

(c)

TEXT: true (as (false => true) <=> true)

(d)

TEXT: true (as (false => false) <=> true)

TEXT: (Assuming that pigs can't fly . . . )

** Solution 2 **

(a)

TRUTH TABLE:
p | q | p and q | (p and q) => p
T | T | T | T
T | F | F | T
F | T | F | T
F | F | F | T

(b)

TRUTH TABLE:
p | q | p and q | not p | not p => (p and q) | (not p => (p and q)) <=> p
T | T | T | F | T | T
T | F | F | F | T | T
F | T | F | T | F | T
F | F | F | T | F | T

(c)

TRUTH TABLE:
p | q | p => q | p and (p => q) | (p and (p => q)) => q
T | T | T | T | T
T | F | F | F | T
F | T | T | F | T
F | F | T | F | T

** Solution 3 **

(a)

EQUIV:
p => not p
<=> not p or not p [=>]
<=> not p [idempotence]

(b)

EQUIV:
not p => p
<=> not not p or p [=>]
<=> p or p [not not]
<=> p [idempotence]

(c)

EQUIV:
p => (q => r)
<=> not p or (q => r) [=>]
<=> not p or (not q or r) [=>]
<=> (not p or not q) or r [associativity]
<=> not (p and q) or r [De Morgan]
<=> (p and q) => r [=>]

(d)

EQUIV:
q => (p => r)
<=> not q or (p => r) [=>]
<=> not q or (not p or r) [=>]
<=> not p or (not q or r) [associativity and commutativity]
<=> not p or (q => r) [=>]
<=> p => (q => r) [=>]

(e)

EQUIV:
((p and q) <=> p)
<=> ((p and q) => p) and (p => (p and q)) [<=>]
<=> (not (p and q) or p) and (not p or (p and q)) [=>]
<=> ((not p or not q) or p) and (not p or (p and q)) [De Morgan]
<=> (not q or (not p or p)) and (not p or (p and q)) [associativity and comm.]
<=> (not q or true) and (not p or (p and q)) [excluded middle]
<=> true and (not p or (p and q)) [or and true]
<=> not p or (p and q) [and and true]
<=> (not p or p) and (not p or q) [distribution]
<=> true and (not p or q) [excluded middle]
<=> not p or q [and and true]
<=> p => q [=>]

(f)

EQUIV:
((p or q) <=> p)
<=> ((p or q) => p) and (p => (p or q)) [<=>]
<=> (not (p or q) or p) and (not p or (p or q)) [=>]
<=> ((not p and not q) or p) and (not p or (p or q)) [De Morgan]
<=> ((not p or p) and (not q or p)) and (not p or (p or q)) [distribution]
<=> (true and (not q or p)) and (not p or (p or q)) [excluded middle]
<=> (not q or p) and (not p or (p or q)) [and and true]
<=> (not q or p) and ((not p or p) or q) [associativity]
<=> (not q or p) and (true or q) [excluded middle]
<=> (not q or p) and true [or and true]
<=> (not q or p) [and and true]
<=> q => p [=>]

** Solution 4 **

TEXT: (a) (p or q) <=> ((not p or not q) and q) is not a tautology. You might illustrate this via a truth table or via a chain of equivalences, showing that the proposition is not equivalent to true. Alternatively, you might try and find a combination of values for which the proposition is false. (In this case, the proposition is false when p and q are both true.)

TEXT: (b) (p or q) <=> ((not p and not q) or q) is not a tautology. In this case, the proposition is false when p is true and q is false.

** Solution 5 **

(a)

exists d : Dog | gentle(d) and well_trained(d)

(b)

forall d : Dog | neat(d) and well_trained(d) => attractive(d)

(c)

TEXT: (Requires nested quantifier in implication - parser limitation)

** Solution 6 **

(a)

TEXT: This is a true proposition: whatever the value of x, the expression x^2 - x + 1 denotes a natural number. If we choose y to be this natural number, we will find that p is true.

(b)

TEXT: This is a false proposition. We cannot choose a large enough value for y such that p will hold for any value of x.

(c)

TEXT: This is a false proposition. It is an implication whose antecedent part is true and whose consequent part is false.

(d)

TEXT: This is a true proposition. It is an implication whose antecedent part is false and whose consequent part is true.

** Solution 7 **

(a)

TEXT: We must define a predicate p that is false for at least one value of x, and is true for at least one other value. A suitable solution would be p <=> x > 1.

(b)

TEXT: With the above choice of p, we require only that q is sometimes false when p is true (for else the universal quantification would hold). A suitable solution would be q <=> x > 3.

** Solution 8 **

(a)

forall x : N | x >= z

=== Equality ===

** Solution 9 **

(d)

EQUIV:
exists x : N | (x = 1 and x > y) or (x = 2 and x > z)
<=> (exists x : N | x = 1 and x > y) or (exists x : N | x = 2 and x > z)
<=> (1 in N and 1 > y) or (exists x : N | x = 2 and x > z)
<=> (1 in N and 1 > y) or (2 in N and 2 > z)
<=> 1 > y or 2 > z

** Solution 10 **

TEXT: As discussed, the quantifier exists1 can help give rise to a 'test' or 'precondition' to ensure that an application of mu will work.

TEXT: So, as a simple example, as the proposition

exists1 n : N | (forall m : N | n <= m)

TEXT: is equivalent to true, we can be certain that the statement

(mu n : N | (forall m : N | n <= m))

TEXT: will return a result (which happens to be 0).

** Solution 11 **

(a)

TEXT: (mu a : N | a = a) = 0 is a provable statement, since 0 is the only natural number with the specified property.

(b)

TEXT: (mu b : N | b = b) = 1 is not provable. The specified property is true of both 0 and 1, and thus the value of the mu-expression is undefined.

(c)

TEXT: (mu c : N | c > c) = (mu c : N | c > c) is a provable statement. Neither expression is properly defined, but we may conclude that they are equal; there is little else that we can prove about them.

(d)

TEXT: (mu d : N | d = d) = 1 is not a provable statement. We cannot confirm that 1 is the only natural number with the specified property; we do not know what value is taken by undefined operations.

** Solution 12 **

TEXT: (Requires mu-operator with expression part - not yet implemented)

(a)

TEXT: (mu m : Mountain | (forall n : Mountain | height(n) <= height(m)) . height(m))

(b)

TEXT: (mu c : Chapter | (exists1 d : Chapter | length(d) > length(c)) . length(c))

(c)

TEXT: Assuming the existence of a suitable function, max: (mu n : N | n = max({ m : N | 8 * m < 100 . 8 * m }) . 100 - n)

=== Deductive proofs ===

** Solution 13 **

PROOF:
  (p and (p => q)) => (p and q) [=> intro from 1]
    [1] p and (p => q) [assumption]
    :: p and q [and intro]
      :: p [and elim from 1]
        [1] p and (p => q) [from above]
      :: q [=> elim]
        :: p => q [and elim from 1]
          [1] p and (p => q) [from above]
        :: p [and elim from 1]
          [1] p and (p => q) [from above]

** Solution 14 **

TEXT: In one direction:

PROOF:
  ((p and q) <=> p) => (p => q) [=> intro from 1]
    [1] (p and q) <=> p [assumption]
    :: p => q [=> intro from 2]
      [2] p [assumption]
      :: q [and elim from 3]
        :: p and q [=> elim from 1 and 2]
          [3] p and q [derived]

TEXT: and the other:

PROOF:
  (p => q) => ((p and q) <=> p) [=> intro from 1]
    [1] p => q [assumption]
    :: (p and q) <=> p [<=> intro]
      :: (p and q) => p [=> intro from 2]
        [2] p and q [assumption]
        :: p [and elim from 2]
      :: p => (p and q) [=> intro from 3]
        [3] p [assumption]
        :: p and q [and intro from 1 and 3]

TEXT: We can then combine these two proofs with <=> intro.

** Solution 15 **

PROOF:
  ((p => q) and not q) => not p [=> intro from 1]
    [1] (p => q) and not q [assumption]
    :: not p [false elim from 2]
      [2] p [assumption]
      :: false [false intro]
        :: q [=> elim]
          :: p => q [and elim from 1]
          :: p [from 2]
        :: not q [and elim from 1]

** Solution 16 **

TEXT: In one direction:

PROOF:
  (p and (q or r)) => ((p and q) or (p and r)) [=> intro from 1]
    [1] p and (q or r) [assumption]
    :: (p and q) or (p and r) [or elim from 2]
      [2] q or r [from 1]
      case q:
        :: p and q [and intro]
          :: p [and elim from 1]
          :: q [case assumption]
        :: (p and q) or (p and r) [or intro]
      case r:
        :: p and r [and intro]
          :: p [and elim from 1]
          :: r [case assumption]
        :: (p and q) or (p and r) [or intro]

TEXT: In the other:

PROOF:
  ((p and q) or (p and r)) => (p and (q or r)) [=> intro from 3]
    [3] (p and q) or (p and r) [assumption]
    :: p and (q or r) [or elim from 4]
      [4] case1 or case2 [from 3]
      case p and q:
        :: p [and elim]
        :: q or r [or intro]
        :: p and (q or r) [and intro]
      case p and r:
        :: p [and elim]
        :: q or r [or intro]
        :: p and (q or r) [and intro]

** Solution 17 **

TEXT: In one direction:

PROOF:
  (p or (q and r)) => ((p or q) and (p or r)) [=> intro from 3]
    [3] p or (q and r) [assumption]
    :: (p or q) and (p or r) [or elim and and intro]

TEXT: and the other:

PROOF:
  ((p or q) and (p or r)) => (p or (q and r)) [=> intro from 1]
    [1] (p or q) and (p or r) [assumption]
    :: p or (q and r) [or elim from 2 and 3]

** Solution 18 **

TEXT: In one direction:

PROOF:
  (p => q) => (not p or q) [=> intro from 1]
    [1] p => q [assumption]
    :: not p or q [or elim from excluded middle]

TEXT: and the other:

PROOF:
  (not p or q) => (p => q) [=> intro from 3]
    [3] not p or q [assumption]
    :: p => q [=> intro from 4]
      [4] p [assumption]
      :: q [or elim and false elim from 3]

=== Sets and types ===

** Solution 19 **

(a)

TEXT: 1 in {4, 3, 2, 1} is true.

(b)

TEXT: {1} in {1, 2, 3, 4} is undefined.

(c)

TEXT: {1} in {{1}, {2}, {3}, {4}} is true.

(d)

TEXT: The empty set in {1, 2, 3, 4} is undefined.

** Solution 20 **

(a)

{1} cross {2, 3}

TEXT: is the set {(1, 2), (1, 3)}

(b)

TEXT: The empty set cross {2, 3} is the empty set

(c)

(P emptyset) cross {1}

TEXT: is the set {(emptyset, 1)}

(d)

TEXT: {(1, 2)} cross {3, 4} is the set {((1, 2), 3), ((1, 2), 4)}

** Solution 21 **

TEXT: There are various ways of describing these sets via set comprehensions. Examples are given below.

(a)

{ z : Z | 0 <= z and z <= 100 }

(b)

{ z : Z | z = 10 }

(c)

{ z : Z | z mod 2 = 0 or z mod 3 = 0 or z mod 5 = 0 }

** Solution 22 **

(a)

{ n : N | n <= 4 . n^2 }

(b)

{ n : N | n <= 4 . (n, n^2) }

(c)

TEXT: { n : P {0, 1} } (set comprehension notation requires clarification)

(d)

TEXT: { n : P {0, 1} | true . (n, # n) } (alternative: map over powerset)

** Solution 23 **

(a)

EQUIV:
x in a intersect a
<=> x in a and x in a
<=> x in a

(b)

EQUIV:
x in a union a
<=> x in a or x in a
<=> x in a

** Solution 24 **

(a)

TEXT: The set of all pairs of integers is Z cross Z. To give it a name, we could write:

Pairs == Z cross Z

(b)

TEXT: The set of all integer pairs in which each element is strictly greater than zero could be defined by:

StrictlyPositivePairs == { m, n : Z | m > 0 and n > 0 . (m, n) }

(c)

TEXT: It is intuitive to use a singular noun for the name of a basic type; we define the set of all people by writing:

given Person

(d)

TEXT: The set of all couples could be defined by:

Couples == { s : P Person | # s = 2 }

** Solution 25 **

TEXT: (Requires generic set notation and Cartesian product)

** Solution 26 **

TEXT: (Requires generic parameters and relation type notation)

=== Relations ===

** Solution 27 **

(a)

TEXT: The power set of {(0,0), (0,1), (1,0), (1,1)} is:

TEXT: { emptyset, {(0, 0)}, {(0, 1)}, {(1, 0)}, {(1, 1)}, {(1, 0), (1, 1)}, {(0, 0), (0, 1)}, {(0, 1), (1, 1)}, {(0, 1), (1, 0)}, {(0, 0), (1, 1)}, {(0, 0), (1, 0)}, {(0, 0), (1, 0), (1, 1)}, {(0, 0), (0, 1), (1, 1)}, {(0, 0), (0, 1), (1, 0)}, {(0, 1), (1, 0), (1, 1)}, {(0, 0), (0, 1), (1, 0), (1, 1)} }

(b)

TEXT: { emptyset, {(0, 0)}, {(0, 1)}, {(0, 0), (0, 1)} }

(c)

TEXT: { emptyset }

(d)

TEXT: { emptyset }

** Solution 28 **

(a)

TEXT: dom R = {0, 1, 2}

(b)

TEXT: ran R = {1, 2, 3}

(c)

TEXT: {1, 2} <| R = {1 |-> 2, 1 |-> 3, 2 |-> 3}

** Solution 29 **

(a)

{2 |-> 4, 3 |-> 3, 3 |-> 4, 4 |-> 2}

(b)

{1 |-> 3, 2 |-> 2, 2 |-> 3, 3 |-> 1}

(c)

{1 |-> 1, 2 |-> 2, 2 |-> 3, 3 |-> 2, 3 |-> 3, 4 |-> 4}

(d)

{1 |-> 4, 2 |-> 2, 2 |-> 3, 3 |-> 2, 3 |-> 3, 4 |-> 1}

** Solution 30 **

(a)

parentOf == childOf~

TEXT: This is a good example of how there are many different ways of writing the same thing. An alternative abbreviation is:

parentOf == {x, y : Person | x |-> y in childOf . y |-> x}

TEXT: Or, via an axiomatic definition:

axdef
  parentOf : Person <-> Person
where
  parentOf = childOf~
end

(b)

TEXT: siblingOf == (childOf o9 parentOf) \ id

(c)

cousinOf == childOf o9 siblingOf o9 parentOf

(d)

ancestorOf == parentOf+

** Solution 31 **

TEXT: (Requires compound identifiers with operators - R+, R*)

(a)

R == {a, b : N | b = a or b = a}

(b)

S == {a, b : N | b = a or b = a}

(c)

TEXT: R+ == {a, b : N | b > a}

(d)

TEXT: R* == {a, b : N | b >= a}

** Solution 32 **

(a)

EQUIV:
x |-> y in A <| (B <| R)
<=> x in A and x |-> y in (B <| R)
<=> x in A and x in B and x |-> y in R
<=> x in A intersect B and x |-> y in R
<=> x |-> y in (A intersect B) <| R

(b)

EQUIV:
x |-> y in (R union S) |> C
<=> x |-> y in (R union S) and y in C
<=> (x |-> y in R or x |-> y in S) and y in C
<=> (x |-> y in R and y in C) or (x |-> y in S and y in C)
<=> x |-> y in R |> C or x |-> y in S |> C
<=> x |-> y in (R |> C) union (S |> C)

=== Functions ===

** Solution 33 **

TEXT: The set of 9 functions:

TEXT: { emptyset, {(0, 0)}, {(0, 1)}, {(1, 1)}, {(1, 0)}, {(0, 0), (1, 1)}, {(0, 1), (1, 1)}, {(1, 0), (0, 0)}, {(0, 1), (1, 0)} }

(a)

TEXT: The set of total functions:

TEXT: { {(0, 0), (1, 1)}, {(0, 1), (1, 1)}, {(1, 0), (0, 0)}, {(0, 1), (1, 0)} }

(b)

TEXT: The set of functions which are neither injective nor surjective:

TEXT: { {(0, 1), (1, 1)}, {(0, 0), (1, 0)} }

(c)

TEXT: The set of functions which are injective but not surjective:

TEXT: { emptyset, {(0, 0)}, {(0, 1)}, {(1, 0)}, {(1, 1)} }

(d)

TEXT: There are no functions (of this type) which are surjective but not injective.

(e)

TEXT: The set of bijective functions:

TEXT: { {(0, 0), (1, 1)}, {(0, 1), (1, 0)} }

** Solution 34 **

(a)

{1 |-> a, 2 |-> b, 3 |-> c, 4 |-> b}

(b)

{1 |-> c, 2 |-> b, 3 |-> c, 4 |-> d}

(c)

{1 |-> c, 2 |-> b, 3 |-> c, 4 |-> b}

(d)

{1 |-> c, 2 |-> b, 3 |-> c, 4 |-> b}

** Solution 35 **

TEXT: (Requires power set notation P and relational image)

(a)

TEXT: axdef
TEXT:   children : Person -> P Person
TEXT: where
TEXT:   children = {p : Person . p |-> parentOf(| {p} |)}
TEXT: end

(b)

TEXT: axdef
TEXT:   number_of_grandchildren : Person -> N
TEXT: where
TEXT:   number_of_grandchildren = {p : Person . p |-> # (parentOf o9 parentOf)(| {p} |)}
TEXT: end

** Solution 36 **

TEXT: (Requires power set, function types, and ran keyword)

TEXT: axdef
TEXT:   number_of_drivers : (Drivers <-> Cars) -> (Cars -> N)
TEXT: where
TEXT:   forall r : Drivers <-> Cars | number_of_drivers(r) = {c : ran r . c |-> #{d : Drivers | d |-> c in r}}
TEXT: end

=== Sequences ===

** Solution 37 **

** Solution 38 **

** Solution 39 **

=== Modelling ===

** Solution 40 **

** Solution 41 **

** Solution 42 **

** Solution 43 **

=== Free types and induction ===

** Solution 44 **

** Solution 45 **

** Solution 46 **

** Solution 47 **

=== Supplementary material: assignment practice ===

** Solution 48 **

** Solution 49 **

** Solution 50 **

** Solution 51 **

** Solution 52 **
