\documentclass[a4paper,10pt,fleqn]{article}
\usepackage[margin=1in]{geometry}
\usepackage{amssymb}
\usepackage{natbib}
\usepackage{zed-cm}
\usepackage{zed-maths}
\usepackage{zed-proof}
\begin{document}

\section*{Propositional logic}

\bigskip
\noindent
\textbf{Solution 1}

\medskip

\noindent
\hangindent=2em
(a) $false(as(true \Rightarrow false) \Leftrightarrow false)$

\medskip
\noindent
\hangindent=2em
(b) $true(as(false \Rightarrow false) \Leftrightarrow true)$

\medskip
\noindent
\hangindent=2em
(c) $true(as(false \Rightarrow true) \Leftrightarrow true)$

\medskip
\noindent
\hangindent=2em
(d) $true(as(false \Rightarrow false) \Leftrightarrow true)$

\bigskip

(Assuming that pigs can't fly . . . )

\bigskip

\medskip

\bigskip
\noindent
\textbf{Solution 2}

\medskip

(a)
\par
\vspace{11pt}
\begin{tabular}{c|c|c|c}
$p$ & $q$ & $p \land q$ & $\mathbf{( p \land q ) \Rightarrow p}$ \\
\hline
\textit{t} & \textit{t} & \textit{t} & \textbf{t} \\
\textit{t} & \textit{f} & \textit{f} & \textbf{t} \\
\textit{f} & \textit{t} & \textit{f} & \textbf{t} \\
\textit{f} & \textit{f} & \textit{f} & \textbf{t} \\
\end{tabular}

\medskip

(b)
\par
\vspace{11pt}
\begin{tabular}{c|c|c|c|c|c}
$p$ & $q$ & $p \land q$ & $\lnot p$ & $\lnot p \Rightarrow ( p \land q )$ & $\mathbf{( \lnot p \Rightarrow ( p \land q ) ) \Leftrightarrow p}$ \\
\hline
\textit{t} & \textit{t} & \textit{t} & \textit{f} & \textit{t} & \textbf{t} \\
\textit{t} & \textit{f} & \textit{f} & \textit{f} & \textit{t} & \textbf{t} \\
\textit{f} & \textit{t} & \textit{f} & \textit{t} & \textit{f} & \textbf{t} \\
\textit{f} & \textit{f} & \textit{f} & \textit{t} & \textit{f} & \textbf{t} \\
\end{tabular}

\medskip

(c)
\par
\vspace{11pt}
\begin{tabular}{c|c|c|c|c}
$p$ & $q$ & $p \Rightarrow q$ & $p \land ( p \Rightarrow q )$ & $\mathbf{( p \land ( p \Rightarrow q ) ) \Rightarrow q}$ \\
\hline
\textit{t} & \textit{t} & \textit{t} & \textit{t} & \textbf{t} \\
\textit{t} & \textit{f} & \textit{f} & \textit{f} & \textbf{t} \\
\textit{f} & \textit{t} & \textit{t} & \textit{f} & \textbf{t} \\
\textit{f} & \textit{f} & \textit{t} & \textit{f} & \textbf{t} \\
\end{tabular}

\medskip

\bigskip
\noindent
\textbf{Solution 3}

\medskip

(a)
\par
\vspace{11pt}
\[
\begin{array}{ll@{\hspace{2em}}l}
& p \Rightarrow \lnot p \\
&\Leftrightarrow \lnot p \lor \lnot p & [\mbox{$\Rightarrow$}] \\
&\Leftrightarrow \lnot p & [\mbox{idempotence}]
\end{array}
\]

\medskip

(b)
\par
\vspace{11pt}
\[
\begin{array}{ll@{\hspace{2em}}l}
& \lnot p \Rightarrow p \\
&\Leftrightarrow \lnot \lnot p \lor p & [\mbox{$\Rightarrow$}] \\
&\Leftrightarrow p \lor p & [\mbox{$\lnot$ $\lnot$}] \\
&\Leftrightarrow p & [\mbox{idempotence}]
\end{array}
\]

\medskip

(c)
\par
\vspace{11pt}
\[
\begin{array}{ll@{\hspace{2em}}l}
& p \Rightarrow (q \Rightarrow r) \\
&\Leftrightarrow \lnot p \lor (q \Rightarrow r) & [\mbox{$\Rightarrow$}] \\
&\Leftrightarrow \lnot p \lor \lnot q \lor r & [\mbox{$\Rightarrow$}] \\
&\Leftrightarrow \lnot p \lor \lnot q \lor r & [\mbox{associativity}] \\
&\Leftrightarrow \lnot (p \land q) \lor r & [\mbox{De Morgan}] \\
&\Leftrightarrow p \land q \Rightarrow r & [\mbox{$\Rightarrow$}]
\end{array}
\]

\medskip

(d)
\par
\vspace{11pt}
\[
\begin{array}{ll@{\hspace{2em}}l}
& q \Rightarrow (p \Rightarrow r) \\
&\Leftrightarrow \lnot q \lor (p \Rightarrow r) & [\mbox{$\Rightarrow$}] \\
&\Leftrightarrow \lnot q \lor \lnot p \lor r & [\mbox{$\Rightarrow$}] \\
&\Leftrightarrow \lnot p \lor \lnot q \lor r & [\mbox{associativity $\land$ commutativity}] \\
&\Leftrightarrow \lnot p \lor (q \Rightarrow r) & [\mbox{$\Rightarrow$}] \\
&\Leftrightarrow p \Rightarrow (q \Rightarrow r) & [\mbox{$\Rightarrow$}]
\end{array}
\]

\medskip

(e)
\par
\vspace{11pt}
\[
\begin{array}{ll@{\hspace{2em}}l}
& p \land q \Leftrightarrow p \\
&\Leftrightarrow (p \land q \Rightarrow p) \land (p \Rightarrow p \land q) & [\mbox{$\Leftrightarrow$}] \\
&\Leftrightarrow (\lnot (p \land q) \lor p) \land (\lnot p \lor p \land q) & [\mbox{$\Rightarrow$}] \\
&\Leftrightarrow (\lnot p \lor \lnot q \lor p) \land (\lnot p \lor p \land q) & [\mbox{De Morgan}] \\
&\Leftrightarrow (\lnot q \lor \lnot p \lor p) \land (\lnot p \lor p \land q) & [\mbox{associativity $\land$ comm .}] \\
&\Leftrightarrow (\lnot q \lor true) \land (\lnot p \lor p \land q) & [\mbox{excluded middle}] \\
&\Leftrightarrow true \land (\lnot p \lor p \land q) & [\mbox{$\lor$ $\land$ true}] \\
&\Leftrightarrow \lnot p \lor p \land q & [\mbox{$\land$ $\land$ true}] \\
&\Leftrightarrow (\lnot p \lor p) \land (\lnot p \lor q) & [\mbox{distribution}] \\
&\Leftrightarrow true \land (\lnot p \lor q) & [\mbox{excluded middle}] \\
&\Leftrightarrow \lnot p \lor q & [\mbox{$\land$ $\land$ true}] \\
&\Leftrightarrow p \Rightarrow q & [\mbox{$\Rightarrow$}]
\end{array}
\]

\medskip

(f)
\par
\vspace{11pt}
\[
\begin{array}{ll@{\hspace{2em}}l}
& p \lor q \Leftrightarrow p \\
&\Leftrightarrow (p \lor q \Rightarrow p) \land (p \Rightarrow p \lor q) & [\mbox{$\Leftrightarrow$}] \\
&\Leftrightarrow (\lnot (p \lor q) \lor p) \land (\lnot p \lor p \lor q) & [\mbox{$\Rightarrow$}] \\
&\Leftrightarrow (\lnot p \land \lnot q \lor p) \land (\lnot p \lor p \lor q) & [\mbox{De Morgan}] \\
&\Leftrightarrow (\lnot p \lor p) \land (\lnot q \lor p) \land (\lnot p \lor p \lor q) & [\mbox{distribution}] \\
&\Leftrightarrow true \land (\lnot q \lor p) \land (\lnot p \lor p \lor q) & [\mbox{excluded middle}] \\
&\Leftrightarrow (\lnot q \lor p) \land (\lnot p \lor p \lor q) & [\mbox{$\land$ $\land$ true}] \\
&\Leftrightarrow (\lnot q \lor p) \land (\lnot p \lor p \lor q) & [\mbox{associativity}] \\
&\Leftrightarrow (\lnot q \lor p) \land (true \lor q) & [\mbox{excluded middle}] \\
&\Leftrightarrow (\lnot q \lor p) \land true & [\mbox{$\lor$ $\land$ true}] \\
&\Leftrightarrow \lnot q \lor p & [\mbox{$\land$ $\land$ true}] \\
&\Leftrightarrow q \Rightarrow p & [\mbox{$\Rightarrow$}]
\end{array}
\]

\medskip

\bigskip
\noindent
\textbf{Solution 4}

\medskip

\noindent
\hangindent=2em
(a) $p \lor q$ $\Leftrightarrow$ $(\lnot p \lor \lnot q) \land q$ is $\lnot a$ tautology. You might illustrate this via a truth table or via a chain of equivalences, showing that the proposition is not equivalent to true. Alternatively, you might try and find a combination of values for which the proposition is false. (In this case, the proposition is false when p and q are both true.)

\bigskip


\medskip
\noindent
\hangindent=2em
(b) $p \lor q$ $\Leftrightarrow$ $\lnot p \land \lnot q \lor q$ is $\lnot a$ tautology. In this case, the proposition is false when p is true and q is false.

\bigskip


\medskip
\bigskip
\noindent
\textbf{Solution 5}

\medskip

\noindent
\hangindent=2em
(a) $\exists d \colon Dog \bullet gentle(d) \land \mathit{well\_trained}(d)$

\medskip
\noindent
\hangindent=2em
(b) $\forall d \colon Dog \bullet neat(d) \land \mathit{well\_trained}(d) \Rightarrow attractive(d)$

\medskip
\noindent
\hangindent=2em
(c) $\exists d \colon Dog \bullet gentle(d) \Rightarrow \forall t \colon Trainer \bullet groomed(d, t)$

\medskip
\bigskip
\noindent
\textbf{Solution 6}

\medskip

\noindent
\hangindent=2em
(a) This is a true proposition: whatever the value of x, the expression $x^2$ - x + 1 denotes a natural number. If we choose y to be this natural number, we will find that p is true.

\bigskip


\medskip
\noindent
\hangindent=2em
(b) This is a false proposition. We cannot choose a large enough value for y such that p will hold for any value of x.

\bigskip


\medskip
\noindent
\hangindent=2em
(c) This is a false proposition. It is an implication whose antecedent part is true and whose consequent part is false.

\bigskip


\medskip
\noindent
\hangindent=2em
(d) This is a true proposition. It is an implication whose antecedent part is false and whose consequent part is true.

\bigskip


\medskip
\bigskip
\noindent
\textbf{Solution 7}

\medskip

\noindent
\hangindent=2em
(a) We must define a predicate p that is false for at least one value of x, and is true for at least one other value. A suitable solution would be $p \Leftrightarrow x > 1$.

\bigskip


\medskip
\noindent
\hangindent=2em
(b) With the above choice of p, we require only that q is sometimes false when p is true (for else the universal quantification would hold). A suitable solution would be $q \Leftrightarrow x > 3$.

\bigskip


\medskip
\bigskip
\noindent
\textbf{Solution 8}

\medskip

\noindent
\hangindent=2em
(a) $\forall x \colon \mathbb{N} \bullet x \geq z$

\medskip
\noindent
\hangindent=2em
(b) $\forall z \colon \mathbb{N} \bullet z \geq x + y$

\medskip
\noindent
\hangindent=2em
(c) $x + 3 > 0 \land \forall z \colon \mathbb{N} \bullet z \geq x + 3$

\medskip
\section*{Equality}

\bigskip
\noindent
\textbf{Solution 9}

\medskip

(a)
\par
\vspace{11pt}
\[
\begin{array}{ll@{\hspace{2em}}l}
& \exists y \colon \mathbb{N} \bullet y \in \{0, 1\} \land y \neq 1 \land x \neq y \\
&\Leftrightarrow \exists y \colon \mathbb{N} \bullet y = 0 \land x \neq y & [\mbox{arithmetic}] \\
&\Leftrightarrow 0 \in \mathbb{N} \land x \neq 0 & [\mbox{one - point rule}] \\
&\Leftrightarrow x \neq 0
\end{array}
\]

\medskip

(b)
\par
\vspace{11pt}
\[
\begin{array}{ll@{\hspace{2em}}l}
& \exists x, y \colon \mathbb{N} \bullet x + y = 4 \land x < y \\
&\Leftrightarrow \exists x, y \colon \mathbb{N} \bullet y = 4 - x \land x < y \\
&\Leftrightarrow \exists x \colon \mathbb{N} \bullet 4 - x \in \mathbb{N} \land x < 4 - x \\
&\Leftrightarrow true
\end{array}
\]

\bigskip

The final equivalence holds because $0 \in N$, $4 - 0 \in N$, and 0 $<$ 4.

\bigskip

\medskip

(c)
\par
\vspace{11pt}
\[
\begin{array}{ll@{\hspace{2em}}l}
& \forall x \colon \mathbb{N} \bullet \exists y \colon \mathbb{N} \bullet x = y + 1 \\
&\Leftrightarrow \forall x \colon \mathbb{N} \bullet \exists y \colon \mathbb{N} \bullet y = x - 1 \\
&\Leftrightarrow \forall x \colon \mathbb{N} \bullet x - 1 \in \mathbb{N}
\end{array}
\]

\bigskip

The final equivalence holds because $0 \in N$ and yet $0 - 1 \notin N$. We may assume that the subtraction operator is defined for all integers.

\bigskip

\medskip

(d)
\par
\vspace{11pt}
\[
\begin{array}{ll@{\hspace{2em}}l}
& \exists x \colon \mathbb{N} \bullet x = 1 \land x > y \lor x = 2 \land x > z \\
&\Leftrightarrow \exists x \colon \mathbb{N} \bullet x = 1 \land x > y \lor \exists x \colon \mathbb{N} \bullet x = 2 \land x > z \\
&\Leftrightarrow 1 \in \mathbb{N} \land 1 > y \lor \exists x \colon \mathbb{N} \bullet x = 2 \land x > z \\
&\Leftrightarrow 1 \in \mathbb{N} \land 1 > y \lor 2 \in \mathbb{N} \land 2 > z \\
&\Leftrightarrow 1 > y \lor 2 > z
\end{array}
\]

\medskip

\bigskip
\noindent
\textbf{Solution 10}

\medskip

\bigskip

As discussed, the quantifier $\exists_1$ can help give rise to a 'test' or 'precondition' to ensure that an application of mu will work.

\bigskip

\bigskip

So, as a simple example, as the proposition

\bigskip

\noindent
$\exists_1 n \colon \mathbb{N} \bullet \forall m \colon \mathbb{N} \bullet n \leq m$


\bigskip

is equivalent to true, we can be certain that the statement

\bigskip

\noindent
$\mu n \colon \mathbb{N} \bullet \forall m \colon \mathbb{N} \bullet n \leq m$


\bigskip

will return a result (which happens to be 0).

\bigskip

\bigskip
\noindent
\textbf{Solution 11}

\medskip

\noindent
\hangindent=2em
(a) $\mu a \colon \mathbb{N} \bullet a = a = 0$

\bigskip

is a provable statement, since 0 is the only natural number with the specified property.

\bigskip

\medskip

\noindent
\hangindent=2em
(b) $\mu b \colon \mathbb{N} \bullet b = b = 1$

\bigskip

is not provable. The specified property is true of both 0 and 1, and thus the value of the mu-expression is undefined.

\bigskip

\medskip

\noindent
\hangindent=2em
(c) $\mu c \colon \mathbb{N} \bullet c > c = \mu c \colon \mathbb{N} \bullet c > c$

\bigskip

is a provable statement. Neither expression is properly defined, but we may conclude that they are equal; there is little else that we can prove about them.

\bigskip

\medskip

\noindent
\hangindent=2em
(d) $\mu d \colon \mathbb{N} \bullet d = d = 1$

\bigskip

is $\lnot a$ provable statement. We cannot confirm that 1 is the only natural number with the specified property; we do not know what value is taken by undefined operations.

\bigskip

\medskip

\bigskip
\noindent
\textbf{Solution 12}

\medskip

\noindent
\hangindent=2em
(a) $\mu m \colon Mountain \bullet \forall n \colon Mountain \bullet height(n) \leq height(m).height(m)$

\medskip
\noindent
\hangindent=2em
(b) $\mu c \colon Chapter \bullet \exists_1 d \colon Chapter \bullet length(d) > length(c).length(c)$

\medskip
\noindent
\hangindent=2em
(c) Assuming the existence of a suitable function, max: ($\mu n \colon \mathbb{N} \bullet n = max$($\{ m \colon \mathbb{N} \mid 8 * m < 100.8 * m \}$) . 100 - n)

\bigskip


\medskip
\section*{Deductive proofs}

\bigskip
\noindent
\textbf{Solution 13}

\medskip

\noindent
$\displaystyle
\infer[\Rightarrow\textrm{-intro}^{[1]}]{p \land (p \Rightarrow q) \Rightarrow p \land q}{
  \ulcorner p \land (p \Rightarrow q) \urcorner^{[1]}
&
\infer[\land \mathrm{intro}]{p \land q}{
  \infer[\land\textrm{-elim}^{[1]}]{p}{
  \infer[\mathrm{from} above]{p \land (p \Rightarrow q)}{}
}
&
\infer[\Rightarrow \mathrm{elim}]{q}{
  \infer[\land\textrm{-elim}^{[1]}]{p \Rightarrow q}{
  \infer[\mathrm{from} above]{p \land (p \Rightarrow q)}{}
}
&
\infer[\land\textrm{-elim}^{[1]}]{p}{
  \infer[\mathrm{from} above]{p \land (p \Rightarrow q)}{}
}
}
}
}
$

\bigskip
\noindent
\textbf{Solution 14}

\medskip

\bigskip

In one direction:

\bigskip

\noindent
$\displaystyle
\infer[\Rightarrow\textrm{-intro}^{[1]}]{(p \land q \Leftrightarrow p) \Rightarrow (p \Rightarrow q)}{
  \ulcorner p \land q \Leftrightarrow p \urcorner^{[1]}
&
\infer[\Rightarrow\textrm{-intro}^{[2]}]{p \Rightarrow q}{
  \ulcorner p \urcorner^{[2]}
&
\infer[\land\textrm{-elim}^{[3]}]{q}{
  \infer[\Rightarrow \mathrm{elim} \mathrm{from} 1 \land 2]{p \land q}{
  \infer[derived]{p \land q}{}
}
}
}
}
$

\bigskip

and the other:

\bigskip

\noindent
$\displaystyle
\infer[\Rightarrow\textrm{-intro}^{[1]}]{(p \Rightarrow q) \Rightarrow (p \land q \Leftrightarrow p)}{
  \ulcorner p \Rightarrow q \urcorner^{[1]}
&
\infer[\Leftrightarrow \mathrm{intro}]{p \land q \Leftrightarrow p}{
  \infer[\Rightarrow\textrm{-intro}^{[2]}]{p \land q \Rightarrow p}{
  \ulcorner p \land q \urcorner^{[2]}
&
\infer[\land\textrm{-elim}^{[2]}]{p}{}
}
&
\infer[\Rightarrow\textrm{-intro}^{[3]}]{p \Rightarrow p \land q}{
  \ulcorner p \urcorner^{[3]}
&
\infer[\land \mathrm{intro} \mathrm{from} 1 \land 3]{p \land q}{}
}
}
}
$

\bigskip

We can then combine these two proofs $with \Leftrightarrow intro$.

\bigskip

\bigskip
\noindent
\textbf{Solution 15}

\medskip

\noindent
$\displaystyle
\infer[\Rightarrow\textrm{-intro}^{[1]}]{(p \Rightarrow q) \land \lnot q \Rightarrow \lnot p}{
  \ulcorner (p \Rightarrow q) \land \lnot q \urcorner^{[1]}
&
\infer[false\textrm{-elim}^{[2]}]{\lnot p}{
  \ulcorner p \urcorner^{[2]}
&
\infer[\mathrm{false} \mathrm{intro}]{false}{
  \infer[\Rightarrow \mathrm{elim}]{q}{
  \infer[\land\textrm{-elim}^{[1]}]{p \Rightarrow q}{}
&
\ulcorner p \urcorner^{[2]}
}
&
\infer[\land\textrm{-elim}^{[1]}]{\lnot q}{}
}
}
}
$

\bigskip
\noindent
\textbf{Solution 16}

\medskip

\bigskip

In one direction:

\bigskip

\noindent
$\displaystyle
\infer[\Rightarrow\textrm{-intro}^{[1]}]{p \land (q \lor r) \Rightarrow p \land q \lor p \land r}{
  \ulcorner p \land (q \lor r) \urcorner^{[1]}
&
\infer[\lor\textrm{-elim}^{[2]}]{p \land q \lor p \land r}{
  \ulcorner q \lor r \urcorner^{[1]}
&
\raiseproof{10ex}{\infer[\lor \mathrm{intro}]{p \land q \lor p \land r}{\infer[\land \mathrm{intro}]{p \land q}{
  \infer[\land\textrm{-elim}^{[1]}]{p}{}
&
\infer[\mathrm{case} \mathrm{assumption}]{q}{}
}}}
&
\hskip 6em \raiseproof{26ex}{\infer[\lor \mathrm{intro}]{p \land q \lor p \land r}{\infer[\land \mathrm{intro}]{p \land r}{
  \infer[\land\textrm{-elim}^{[1]}]{p}{}
&
\infer[\mathrm{case} \mathrm{assumption}]{r}{}
}}}
}
}
$

\bigskip

In the other:

\bigskip

\noindent
$\displaystyle
\infer[\Rightarrow\textrm{-intro}^{[3]}]{p \land q \lor p \land r \Rightarrow p \land (q \lor r)}{
  \ulcorner p \land q \lor p \land r \urcorner^{[3]}
&
\infer[\lor\textrm{-elim}^{[4]}]{p \land (q \lor r)}{
  \ulcorner case1 \lor case2 \urcorner^{[3]}
&
\raiseproof{8ex}{\infer[\land \mathrm{intro}]{p \land (q \lor r)}{\infer[\land \mathrm{elim}]{p}{} & \infer[\lor \mathrm{intro}]{q \lor r}{}}}
&
\hskip 6em \raiseproof{22ex}{\infer[\land \mathrm{intro}]{p \land (q \lor r)}{\infer[\land \mathrm{elim}]{p}{} & \infer[\lor \mathrm{intro}]{q \lor r}{}}}
}
}
$

\bigskip
\noindent
\textbf{Solution 17}

\medskip

\bigskip

In one direction:

\bigskip

\noindent
$\displaystyle
\infer[\Rightarrow\textrm{-intro}^{[3]}]{p \lor q \land r \Rightarrow (p \lor q) \land (p \lor r)}{
  \ulcorner p \lor q \land r \urcorner^{[3]}
&
\infer[\lor \mathrm{elim} \land \land \mathrm{intro}]{(p \lor q) \land (p \lor r)}{}
}
$

\bigskip

and the other:

\bigskip

\noindent
$\displaystyle
\infer[\Rightarrow\textrm{-intro}^{[1]}]{(p \lor q) \land (p \lor r) \Rightarrow p \lor q \land r}{
  \ulcorner (p \lor q) \land (p \lor r) \urcorner^{[1]}
&
\infer[\lor \mathrm{elim} \mathrm{from} 2 \land 3]{p \lor q \land r}{}
}
$

\bigskip
\noindent
\textbf{Solution 18}

\medskip

\bigskip

In one direction:

\bigskip

\noindent
$\displaystyle
\infer[\Rightarrow\textrm{-intro}^{[1]}]{(p \Rightarrow q) \Rightarrow \lnot p \lor q}{
  \ulcorner p \Rightarrow q \urcorner^{[1]}
&
\infer[\lor \mathrm{elim} \mathrm{from} \mathrm{excluded} \mathrm{middle}]{\lnot p \lor q}{}
}
$

\bigskip

and the other:

\bigskip

\noindent
$\displaystyle
\infer[\Rightarrow\textrm{-intro}^{[3]}]{\lnot p \lor q \Rightarrow (p \Rightarrow q)}{
  \ulcorner \lnot p \lor q \urcorner^{[3]}
&
\infer[\Rightarrow\textrm{-intro}^{[4]}]{p \Rightarrow q}{
  \ulcorner p \urcorner^{[4]}
&
\infer[\lor elim \land false\textrm{-elim}^{[3]}]{q}{}
}
}
$

\section*{Sets and types}

\bigskip
\noindent
\textbf{Solution 19}

\medskip

\noindent
\hangindent=2em
(a) 1 in $\{4, 3, 2, 1\}$ is true.

\bigskip


\medskip
\noindent
\hangindent=2em
(b) $\{1\}$ in $\{1, 2, 3, 4\}$ is undefined.

\bigskip


\medskip
\noindent
\hangindent=2em
(c) $\{1\}$ in $\{\{1\}, \{2\}, \{3\}, \{4\}\}$ is true.

\bigskip


\medskip
\noindent
\hangindent=2em
(d) The empty set in $\{1, 2, 3, 4\}$ is undefined.

\bigskip


\medskip
\bigskip
\noindent
\textbf{Solution 20}

\medskip

\noindent
\hangindent=2em
(a) $\{1\} \cross \{2, 3\}$

\bigskip

is the set $\{(1, 2), (1, 3)\}$

\bigskip

\medskip

\noindent
\hangindent=2em
(b) The empty set cross $\{2, 3\}$ is the empty set

\bigskip


\medskip
\noindent
\hangindent=2em
(c) $\power \emptyset \cross \{1\}$

\bigskip

is the set $\{(\emptyset, 1)\}$

\bigskip

\medskip

\noindent
\hangindent=2em
(d) $\{(1, 2)\}$ cross $\{3, 4\}$ is the set $\{((1, 2), 3), ((1, 2), 4)\}$

\bigskip


\medskip
\bigskip
\noindent
\textbf{Solution 21}

\medskip

\bigskip

There are various ways of describing these sets via set comprehensions. Examples are given below.

\bigskip

\noindent
\hangindent=2em
(a) $\{ z \colon \mathbb{Z} \mid 0 \leq z \land z \leq 100 \}$

\medskip
\noindent
\hangindent=2em
(b) $\{ z \colon \mathbb{Z} \mid z = 10 \}$

\medskip
\noindent
\hangindent=2em
(c) $\{ z \colon \mathbb{Z} \mid z \mod 2 = 0 \lor z \mod 3 = 0 \lor z \mod 5 = 0 \}$

\medskip
\bigskip
\noindent
\textbf{Solution 22}

\medskip

\noindent
\hangindent=2em
(a) $\{ n \colon \mathbb{N} \mid n \leq 4 \bullet n^2 \}$

\medskip
\noindent
\hangindent=2em
(b) $\{ n \colon \mathbb{N} \mid n \leq 4 \bullet (n, n^2) \}$

\medskip
\noindent
\hangindent=2em
(c) $\{ n \colon \power \{0, 1\} \}$

\medskip
\noindent
\hangindent=2em
(d) $\{ n \colon \power \{0, 1\} \mid true \bullet (n, \# n) \}$

\medskip
\bigskip
\noindent
\textbf{Solution 23}

\medskip

(a)
\par
\vspace{11pt}
\[
\begin{array}{ll@{\hspace{2em}}l}
& x \in a \cap a \\
&\Leftrightarrow x \in a \land x \in a \\
&\Leftrightarrow x \in a
\end{array}
\]

\medskip

(b)
\par
\vspace{11pt}
\[
\begin{array}{ll@{\hspace{2em}}l}
& x \in a \cup a \\
&\Leftrightarrow x \in a \lor x \in a \\
&\Leftrightarrow x \in a
\end{array}
\]

\medskip

\bigskip
\noindent
\textbf{Solution 24}

\medskip

(a)
\par
\vspace{11pt}
\bigskip

The set of all pairs of integers is Z cross Z. To give it a name, we could write:

\bigskip

\begin{zed}
Pairs == \mathbb{Z} \cross \mathbb{Z}
\end{zed}

\medskip

(b)
\par
\vspace{11pt}
\bigskip

The set of all integer pairs in which each element is strictly greater than zero could be defined by:

\bigskip

\begin{zed}
StrictlyPositivePairs == \{ m, n \colon \mathbb{Z} \mid m > 0 \land n > 0 \bullet (m, n) \}
\end{zed}

\medskip

(c)
\par
\vspace{11pt}
\bigskip

It is intuitive to use a singular noun for the name of a basic type; we define the set of all people by writing:

\bigskip

\begin{zed}[Person]\end{zed}

\medskip

(d)
\par
\vspace{11pt}
\bigskip

The set of all couples could be defined by:

\bigskip

\begin{zed}
Couples == \{ s \colon \power Person \mid \# s = 2 \}
\end{zed}

\medskip

\bigskip
\noindent
\textbf{Solution 25}

\medskip

\noindent
\hangindent=2em
(a) $\emptyset[\mathbb{N}] \in \emptyset[\power \mathbb{N}]$

\medskip
\noindent
\hangindent=2em
(b) $\emptyset[\mathbb{N} \cross \mathbb{N}] \subseteq \emptyset[\mathbb{N}] \cross \emptyset[\mathbb{N}]$

\medskip
\noindent
\hangindent=2em
(c) $\emptyset[\mathbb{N}] \cross \{\emptyset[\mathbb{N}]\} \subseteq \emptyset[\mathbb{N} \cross \power \mathbb{N}]$

\medskip
\bigskip
\noindent
\textbf{Solution 26}

\medskip

\bigskip

We may define notin using our built-in operator (notin is already implemented as a binary operator mapping to \notin)

\bigskip

\section*{Relations}

\bigskip
\noindent
\textbf{Solution 27}

\medskip

(a)
\par
\vspace{11pt}
\bigskip

The power set of $\{(0, 0), (0, 1), (1, 0), (1, 1)\}$ is:

\bigskip

\noindent
$\{\emptyset, \{(0, 0)\}, \{(0, 1)\}, \{(1, 0)\}, \{(1, 1)\}, \{(1, 0), (1, 1)\}, \{(0, 0), (0, 1)\}, \{(0, 1), (1, 1)\}, \{(0, 1), (1, 0)\}, \{(0, 0), (1, 1)\}, \{(0, 0), (1, 0)\}, \{(0, 0), (1, 0), (1, 1)\}, \{(0, 0), (0, 1), (1, 1)\}, \{(0, 0), (0, 1), (1, 0)\}, \{(0, 1), (1, 0), (1, 1)\}, \{(0, 0), (0, 1), (1, 0), (1, 1)\}\}$


\medskip

\noindent
\hangindent=2em
(b) $\{\emptyset, \{(0, 0)\}, \{(0, 1)\}, \{(0, 0), (0, 1)\}\}$

\medskip
\noindent
\hangindent=2em
(c) $\{\emptyset\}$

\medskip
\noindent
\hangindent=2em
(d) $\{\emptyset\}$

\medskip
\bigskip
\noindent
\textbf{Solution 28}

\medskip

\noindent
\hangindent=2em
(a) $\dom R = \{0, 1, 2\}$

\medskip
\noindent
\hangindent=2em
(b) $\ran R = \{1, 2, 3\}$

\medskip
\noindent
\hangindent=2em
(c) $\{1, 2\} \dres R = \{1 \mapsto 2, 1 \mapsto 3, 2 \mapsto 3\}$

\medskip
\bigskip
\noindent
\textbf{Solution 29}

\medskip

\noindent
\hangindent=2em
(a) $\{2 \mapsto 4, 3 \mapsto 3, 3 \mapsto 4, 4 \mapsto 2\}$

\medskip
\noindent
\hangindent=2em
(b) $\{1 \mapsto 3, 2 \mapsto 2, 2 \mapsto 3, 3 \mapsto 1\}$

\medskip
\noindent
\hangindent=2em
(c) $\{1 \mapsto 1, 2 \mapsto 2, 2 \mapsto 3, 3 \mapsto 2, 3 \mapsto 3, 4 \mapsto 4\}$

\medskip
\noindent
\hangindent=2em
(d) $\{1 \mapsto 4, 2 \mapsto 2, 2 \mapsto 3, 3 \mapsto 2, 3 \mapsto 3, 4 \mapsto 1\}$

\medskip
\bigskip
\noindent
\textbf{Solution 30}

\medskip

\begin{axdef}
childOf : Person \rel Person
\end{axdef}

(a)
\par
\vspace{11pt}
\begin{zed}
parentOf == childOf^{-1}
\end{zed}

\bigskip

This is a good example of how there are many different ways of writing the same thing. An alternative abbreviation would $be : parentOf $== $\{ x, y \colon Person \mid x \mapsto y \in childOf \bullet y \mapsto x \}$. Or via an axiomatic definition with $parentOf : Person <\fun Person and where clause parentOf $= childOf~.

\bigskip

\medskip

(b)
\par
\vspace{11pt}
\begin{zed}
siblingOf == (childOf \circ parentOf) \setminus \id[Person]
\end{zed}

\medskip

(c)
\par
\vspace{11pt}
\begin{zed}
cousinOf == childOf \circ siblingOf \circ parentOf
\end{zed}

\medskip

(d)
\par
\vspace{11pt}
\begin{zed}
ancestorOf == parentOf^{+}
\end{zed}

\medskip

\bigskip
\noindent
\textbf{Solution 31}

\medskip

\bigskip

(Requires compound identifiers with operators - R+, R*)

\bigskip

(a)
\par
\vspace{11pt}
\begin{zed}
R == \{ a, b \colon \mathbb{N} \mid b = a \lor b = a \}
\end{zed}

\medskip

(b)
\par
\vspace{11pt}
\begin{zed}
S == \{ a, b \colon \mathbb{N} \mid b = a \lor b = a \}
\end{zed}

\medskip

\noindent
\hangindent=2em
(c) R+ == $\{ a, b \colon \mathbb{N} \mid b > a \}$

\bigskip


\medskip
\noindent
\hangindent=2em
(d) R* == $\{ a, b \colon \mathbb{N} \mid b \geq a \}$

\bigskip


\medskip
\bigskip
\noindent
\textbf{Solution 32}

\medskip

(a)
\par
\vspace{11pt}
\[
\begin{array}{ll@{\hspace{2em}}l}
& x \mapsto y \in A \dres B \dres R \\
&\Leftrightarrow x \in A \land x \mapsto y \in (B \dres R) \\
&\Leftrightarrow x \in A \land x \in B \land x \mapsto y \in R \\
&\Leftrightarrow x \in A \cap B \land x \mapsto y \in R \\
&\Leftrightarrow x \mapsto y \in A \cap B \dres R
\end{array}
\]

\medskip

(b)
\par
\vspace{11pt}
\[
\begin{array}{ll@{\hspace{2em}}l}
& x \mapsto y \in R \cup S \rres C \\
&\Leftrightarrow x \mapsto y \in R \cup S \land y \in C \\
&\Leftrightarrow (x \mapsto y \in R \lor x \mapsto y \in S) \land y \in C \\
&\Leftrightarrow x \mapsto y \in R \land y \in C \lor x \mapsto y \in S \land y \in C \\
&\Leftrightarrow x \mapsto y \in R \rres C \lor x \mapsto y \in S \rres C \\
&\Leftrightarrow x \mapsto y \in (R \rres C) \cup (S \rres C)
\end{array}
\]

\medskip

\section*{Functions}

\bigskip
\noindent
\textbf{Solution 33}

\medskip

\bigskip

The set of 9 functions:

\bigskip

\noindent
$\{\emptyset, \{(0, 0)\}, \{(0, 1)\}, \{(1, 1)\}, \{(1, 0)\}, \{(0, 0), (1, 1)\}, \{(0, 1), (1, 1)\}, \{(1, 0), (0, 0)\}, \{(0, 1), (1, 0)\}\}$


(a)
\par
\vspace{11pt}
\bigskip

The set of total functions:

\bigskip

\noindent
$\{\{(0, 0), (1, 1)\}, \{(0, 1), (1, 1)\}, \{(1, 0), (0, 0)\}, \{(0, 1), (1, 0)\}\}$


\medskip

(b)
\par
\vspace{11pt}
\bigskip

The set of functions which are neither injective nor surjective:

\bigskip

\noindent
$\{\{(0, 1), (1, 1)\}, \{(0, 0), (1, 0)\}\}$


\medskip

(c)
\par
\vspace{11pt}
\bigskip

The set of functions which are injective but not surjective:

\bigskip

\noindent
$\{\emptyset, \{(0, 0)\}, \{(0, 1)\}, \{(1, 0)\}, \{(1, 1)\}\}$


\medskip

\noindent
\hangindent=2em
(d) There are no functions (of this type) which are surjective but not injective.

\bigskip


\medskip
(e)
\par
\vspace{11pt}
\bigskip

The set of bijective functions:

\bigskip

\noindent
$\{\{(0, 0), (1, 1)\}, \{(0, 1), (1, 0)\}\}$


\medskip

\bigskip
\noindent
\textbf{Solution 34}

\medskip

\noindent
\hangindent=2em
(a) $\{1 \mapsto a, 2 \mapsto b, 3 \mapsto c, 4 \mapsto b\}$

\medskip
\noindent
\hangindent=2em
(b) $\{1 \mapsto c, 2 \mapsto b, 3 \mapsto c, 4 \mapsto d\}$

\medskip
\noindent
\hangindent=2em
(c) $\{1 \mapsto c, 2 \mapsto b, 3 \mapsto c, 4 \mapsto b\}$

\medskip
\noindent
\hangindent=2em
(d) $\{1 \mapsto c, 2 \mapsto b, 3 \mapsto c, 4 \mapsto b\}$

\medskip
\bigskip
\noindent
\textbf{Solution 35}

\medskip

(a)
\par
\vspace{11pt}
\begin{axdef}
children : Person \fun \power Person
\where
children = \{ p \colon Person \bullet p \mapsto (parentOf \limg \{p\} \rimg) \}
\end{axdef}

\medskip

(b)
\par
\vspace{11pt}
\begin{axdef}
\mathit{number\_of\_grandchildren} : Person \fun \mathbb{N}
\where
\mathit{number\_of\_grandchildren} = \{ p \colon Person \bullet p \mapsto \# (parentOf \circ parentOf \limg \{p\} \rimg) \}
\end{axdef}

\medskip

\bigskip
\noindent
\textbf{Solution 36}

\medskip

\bigskip

(Note: This solution demonstrates relation types in quantifier domains)

\bigskip

\begin{axdef}
\mathit{number\_of\_drivers} : Drivers \rel Cars \fun (Cars \fun \mathbb{N})
\where
\mathit{number\_of\_drivers} = \lambda r : Drivers \rel Cars \bullet \{ c \colon \ran r \bullet c \mapsto \# \{ d \colon Drivers \mid d \mapsto c \in r \} \}
\end{axdef}

\section*{Sequences}

\bigskip
\noindent
\textbf{Solution 37}

\medskip

\noindent
\hangindent=2em
(a) $\langle a \rangle$

\medskip
\noindent
\hangindent=2em
(b) $\{1 \mapsto a, 2 \mapsto b, 2 \mapsto a, 3 \mapsto c, 3 \mapsto b, 4 \mapsto d\}$

\medskip
\noindent
\hangindent=2em
(c) $\{2 \mapsto b, 3 \mapsto c, 4 \mapsto d\}$

\medskip
\noindent
\hangindent=2em
(d) $\{1, 2, 3, 4\}$

\medskip
\noindent
\hangindent=2em
(e) $\{a, b\}$

\medskip
\noindent
\hangindent=2em
(f) $\{a \mapsto 1, b \mapsto 2, c \mapsto 3, d \mapsto 4\}$

\medskip
\noindent
\hangindent=2em
(g) $\langle a, b \rangle$

\medskip
\noindent
\hangindent=2em
(h) $\{3 \mapsto b\}$

\medskip
\noindent
\hangindent=2em
(i) $\{a\}$

\medskip
\noindent
\hangindent=2em
(j) $c$

\medskip
\bigskip
\noindent
\textbf{Solution 38}

\medskip

(a)
\par
\vspace{11pt}
\begin{axdef}
f : Place \fun \power Place
\where
\forall p \colon Place \bullet f(p) = \{ q \colon Place \mid p \mapsto q \in \ran trains \}
\end{axdef}

\medskip

\noindent
\hangindent=2em
(b) $\{ p \colon Place \mid \exists_1 x \colon \dom trains \bullet trains(x).2 = p \}$

\bigskip


\medskip
\noindent
\hangindent=2em
(c) (mu $p : Place | $$\forall q \colon Place \bullet p \neq q$$\mid$ # $\{ x \colon \dom trains \mid trains(x).2 = p \}$ $>$ # $\{ x \colon \dom trains \mid trains(x).2 = q \}$)

\bigskip


\medskip
\bigskip
\noindent
\textbf{Solution 39}

\medskip

(a)
\par
\vspace{11pt}
\begin{axdef}
largeCoins : Collection \fun \mathbb{N}
\where
\forall c \colon Collection \bullet largeCoins(c) = c(large)
\end{axdef}

\medskip

(b)
\par
\vspace{11pt}
\begin{axdef}
addCoin : Collection \cross Coin \fun Collection
\where
\forall c \colon Collection \bullet \forall d \colon Coin \bullet addCoin(c, d) = c \cup \lbag d \rbag
\end{axdef}

\medskip

\section*{Modelling}

\bigskip
\noindent
\textbf{Solution 40}

\medskip

\bigskip

Note: Refactored to use schemas with named fields instead of tuples for fuzz compatibility.

\bigskip

\bigskip

Changed underscore identifiers to camelCase for fuzz compatibility.

\bigskip

\begin{zed}[Title, Length, Viewed]\end{zed}

\begin{schema}{Programme}
title : Title \\
length : Length \\
viewed : Viewed
\end{schema}

(a)
\par
\vspace{11pt}
\begin{axdef}
hd : \seq Programme
\where
cumulativeTotal(hd) \leq 12000 \\
\forall p \colon \ran hd \bullet p.length \leq 360
\end{axdef}

\bigskip

Note that cumulativeTotal is defined in part (d).

\bigskip

\medskip

(b)
\par
\vspace{11pt}
\bigskip

Assuming hd is defined as in part (a):

\bigskip

\bigskip

{$p : ran hd | p$.$length > 120$ . p.title}

\bigskip

\medskip

(c)
\par
\vspace{11pt}
\bigskip

These can be defined recursively:

\bigskip

\begin{axdef}
viewedProgrammes : \seq Programme \fun \seq Programme
\where
viewedProgrammes(\langle \rangle) = \langle \rangle \\
\forall x \colon Programme \bullet \forall s \colon \seq Programme \bullet viewedProgrammes(\langle x \rangle \cat s) = (\mbox{if } x.viewed = yes \mbox{ then } \langle x \rangle \cat viewedProgrammes(s) \mbox{ else } viewedProgrammes(s))
\end{axdef}

\medskip

(d)
\par
\vspace{11pt}
\begin{axdef}
cumulativeTotal : \seq Programme \fun \mathbb{N}
\where
cumulativeTotal(\langle \rangle) = 0 \\
\forall x \colon Programme \bullet \forall s \colon \seq Programme \bullet cumulativeTotal(\langle x \rangle \cat s) = x.length + cumulativeTotal(s)
\end{axdef}

\medskip

(e)
\par
\vspace{11pt}
\bigskip

Assuming hd is defined as in part (a), the title of the longest programme:

\bigskip

\bigskip

(mu $p : ran hd | $$\forall q \colon \ran hd \bullet p \neq q \land p.length > q.length$$\mid$ p.title)

\bigskip

\bigskip

(This, of course, assumes that there is a unique element with this property.)

\bigskip

\medskip

(f)
\par
\vspace{11pt}
\bigskip

axdef

\bigskip

\bigskip

$totalsByTitle : seq(Programme) \fun (Title +\fun Length)$

\bigskip

\bigskip

where

\bigskip

\bigskip

$\forall$ $s : seq(Programme) |$

\bigskip

\bigskip

totalsByTitle(s) = {$t : Title | ($$\exists p \colon \ran s \bullet p.title = t$) .

\bigskip

\bigskip

t $\mapsto$ cumulativeTotal(s $\rres$ {$l : Length$; $v : Viewed $. (t, l, v)})}

\bigskip

\bigskip

end

\bigskip

\bigskip



\bigskip

\bigskip

(Note: Complex nested set comprehensions - may require simplification for implementation)

\bigskip

\medskip

(g)
\par
\vspace{11pt}
\begin{axdef}
removeTheLongestViewed : \seq Programme \fun \seq Programme
\where
\forall s \colon \seq Programme \bullet removeTheLongestViewed(s) = s \rres \{ x \colon \ran s \mid x \neq longestViewed(s) \}
\end{axdef}

\bigskip

Where longestViewed is defined as:

\bigskip

\begin{axdef}
longestViewed : \seq Programme \pfun Programme
\where
\forall s \colon \seq Programme \bullet longestViewed(s) = \mu p \colon \ran s \bullet p.viewed = yes \land \forall q \colon \ran s \bullet p \neq q \land q.viewed = yes \land p.length > q.length
\end{axdef}

\bigskip

This, of course, assumes that there is at least one viewed programme (and one of a unique maximum length).

\bigskip

\medskip

(h)
\par
\vspace{11pt}
\begin{axdef}
sortByLength : \seq Programme \fun \seq Programme
\where
\forall x \colon \seq Programme \bullet items(sortByLength(x)) = items(x) \land \forall i, j \colon \dom sortByLength(x) \bullet i < j \Rightarrow sortByLength(x)(i).length \geq sortByLength(x)(j).length
\end{axdef}

\medskip

\bigskip
\noindent
\textbf{Solution 41}

\medskip

\begin{zed}[Year, Course, Lecturer]\end{zed}

\begin{schema}{Entry}
year : Year \\
course : Course \\
code : \mathbb{N} \\
lecturer : Lecturer \\
enrolled : \mathbb{N} \\
completed : \mathbb{N} \\
grade : \mathbb{N}
\end{schema}

\begin{zed}
Table == \mathbb{N} \pinj Entry
\end{zed}

(a)
\par
\vspace{11pt}
\begin{axdef}
records : Year \pinj Table
\where
\dom records = 1993 \upto current \\
\forall y \colon \dom records \bullet \# records(y) \leq 50 \\
\forall y \colon \dom records \bullet \forall e \colon \ran records(y) \bullet e.year = y \\
\forall r \colon \ran records \bullet \forall i1, i2 \colon \dom r \bullet i1 \neq i2 \land r(i1).year = r(i2).year \Rightarrow r(i1).code \neq r(i2).code
\end{axdef}

\medskip

\noindent
\hangindent=2em
(b) $i(\{ e \colon Entry \mid \exists r \colon \ran records \bullet e \in \ran r \land e.code = 479 \})$

\noindent
$ii(\{ e \colon Entry \mid \exists r \colon \ran records \bullet e \in \ran r \land e.completed > e.enrolled \})$


\noindent
$iii(\{ e \colon Entry \mid \exists r \colon \ran records \bullet e \in \ran r \land e.grade \geq 70 \})$


\noindent
$iv(\{ c \colon Course \mid \forall r \colon \ran records \bullet \forall e \colon \ran r \bullet e.course = c \Rightarrow e.grade \geq 70 \})$


\noindent
$v(\{ y \colon Year \mid y \in \dom records \bullet y \mapsto \{ l \colon Lecturer \mid \# \{ e \colon \ran records(y) \mid e.lecturer = l \} > 6 \} \})$


\medskip

(c)
\par
\vspace{11pt}
\begin{axdef}
\where
\forall x \colon Entry \bullet \forall s \colon \seq Entry \bullet courses479(\langle \rangle) = \langle \rangle \land courses479(\langle x \rangle \cat s) = (\mbox{if } x.code = 479 \mbox{ then } \langle x \rangle \cat courses479(s) \mbox{ else } courses479(s))
\end{axdef}

\medskip

(d)
\par
\vspace{11pt}
\begin{axdef}
\where
\forall x \colon Entry \bullet \forall s \colon \seq Entry \bullet total(\langle \rangle) = 0 \land total(\langle x \rangle \cat s) = x.enrolled + total(s)
\end{axdef}

\medskip

\bigskip
\noindent
\textbf{Solution 42}

\medskip

(a)
\par
\vspace{11pt}
\begin{zed}[Person]\end{zed}

\begin{axdef}
State : \power \seq (\iseq Person)
\where
\forall s \colon State \bullet \forall i, j \colon \dom s \bullet i \neq j \land \ran s(i) \cap \ran s(j) = \{\}
\end{axdef}

\medskip

(b)
\par
\vspace{11pt}
\begin{axdef}
add : \mathbb{N} \cross Person \cross State \pinj State
\where
\forall n \colon \mathbb{N} \bullet \forall p \colon Person \bullet \forall s \colon State \bullet n \in \dom s \land p \notin \bigcup \ran \ran s.add(n, p, s) = s \oplus \{n \mapsto s(n)^{\langle p \rangle}\}
\end{axdef}

\medskip

\bigskip
\noindent
\textbf{Solution 43}

\medskip

\bigskip

Note: Assuming given types Cinema, Film, Date, Booking and a bookings relation.

\bigskip

\bigskip

The problem statement $defines : bookings $: (Cinema cross Film) $\pfun$ seq Booking

\bigskip

\bigskip

where Booking is a triple of (bookingRef, startDay, endDay) : (N cross N cross N)

\bigskip

\begin{zed}[Cinema, Film, Date]\end{zed}

\begin{schema}{Booking}
ref : \mathbb{N} \\
startDay : \mathbb{N} \\
endDay : \mathbb{N}
\end{schema}

\bigskip

Assuming: bookings : (Cinema cross Film) $\pfun$ seq Booking

\bigskip

(a)
\par
\vspace{11pt}
\noindent
\hangindent=2em
(i) $\forall$ $i : dom bookings | $$\forall x, y \colon bookings(i) \bullet x \neq y$$\mid$ (x.startDay..x.endDay) intersect (y.startDay..y.endDay) = $\emptyset$

\bigskip


\medskip
\noindent
\hangindent=2em
(ii) $\forall$ $i : dom bookings | $\forall$ x $: bookings(i) $\mid$ $\{x.startDay, x.endDay\}$ subseteq 1..max(i.1)

\bigskip


\medskip
\bigskip

(Note: Assuming max is a function on Cinema that returns the maximum day number)

\bigskip

\noindent
\hangindent=2em
(iii) $\forall$ $i : dom bookings | $$\forall b \colon bookings(i) \bullet b.startDay \leq b.endDay$

\bigskip


\medskip
\noindent
\hangindent=2em
(iv) This is enforced by the constraint for part (i).

\bigskip


\medskip
\medskip

(b)
\par
\vspace{11pt}
\bigskip

Assuming Banbury : Cinema and bookings is defined

\bigskip

\noindent
\hangindent=2em
(i) $\{ i \colon \dom bookings \mid i.1 = Banbury.i.2 \}$

\bigskip


\medskip
\noindent
\hangindent=2em
(ii) $\{ i \colon \dom bookings \mid i.1 = Banbury \land \exists b \colon bookings(i) \bullet 50 \in b \bullet startDay \upto b.endDay \}$

\bigskip


\medskip
\noindent
\hangindent=2em
(iii) Assuming Room is Cinema, returning unique cinema/film pairs:

\bigskip


\medskip
\bigskip

{$c : Cinema$; $f : Film | $$\exists i \colon \dom bookings \bullet i.1 = c \land i.2 = f$. (c, f)}

\bigskip

\noindent
\hangindent=2em
(iv) $\{ c \colon Cinema \mid \exists i \colon \dom bookings \bullet i.1 = c \land \# bookings(i) \geq 10 \}$

\bigskip


\medskip
\medskip

\section*{Free types and induction}

\begin{zed}[N]\end{zed}

\begin{zed}Tree ::= stalk | leaf \ldata \mathbb{N} \rdata | branch \ldata Tree \cross Tree \rdata\end{zed}

\bigskip
\noindent
\textbf{Solution 44}

\medskip

\bigskip

The two cases of the proof are established by equational reasoning: the first by

\bigskip

\bigskip



\bigskip

\bigskip

reverse ($\langle \rangle$ ^ t) = reverse t [cat.1a] = (reverse t) ^ $\langle \rangle$ [cat.1b]

\bigskip

\bigskip



\bigskip

\bigskip

where cat.1a is $\langle \rangle$ ^ $s = s$ and cat.1b is s ^ $\langle \rangle$ = s

\bigskip

\bigskip



\bigskip

\bigskip

and the second by

\bigskip

\bigskip



\bigskip

\bigskip

reverse (($\langle x \rangle$ ^ u) ^ t) = reverse ($\langle x \rangle$ ^ (u ^ t)) [cat.2]

\bigskip

\bigskip

= reverse (u ^ t) ^ $\langle x \rangle$    [reverse.2]

\bigskip

\bigskip

= (reverse t ^ reverse u) ^ $\langle x \rangle$  [anti-distributive]

\bigskip

\bigskip

= reverse t ^ (reverse u ^ $\langle x \rangle$)  [cat.2]

\bigskip

\bigskip

= reverse t ^ reverse ($\langle x \rangle$ ^ u)  [reverse.2]

\bigskip

\bigskip
\noindent
\textbf{Solution 45}

\medskip

\bigskip

The base case:

\bigskip

\bigskip



\bigskip

\bigskip

reverse (reverse $\langle \rangle$) = reverse $\langle \rangle$ [reverse.1] = $\langle \rangle$ [reverse.1]

\bigskip

\bigskip



\bigskip

\bigskip

The inductive step:

\bigskip

\bigskip



\bigskip

\bigskip

reverse (reverse ($\langle x \rangle$ ^ t))

\bigskip

\bigskip

= reverse ((reverse t) ^ $\langle x \rangle$)  [reverse.2]

\bigskip

\bigskip

= reverse ($\langle x \rangle$) ^ reverse (reverse t)  [anti-distributive]

\bigskip

\bigskip

= reverse ($\langle x \rangle$ ^ $\langle \rangle$) ^ reverse (reverse t)  [cat.1]

\bigskip

\bigskip

= ((reverse $\langle \rangle$) ^ $\langle x \rangle$) ^ reverse (reverse t)  [reverse.2]

\bigskip

\bigskip

= ($\langle \rangle$ ^ $\langle x \rangle$) ^ reverse (reverse t)  [reverse.1]

\bigskip

\bigskip

= $\langle x \rangle$ ^ reverse (reverse t)  [cat.1]

\bigskip

\bigskip

= $\langle x \rangle$ ^ t  [reverse (reverse t) = t]

\bigskip

\bigskip
\noindent
\textbf{Solution 46}

\medskip

(a)
\par
\vspace{11pt}
\begin{axdef}
count : Tree \fun \mathbb{N}
\where
count(stalk) = 0 \\
\forall n \colon \mathbb{N} \bullet count(leaf(n)) = 1 \\
\forall t1, t2 \colon Tree \bullet count(branch(t1, t2)) = count(t1) + count(t2)
\end{axdef}

\medskip

(b)
\par
\vspace{11pt}
\begin{axdef}
flatten : Tree \fun \seq \mathbb{N}
\where
flatten(stalk) = \langle \rangle \\
\forall n \colon \mathbb{N} \bullet flatten(leaf(n)) = \langle n \rangle \\
\forall t1, t2 \colon Tree \bullet flatten(branch(t1, t2)) = flatten(t1)^{flatten}(t2)
\end{axdef}

\medskip

\bigskip
\noindent
\textbf{Solution 47}

\medskip

\bigskip

First, exhibit the induction principle for the free type:

\bigskip

\bigskip



\bigskip

\bigskip

P stalk and ($\forall n \colon \mathbb{N} \bullet \power leaf(n)$) and $\forall t1, t2 \colon Tree \bullet \power t1 \land \power t2 \Rightarrow \power branch(t1, t2)$

\bigskip

\bigskip

implies $\forall t \colon Tree \bullet \power t$

\bigskip

\bigskip



\bigskip

\bigskip

This gives three cases for the proof:

\bigskip

\bigskip



\bigskip

\bigskip

# (flatten stalk) = # $\langle \rangle$ [flatten] = 0 [#] = count stalk [count]

\bigskip

\bigskip



\bigskip

\bigskip

(Remaining cases omitted - require equational reasoning with recursive functions)

\bigskip

\section*{Supplementary material : assignment practice}

\bigskip
\noindent
\textbf{Solution 48}

\medskip

\begin{zed}[SongId, UserId, PlaylistId, Playlist]\end{zed}

\begin{axdef}
songs : \finset SongId \\
users : \finset UserId \\
playlists : PlaylistId \pfun Playlist \\
playlistOwner : PlaylistId \pfun UserId \\
playlistSubscribers : PlaylistId \pfun \finset_1 UserId
\where
\forall i \colon \dom playlists \bullet \ran playlists(i) \subseteq songs \\
\dom playlistOwner \subseteq \dom playlists \\
\ran playlistOwner \subseteq users \\
\dom playlistSubscribers \subseteq \dom playlists \\
\forall i \colon \dom playlistSubscribers \bullet playlistSubscribers(i) \subseteq users \\
\forall i \colon \dom playlists \bullet playlistOwner(i) \in playlistSubscribers(i)
\end{axdef}

\bigskip
\noindent
\textbf{Solution 49}

\medskip

\begin{axdef}
hated : UserId \pfun \finset SongId \\
loved : UserId \pfun \finset SongId
\where
\dom hated \subseteq users \\
\forall i \colon \dom hated \bullet hated(i) \subseteq songs \\
\dom loved \subseteq users \\
\forall i \colon \dom loved \bullet loved(i) \subseteq songs \\
\forall i \colon \dom hated \cup \dom loved \bullet hated(i) \cap loved(i) = \emptyset
\end{axdef}

\bigskip
\noindent
\textbf{Solution 50}

\medskip

(a)
\par
\vspace{11pt}
\begin{zed}
A == users \setminus \bigcup \ran playlistSubscribers
\end{zed}

\medskip

(b)
\par
\vspace{11pt}
\begin{zed}
B == \{ p \colon \dom playlistSubscribers \mid \# playlistSubscribers(p) \geq 100 \}
\end{zed}

\medskip

(c)
\par
\vspace{11pt}
\begin{zed}
C == \mu u \colon \dom loved \bullet \forall v \colon \dom loved \bullet u \neq v \land \# loved(u) > \# loved(v)
\end{zed}

\medskip

(d)
\par
\vspace{11pt}
\begin{zed}
D == \mu s \colon songs \bullet \forall t \colon songs \bullet s \neq t \land \# \{ u \colon UserId \mid s \in loved(u) \} > \# \{ u \colon UserId \mid t \in loved(u) \}
\end{zed}

\medskip

\bigskip
\noindent
\textbf{Solution 51}

\medskip

(a)
\par
\vspace{11pt}
\begin{axdef}
loveHateScore : SongId \pfun \mathbb{N}
\where
\forall i \colon songs \bullet loveHateScore(i) = (\mbox{if } \# \{ u \colon UserId \mid i \in loved(u) \} \geq \# \{ u \colon UserId \mid i \in hated(u) \} \mbox{ then } \# (\{ u \colon UserId \mid i \in loved(u) \} - \# \{ u \colon UserId \mid i \in hated(u) \}) \mbox{ else } 0)
\end{axdef}

\begin{axdef}
playlistCount : SongId \pfun \mathbb{N}
\where
\forall i \colon songs \bullet playlistCount(i) = \# \{ p \colon \dom playlist \mid i \in \ran playlist(p) \}
\end{axdef}

\begin{axdef}
length : SongId \pfun \mathbb{N} \\
popularity : SongId \pfun \mathbb{N}
\where
\dom length \subseteq songs \\
\dom popularity \subseteq songs \\
\forall i \colon songs \bullet popularity(i) = loveHateScore(i) + playlistCount(i)
\end{axdef}

\medskip

(b)
\par
\vspace{11pt}
\begin{axdef}
mostPopular : SongId
\where
mostPopular = (\mbox{if } \exists_1 i \colon songs \bullet \forall j \colon songs \bullet i \neq j \land popularity(i) > popularity(j) \mbox{ then } \mu i \colon songs \bullet \forall j \colon songs \bullet i \neq j \land popularity(i) > popularity(j) \mbox{ else } nullSong)
\end{axdef}

\medskip

(c)
\par
\vspace{11pt}
\begin{zed}
playlistsContainingMostPopularSong == \{ i \colon \dom playlists \mid mostPopular \in \ran playlists(i) \}
\end{zed}

\medskip

\bigskip
\noindent
\textbf{Solution 52}

\medskip

(a)
\par
\vspace{11pt}
\begin{axdef}
premiumPlays : \seq Play \fun \seq Play
\where
premiumPlays(\langle \rangle) = \langle \rangle \\
\forall x \colon Play \bullet \forall s \colon \seq Play \bullet premiumPlays(\langle x \rangle \cat s) = (\mbox{if } userStatus(x.2) = premium \mbox{ then } \langle x \rangle \cat premiumPlays(s) \mbox{ else } premiumPlays(s))
\end{axdef}

\medskip

(b)
\par
\vspace{11pt}
\begin{axdef}
standardPlays : \seq Play \fun \seq Play
\where
standardPlays(\langle \rangle) = \langle \rangle \\
\forall x \colon Play \bullet \forall s \colon \seq Play \bullet standardPlays(\langle x \rangle \cat s) = (\mbox{if } userStatus(x.2) = standard \mbox{ then } \langle x \rangle \cat standardPlays(s) \mbox{ else } standardPlays(s))
\end{axdef}

\medskip

(c)
\par
\vspace{11pt}
\begin{axdef}
cumulativeLength : \seq Play \fun \mathbb{N}
\where
cumulativeLength(\langle \rangle) = 0 \\
\forall x \colon Play \bullet \forall s \colon \seq Play \bullet cumulativeLength(\langle x \rangle \cat s) = length(x.1) + cumulativeLength(s)
\end{axdef}

\medskip

\end{document}