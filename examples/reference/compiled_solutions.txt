=== Propositional logic ===

** Solution 1 **

(a) false (as (true => false) <=> false)
(b) true (as (false => false) <=> true)
(c) true (as (false => true) <=> true)
(d) true (as (false => false) <=> true)

TEXT: (Assuming that pigs can't fly . . . )

** Solution 2 **

(a)

TRUTH TABLE:
p | q | p and q | (p and q) => p
T | T | T | T
T | F | F | T
F | T | F | T
F | F | F | T

(b)

TRUTH TABLE:
p | q | p and q | not p | not p => (p and q) | (not p => (p and q)) <=> p
T | T | T | F | T | T
T | F | F | F | T | T
F | T | F | T | F | T
F | F | F | T | F | T

(c)

TRUTH TABLE:
p | q | p => q | p and (p => q) | (p and (p => q)) => q
T | T | T | T | T
T | F | F | F | T
F | T | T | F | T
F | F | T | F | T

** Solution 3 **

(a)

EQUIV:
p => not p
<=> not p or not p [=>]
<=> not p [idempotence]

(b)

EQUIV:
not p => p
<=> not not p or p [=>]
<=> p or p [not not]
<=> p [idempotence]

(c)

EQUIV:
p => (q => r)
<=> not p or (q => r) [=>]
<=> not p or (not q or r) [=>]
<=> (not p or not q) or r [associativity]
<=> not (p and q) or r [De Morgan]
<=> (p and q) => r [=>]

(d)

EQUIV:
q => (p => r)
<=> not q or (p => r) [=>]
<=> not q or (not p or r) [=>]
<=> not p or (not q or r) [associativity and commutativity]
<=> not p or (q => r) [=>]
<=> p => (q => r) [=>]

(e)

EQUIV:
((p and q) <=> p)
<=> ((p and q) => p) and (p => (p and q)) [<=>]
<=> (not (p and q) or p) and (not p or (p and q)) [=>]
<=> ((not p or not q) or p) and (not p or (p and q)) [De Morgan]
<=> (not q or (not p or p)) and (not p or (p and q)) [associativity and comm.]
<=> (not q or true) and (not p or (p and q)) [excluded middle]
<=> true and (not p or (p and q)) [or and true]
<=> not p or (p and q) [and and true]
<=> (not p or p) and (not p or q) [distribution]
<=> true and (not p or q) [excluded middle]
<=> not p or q [and and true]
<=> p => q [=>]

(f)

EQUIV:
((p or q) <=> p)
<=> ((p or q) => p) and (p => (p or q)) [<=>]
<=> (not (p or q) or p) and (not p or (p or q)) [=>]
<=> ((not p and not q) or p) and (not p or (p or q)) [De Morgan]
<=> ((not p or p) and (not q or p)) and (not p or (p or q)) [distribution]
<=> (true and (not q or p)) and (not p or (p or q)) [excluded middle]
<=> (not q or p) and (not p or (p or q)) [and and true]
<=> (not q or p) and ((not p or p) or q) [associativity]
<=> (not q or p) and (true or q) [excluded middle]
<=> (not q or p) and true [or and true]
<=> (not q or p) [and and true]
<=> q => p [=>]

** Solution 4 **

(a)

TEXT: (p or q) <=> ((not p or not q) and q) is not a tautology. You might illustrate this via a truth table or via a chain of equivalences, showing that the proposition is not equivalent to true. Alternatively, you might try and find a combination of values for which the proposition is false. (In this case, the proposition is false when p and q are both true.)

(b)

TEXT: (p or q) <=> ((not p and not q) or q) is not a tautology. In this case, the proposition is false when p is true and q is false.

** Solution 5 **

(a) exists d : Dog | gentle(d) and well_trained(d)
(b) forall d : Dog | neat(d) and well_trained(d) => attractive(d)
(c) exists d : Dog | gentle(d) => forall t : Trainer | groomed(d, t)

** Solution 6 **

(a)

TEXT: This is a true proposition: whatever the value of x, the expression x^2 - x + 1 denotes a natural number. If we choose y to be this natural number, we will find that p is true.

(b)

TEXT: This is a false proposition. We cannot choose a large enough value for y such that p will hold for any value of x.

(c)

TEXT: This is a false proposition. It is an implication whose antecedent part is true and whose consequent part is false.

(d)

TEXT: This is a true proposition. It is an implication whose antecedent part is false and whose consequent part is true.

** Solution 7 **

(a)

TEXT: We must define a predicate p that is false for at least one value of x, and is true for at least one other value. A suitable solution would be p <=> x > 1.

(b)

TEXT: With the above choice of p, we require only that q is sometimes false when p is true (for else the universal quantification would hold). A suitable solution would be q <=> x > 3.

** Solution 8 **

(a) forall x : N | x >= z
(b) forall z : N | z >= x + y
(c) x + 3 > 0 and forall z : N | z >= x + 3

=== Equality ===

** Solution 9 **

(a)

EQUIV:
exists y : N | y in {0, 1} and y != 1 and x != y
<=> exists y : N | y = 0 and x != y [arithmetic]
<=> 0 in N and x != 0 [one-point rule]
<=> x != 0

(b)

EQUIV:
exists x, y : N | x + y = 4 and x < y
<=> exists x, y : N | y = 4 - x and x < y
<=> exists x : N | 4 - x in N and x < 4 - x
<=> true

TEXT: The final equivalence holds because 0 in N, 4 - 0 in N, and 0 < 4.

(c)

EQUIV:
forall x : N | exists y : N | x = y + 1
<=> forall x : N | exists y : N | y = x - 1
<=> forall x : N | x - 1 in N

TEXT: The final equivalence holds because 0 in N and yet 0 - 1 not in N. We may assume that the subtraction operator is defined for all integers.

(d)

EQUIV:
exists x : N | (x = 1 and x > y) or (x = 2 and x > z)
<=> (exists x : N | x = 1 and x > y) or (exists x : N | x = 2 and x > z)
<=> (1 in N and 1 > y) or (exists x : N | x = 2 and x > z)
<=> (1 in N and 1 > y) or (2 in N and 2 > z)
<=> 1 > y or 2 > z

** Solution 10 **

TEXT: As discussed, the quantifier exists1 can help give rise to a 'test' or 'precondition' to ensure that an application of mu will work.

TEXT: So, as a simple example, as the proposition

exists1 n : N | (forall m : N | n <= m)

TEXT: is equivalent to true, we can be certain that the statement

(mu n : N | (forall m : N | n <= m))

TEXT: will return a result (which happens to be 0).

** Solution 11 **

(a) (mu a : N | a = a) = 0 
TEXT: is a provable statement, since 0 is the only natural number with the specified property.

(b) (mu b : N | b = b) = 1 
TEXT: is not provable. The specified property is true of both 0 and 1, and thus the value of the mu-expression is undefined.

(c) (mu c : N | c > c) = (mu c : N | c > c) 
TEXT: is a provable statement. Neither expression is properly defined, but we may conclude that they are equal; there is little else that we can prove about them.

(d) (mu d : N | d = d) = 1 
TEXT: is not a provable statement. We cannot confirm that 1 is the only natural number with the specified property; we do not know what value is taken by undefined operations.

** Solution 12 **

TEXT: (Requires mu-operator with expression part - not yet implemented)

(a)

(mu m : Mountain | (forall n : Mountain | height(n) <= height(m)) . height(m))

(b)

(mu c : Chapter | (exists1 d : Chapter | length(d) > length(c)) . length(c))

(c)

TEXT: Assuming the existence of a suitable function, max: (mu n : N | n = max({ m : N | 8 * m < 100 . 8 * m }) . 100 - n)

=== Deductive proofs ===

** Solution 13 **

PROOF:
  (p and (p => q)) => (p and q) [=> intro from 1]
    [1] p and (p => q) [assumption]
    :: p and q [and intro]
      :: p [and elim from 1]
        [1] p and (p => q) [from above]
      :: q [=> elim]
        :: p => q [and elim from 1]
          [1] p and (p => q) [from above]
        :: p [and elim from 1]
          [1] p and (p => q) [from above]

** Solution 14 **

TEXT: In one direction:

PROOF:
  ((p and q) <=> p) => (p => q) [=> intro from 1]
    [1] (p and q) <=> p [assumption]
    :: p => q [=> intro from 2]
      [2] p [assumption]
      :: q [and elim from 3]
        :: p and q [=> elim from 1 and 2]
          [3] p and q [derived]

TEXT: and the other:

PROOF:
  (p => q) => ((p and q) <=> p) [=> intro from 1]
    [1] p => q [assumption]
    :: (p and q) <=> p [<=> intro]
      :: (p and q) => p [=> intro from 2]
        [2] p and q [assumption]
        :: p [and elim from 2]
      :: p => (p and q) [=> intro from 3]
        [3] p [assumption]
        :: p and q [and intro from 1 and 3]

TEXT: We can then combine these two proofs with <=> intro.

** Solution 15 **

PROOF:
  ((p => q) and not q) => not p [=> intro from 1]
    [1] (p => q) and not q [assumption]
    :: not p [false elim from 2]
      [2] p [assumption]
      :: false [false intro]
        :: q [=> elim]
          :: p => q [and elim from 1]
          :: p [from 2]
        :: not q [and elim from 1]

** Solution 16 **

TEXT: In one direction:

PROOF:
  (p and (q or r)) => ((p and q) or (p and r)) [=> intro from 1]
    [1] p and (q or r) [assumption]
    :: (p and q) or (p and r) [or elim from 2]
      [2] q or r [from 1]
      case q:
        :: p and q [and intro]
          :: p [and elim from 1]
          :: q [case assumption]
        :: (p and q) or (p and r) [or intro]
      case r:
        :: p and r [and intro]
          :: p [and elim from 1]
          :: r [case assumption]
        :: (p and q) or (p and r) [or intro]

TEXT: In the other:

PROOF:
  ((p and q) or (p and r)) => (p and (q or r)) [=> intro from 3]
    [3] (p and q) or (p and r) [assumption]
    :: p and (q or r) [or elim from 4]
      [4] case1 or case2 [from 3]
      case p and q:
        :: p [and elim]
        :: q or r [or intro]
        :: p and (q or r) [and intro]
      case p and r:
        :: p [and elim]
        :: q or r [or intro]
        :: p and (q or r) [and intro]

** Solution 17 **

TEXT: In one direction:

PROOF:
  (p or (q and r)) => ((p or q) and (p or r)) [=> intro from 3]
    [3] p or (q and r) [assumption]
    :: (p or q) and (p or r) [or elim and and intro]

TEXT: and the other:

PROOF:
  ((p or q) and (p or r)) => (p or (q and r)) [=> intro from 1]
    [1] (p or q) and (p or r) [assumption]
    :: p or (q and r) [or elim from 2 and 3]

** Solution 18 **

TEXT: In one direction:

PROOF:
  (p => q) => (not p or q) [=> intro from 1]
    [1] p => q [assumption]
    :: not p or q [or elim from excluded middle]

TEXT: and the other:

PROOF:
  (not p or q) => (p => q) [=> intro from 3]
    [3] not p or q [assumption]
    :: p => q [=> intro from 4]
      [4] p [assumption]
      :: q [or elim and false elim from 3]

=== Sets and types ===

** Solution 19 **

(a)

TEXT: 1 in {4, 3, 2, 1} is true.

(b)

TEXT: {1} in {1, 2, 3, 4} is undefined.

(c)

TEXT: {1} in {{1}, {2}, {3}, {4}} is true.

(d)

TEXT: The empty set in {1, 2, 3, 4} is undefined.

** Solution 20 **

(a)

{1} cross {2, 3}

TEXT: is the set {(1, 2), (1, 3)}

(b)

TEXT: The empty set cross {2, 3} is the empty set

(c)

(P emptyset) cross {1}

TEXT: is the set {(emptyset, 1)}

(d)

TEXT: {(1, 2)} cross {3, 4} is the set {((1, 2), 3), ((1, 2), 4)}

** Solution 21 **

TEXT: There are various ways of describing these sets via set comprehensions. Examples are given below.

(a)

{ z : Z | 0 <= z and z <= 100 }

(b)

{ z : Z | z = 10 }

(c)

{ z : Z | z mod 2 = 0 or z mod 3 = 0 or z mod 5 = 0 }

** Solution 22 **

(a)

{ n : N | n <= 4 . n^2 }

(b)

{ n : N | n <= 4 . (n, n^2) }

(c)

{ n : P {0, 1} }

(d)

{ n : P {0, 1} | true . (n, # n) }

** Solution 23 **

(a)

EQUIV:
x in a intersect a
<=> x in a and x in a
<=> x in a

(b)

EQUIV:
x in a union a
<=> x in a or x in a
<=> x in a

** Solution 24 **

(a)

TEXT: The set of all pairs of integers is Z cross Z. To give it a name, we could write:

Pairs == Z cross Z

(b)

TEXT: The set of all integer pairs in which each element is strictly greater than zero could be defined by:

StrictlyPositivePairs == { m, n : Z | m > 0 and n > 0 . (m, n) }

(c)

TEXT: It is intuitive to use a singular noun for the name of a basic type; we define the set of all people by writing:

given Person

(d)

TEXT: The set of all couples could be defined by:

Couples == { s : P Person | # s = 2 }

** Solution 25 **

TEXT: (Requires generic set notation and Cartesian product)

** Solution 26 **

TEXT: (Requires generic parameters and relation type notation)

=== Relations ===

** Solution 27 **

(a)

TEXT: The power set of {(0,0), (0,1), (1,0), (1,1)} is:

{ emptyset, {(0, 0)}, {(0, 1)}, {(1, 0)}, {(1, 1)}, {(1, 0), (1, 1)}, {(0, 0), (0, 1)}, {(0, 1), (1, 1)}, {(0, 1), (1, 0)}, {(0, 0), (1, 1)}, {(0, 0), (1, 0)}, {(0, 0), (1, 0), (1, 1)}, {(0, 0), (0, 1), (1, 1)}, {(0, 0), (0, 1), (1, 0)}, {(0, 1), (1, 0), (1, 1)}, {(0, 0), (0, 1), (1, 0), (1, 1)} }

(b)

{ emptyset, {(0, 0)}, {(0, 1)}, {(0, 0), (0, 1)} }

(c)

{ emptyset }

(d)

{ emptyset }

** Solution 28 **

(a)

dom R = {0, 1, 2}

(b)

ran R = {1, 2, 3}

(c)

{1, 2} <| R = {1 |-> 2, 1 |-> 3, 2 |-> 3}

** Solution 29 **

(a)

{2 |-> 4, 3 |-> 3, 3 |-> 4, 4 |-> 2}

(b)

{1 |-> 3, 2 |-> 2, 2 |-> 3, 3 |-> 1}

(c)

{1 |-> 1, 2 |-> 2, 2 |-> 3, 3 |-> 2, 3 |-> 3, 4 |-> 4}

(d)

{1 |-> 4, 2 |-> 2, 2 |-> 3, 3 |-> 2, 3 |-> 3, 4 |-> 1}

** Solution 30 **

axdef
  childOf : Person <-> Person
end

(a)

parentOf == childOf~

TEXT: This is a good example of how there are many different ways of writing the same thing. An alternative abbreviation would be: parentOf == {x, y : Person | x |-> y in childOf . y |-> x}. Or via an axiomatic definition with parentOf : Person <-> Person and where clause parentOf = childOf~.

(b)

siblingOf == (childOf o9 parentOf) \ id[Person]

(c)

cousinOf == childOf o9 siblingOf o9 parentOf

(d)

ancestorOf == parentOf+

** Solution 31 **

TEXT: (Requires compound identifiers with operators - R+, R*)

(a)

R == {a, b : N | b = a or b = a}

(b)

S == {a, b : N | b = a or b = a}

(c)

TEXT: R+ == {a, b : N | b > a}

(d)

TEXT: R* == {a, b : N | b >= a}

** Solution 32 **

(a)

EQUIV:
x |-> y in A <| (B <| R)
<=> x in A and x |-> y in (B <| R)
<=> x in A and x in B and x |-> y in R
<=> x in A intersect B and x |-> y in R
<=> x |-> y in (A intersect B) <| R

(b)

EQUIV:
x |-> y in (R union S) |> C
<=> x |-> y in (R union S) and y in C
<=> (x |-> y in R or x |-> y in S) and y in C
<=> (x |-> y in R and y in C) or (x |-> y in S and y in C)
<=> x |-> y in R |> C or x |-> y in S |> C
<=> x |-> y in (R |> C) union (S |> C)

=== Functions ===

** Solution 33 **

TEXT: The set of 9 functions:

{ emptyset, {(0, 0)}, {(0, 1)}, {(1, 1)}, {(1, 0)}, {(0, 0), (1, 1)}, {(0, 1), (1, 1)}, {(1, 0), (0, 0)}, {(0, 1), (1, 0)} }

(a)

TEXT: The set of total functions:

{ {(0, 0), (1, 1)}, {(0, 1), (1, 1)}, {(1, 0), (0, 0)}, {(0, 1), (1, 0)} }

(b)

TEXT: The set of functions which are neither injective nor surjective:

{ {(0, 1), (1, 1)}, {(0, 0), (1, 0)} }

(c)

TEXT: The set of functions which are injective but not surjective:

{ emptyset, {(0, 0)}, {(0, 1)}, {(1, 0)}, {(1, 1)} }

(d)

TEXT: There are no functions (of this type) which are surjective but not injective.

(e)

TEXT: The set of bijective functions:

{ {(0, 0), (1, 1)}, {(0, 1), (1, 0)} }

** Solution 34 **

(a)

{1 |-> a, 2 |-> b, 3 |-> c, 4 |-> b}

(b)

{1 |-> c, 2 |-> b, 3 |-> c, 4 |-> d}

(c)

{1 |-> c, 2 |-> b, 3 |-> c, 4 |-> b}

(d)

{1 |-> c, 2 |-> b, 3 |-> c, 4 |-> b}

** Solution 35 **

TEXT: (Requires power set notation P and relational image)

(a)

axdef
  children : Person -> P Person
where
  children = {p : Person . p |-> parentOf(| {p} |)}
end

(b)

axdef
  number_of_grandchildren : Person -> N
where
  number_of_grandchildren = {p : Person . p |-> # (parentOf o9 parentOf)(| {p} |)}
end

** Solution 36 **

TEXT: (Note: This solution demonstrates relation types in quantifier domains)

axdef
  number_of_drivers : (Drivers <-> Cars) -> (Cars -> N)
where
  number_of_drivers = (lambda r : Drivers <-> Cars . {c : ran r . c |-> #{d : Drivers | d |-> c in r}})
end

=== Sequences ===

** Solution 37 **

(a)

<a>

(b)

{1 |-> a, 2 |-> b, 2 |-> a, 3 |-> c, 3 |-> b, 4 |-> d}

(c)

{2 |-> b, 3 |-> c, 4 |-> d}

(d)

{1, 2, 3, 4}

(e)

{a, b}

(f)

{a |-> 1, b |-> 2, c |-> 3, d |-> 4}

(g)

<a, b>

(h)

{3 |-> b}

(i)

{a}

(j)

c

** Solution 38 **

(a)

axdef
  f : Place -> P(Place)
where
  forall p : Place | f(p) = {q : Place | p |-> q in ran trains}
end

(b)

{p : Place | (exists1 x : dom trains | (trains(x)).2 = p)}

(c)

(mu p : Place | forall q : Place | p /= q | # {x : dom trains | (trains(x)).2 = p} > # {x : dom trains | (trains(x)).2 = q})

** Solution 39 **

(a)

TEXT: large_coins : Collection -> N
TEXT: forall c : Collection | large_coins(c) = c(large)
TEXT: (Blocked by: underscore in identifier for fuzz compatibility)

(b)

TEXT: add_coin : Collection * Coin -> Collection
TEXT: forall c : Collection; d : Coin | add_coin(c, d) = c union [[d]]
TEXT: (Blocked by: underscore in identifier and bag union)

=== Modelling ===

TEXT: Solutions 40-52 are work in progress - many require features not yet implemented

** Solution 40 **

TEXT: (Work in progress - requires semicolon-separated bindings in set comprehensions)

(a)

TEXT: hd : seq(Title * Length * Viewed)
TEXT: cumulative_total hd <= 12000
TEXT: forall p : ran hd | p.2 <= 360

TEXT: Note that cumulative_total is defined in part (d).

(b)

{p : ran hd | p.2 > 120 . p.1}

(c)

TEXT: These can be defined recursively:

axdef
  viewed : seq(Programme) -> seq(Programme)
where
  viewed(<>) = <> and forall x : Programme; s : seq(Programme) | viewed(<x> ^ s) = if x.3 = yes then <x> ^ viewed(s) else viewed(s)
end

TEXT: or otherwise (omitted - requires semicolon-separated bindings in set comprehension)

(d)

axdef
  cumulative_total : seq(Title * Length * Viewed) -> N
where
  cumulative_total (<>) = 0
  forall x : Title * Length * Viewed; s : seq(Title * Length * Viewed) | cumulative_total (<x> ^ s) = x.2 + cumulative_total(s)
end

(e)

TEXT: (mu p : ran hd | forall q : ran hd | p /= q | p.2 > q.2 | p.1)

TEXT: (This, of course, assumes that there is a unique element with this property.)

(f)

TEXT: (f) Omitted - requires semicolon-separated bindings in nested set comprehension

(g)

TEXT: axdef
TEXT:   g : seq(Title * Length * Viewed) -> seq(Title * Length * Viewed)
TEXT: where
TEXT:   forall s : seq(Title * Length * Viewed) | g(s) = s |> {x : ran s | x /= longest_viewed(s)}
TEXT: end
TEXT:
TEXT: Where longest_viewed is defined as
TEXT:
TEXT: axdef
TEXT:   longest_viewed : seq(Title * Length * Viewed) +-> Title * Length * Viewed
TEXT: where
TEXT:   forall s : seq(Title * Length * Viewed) | longest_viewed(s) = (mu p : ran s | p.3 = yes and forall q : ran s | p /= q and q.3 = yes | p.2 > q.2)
TEXT: end

TEXT: This, of course, assumes that there is at least one viewed programme (and one of a unique maximum length).

(h)

axdef
  s : seq(Title * Length * Viewed) -> seq(Title * Length * Viewed)
where
  forall x : seq(Title * Length * Viewed) | items(s(x)) = items(x) and (forall i, j : dom(s(x)) | i < j => (s(x)(i)).2 >= (s(x)(j)).2)
end

** Solution 41 **

(a)

TEXT: axdef
TEXT:   records : Year -|> Table
TEXT: where
TEXT:   dom(records) = 1993..current
TEXT:   forall y : dom(records) | # (records(y)) <= 50
TEXT:   forall y : dom(records) | forall e : ran(records(y)) | year(e.1) = y
TEXT:   forall r : ran(records) | forall i1, i2 : dom(r) | i1 /= i2 and (r(i1)).1 = (r(i2)).1 => (r(i1)).3 /= (r(i2)).3
TEXT: end

(b)

(i)

{e : Entry | (exists r : ran records | e in ran r and e.3 = 479)}

(ii)

{e : Entry | (exists r : ran records | e in ran r and e.6 > e.5)}

(iii)

{e : Entry | (exists r : ran records | e in ran r and e.7 >= 70)}

(iv)

{c : Course | (forall r : ran records | (forall e : ran r | e.2 = c => e.7 >= 70))}

(v)

TEXT: {y : Year | y in dom records . y |-> {l : Lecturer | # {c : ran (records y) | c.4 = l} > 6}}

(c)

TEXT: axdef
TEXT: where
TEXT:   forall x : Entry; s : seq(Entry) | 479_courses (<>) = <> and 479_courses (<x> ^ s) = if x.3 = 479 then <x> ^ 479_courses(s) else 479_courses(s)
TEXT: end
TEXT: (Blocked by: underscore in identifier - use camelCase for fuzz compatibility)

(d)

axdef
where
  forall x : Entry; s : seq(Entry) | total(<>) = 0 and total(<x> ^ s) = x.5 + total(s)
end

** Solution 42 **

given Person

axdef
  State : P(seq(iseq(Person)))
where
  forall s : State | forall i, j : dom(s) | i /= j | ran(s(i)) intersect ran(s(j)) = {}
end

(b)

TEXT: axdef
TEXT:   add : N * Person * State -|> State
TEXT: where
TEXT:   forall n : N; p : Person; s : State | n in dom s and p /in bigcup(ran(ran(s))) |
TEXT:     add(n, p, s) = s ++ {n |-> s(n) ^ <p>}
TEXT: end
TEXT: (Blocked by: -|> operator not implemented)

** Solution 43 **

(a)

TEXT: (i) forall i : dom bookings | forall x, y : bookings(i) | x /= y | (x.2..x.3) intersect (y.2..y.3) = {}
TEXT:
TEXT: (ii) forall i : dom bookings | forall x : bookings(i) | {x.2, x.3} subseteq 1..max(i.1)
TEXT:
TEXT: (iii) forall i : dom bookings | forall b : bookings(i) | b.2 <= b.3
TEXT:
TEXT: (iv) This is enforced by the constraint for part (i).
TEXT:

(b)

TEXT: (i) {i : dom bookings | i.1 = Banbury . i.2}
TEXT:
TEXT: (ii) {i : dom bookings | i.1 = Banbury and exists b : bookings(i) | 50 in b.2..b.3}
TEXT:
TEXT: (iii) {r : Room; s : N | exists i : dom bookings | i.1 = r and i.2 = s . (r, s)}
TEXT:
TEXT: (iv) {r : Room | exists i : dom bookings | i.1 = r | # (bookings(i)) >= 10}
TEXT:

=== Free types and induction ===

given N

Tree ::= stalk | leaf⟨N⟩ | branch⟨Tree × Tree⟩

** Solution 44 **

TEXT: The two cases of the proof are established by equational reasoning: the first by
TEXT:
TEXT: reverse (<> ^ t) = reverse t [cat.1a] = (reverse t) ^ <> [cat.1b]
TEXT:
TEXT: where cat.1a is <> ^ s = s and cat.1b is s ^ <> = s
TEXT:
TEXT: and the second by
TEXT:
TEXT: reverse ((<x> ^ u) ^ t) = reverse (<x> ^ (u ^ t)) [cat.2]
TEXT:                          = reverse (u ^ t) ^ <x>    [reverse.2]
TEXT:                          = (reverse t ^ reverse u) ^ <x>  [anti-distributive]
TEXT:                          = reverse t ^ (reverse u ^ <x>)  [cat.2]
TEXT:                          = reverse t ^ reverse (<x> ^ u)  [reverse.2]

** Solution 45 **

TEXT: The base case:
TEXT:
TEXT: reverse (reverse <>) = reverse <> [reverse.1] = <> [reverse.1]
TEXT:
TEXT: The inductive step:
TEXT:
TEXT: reverse (reverse (<x> ^ t))
TEXT:   = reverse ((reverse t) ^ <x>)  [reverse.2]
TEXT:   = reverse (<x>) ^ reverse (reverse t)  [anti-distributive]
TEXT:   = reverse (<x> ^ <>) ^ reverse (reverse t)  [cat.1]
TEXT:   = ((reverse <>) ^ <x>) ^ reverse (reverse t)  [reverse.2]
TEXT:   = (<> ^ <x>) ^ reverse (reverse t)  [reverse.1]
TEXT:   = <x> ^ reverse (reverse t)  [cat.1]
TEXT:   = <x> ^ t  [reverse (reverse t) = t]

** Solution 46 **

(a)

TEXT: count : Tree -> N
TEXT: count stalk = 0
TEXT: forall n : N | count (leaf n) = 1
TEXT: forall t1, t2 : Tree | count (branch (t1, t2)) = count t1 + count t2
TEXT: (Blocked by: recursive free types and pattern matching)

(b)

TEXT: flatten : Tree -> seq N
TEXT: flatten stalk = <>
TEXT: forall n : N | flatten (leaf n) = <n>
TEXT: forall t1, t2 : Tree | flatten (branch (t1, t2)) = flatten t1 ^ flatten t2
TEXT: (Blocked by: recursive free types and pattern matching)

** Solution 47 **

TEXT: First, exhibit the induction principle for the free type:
TEXT:
TEXT: P stalk and (forall n : N | P (leaf n)) and (forall t1, t2 : Tree | P t1 and P t2 => P (branch (t1, t2)))
TEXT: implies forall t : Tree | P t
TEXT:
TEXT: This gives three cases for the proof:
TEXT:
TEXT: # (flatten stalk) = # <> [flatten] = 0 [#] = count stalk [count]
TEXT:
TEXT: (Remaining cases omitted - require equational reasoning with recursive functions)

=== Supplementary material: assignment practice ===

** Solution 48 **

given SongId, UserId, PlaylistId, Playlist

axdef
  songs : F SongId
  users : F UserId
  playlists : PlaylistId +-> Playlist
  playlistOwner : PlaylistId +-> UserId
  playlistSubscribers : PlaylistId +-> F1 UserId
where
  forall i : dom(playlists) | ran(playlists(i)) subseteq songs
  dom(playlistOwner) subseteq dom(playlists)
  ran(playlistOwner) subseteq users
  dom(playlistSubscribers) subseteq dom(playlists)
  forall i : dom(playlistSubscribers) | playlistSubscribers(i) subseteq users
  forall i : dom(playlists) | playlistOwner(i) in playlistSubscribers(i)
end

** Solution 49 **

axdef
  hated : UserId +-> F SongId
  loved : UserId +-> F SongId
where
  dom(hated) subseteq users
  forall i : dom(hated) | hated(i) subseteq songs
  dom(loved) subseteq users
  forall i : dom(loved) | loved(i) subseteq songs
  forall i : dom(hated) union dom(loved) | hated(i) intersect loved(i) = emptyset
end

** Solution 50 **

(a)

A == users \ bigcup(ran(playlistSubscribers))

(b)

B == {p : dom(playlistSubscribers) | # (playlistSubscribers(p)) >= 100}

(c)

C == (mu u : dom(loved) | forall v : dom(loved) | u /= v | # (loved(u)) > # (loved(v)))

(d)

D == (mu s : songs | forall t : songs | s /= t | # {u : UserId | s in loved(u)} > # {u : UserId | t in loved(u)})

** Solution 51 **

(a)

TEXT: Let's first define two helper functions:
TEXT:
TEXT: loveHateScore : SongId +-> N
TEXT: forall i : songs | # {u : UserId | i in loved(u)} >= # {u : UserId | i in hated(u)} =>
TEXT:     loveHateScore(i) = # {u : UserId | i in loved(u)} - # {u : UserId | i in hated(u)}
TEXT: and
TEXT: forall i : songs | # {u : UserId | i in loved(u)} < # {u : UserId | i in hated(u)} =>
TEXT:     loveHateScore(i) = 0
TEXT:
axdef
  playlistCount : SongId +-> N
where
  forall i : songs | playlistCount(i) = # {p : dom(playlist) | i in ran(playlist(p))}
end

TEXT: We then have:

axdef
  length : SongId +-> N
  popularity : SongId +-> N
where
  dom(length) subseteq songs
  dom(popularity) subseteq songs
  forall i : songs | popularity(i) = loveHateScore(i) + playlistCount(i)
end

(b)

TEXT: mostPopular : SongId
TEXT: (exists1 i : songs | forall j : songs | i /= j | popularity(i) > popularity(j)) =>
TEXT:     mostPopular = (mu i : songs | forall j : songs | i /= j | popularity(i) > popularity(j))
TEXT: and
not (exists1 i : songs | forall j : songs | i /= j | popularity(i) > popularity(j)) => mostPopular = nullSong

(c)

TEXT: playlistsContainingMostPopularSong == {i : dom(playlists) | mostPopular in ran(playlists(i))}

** Solution 52 **

(a)

TEXT: premiumPlays : seq(Play) -> seq(Play)
TEXT: premiumPlays(<>) = <>
TEXT: forall x : Play; s : seq(Play) |
TEXT:     premiumPlays(<x> ^ s) = <x> ^ premiumPlays(s)   if userStatus(x.2) = premium
TEXT:                              premiumPlays(s)          if userStatus(x.2) = standard
TEXT: (Note: Uses camelCase for fuzz compatibility)

(b)

TEXT: standardPlays : seq(Play) -> seq(Play)
TEXT: standardPlays(<>) = <>
TEXT: forall x : Play; s : seq(Play) |
TEXT:     standardPlays(<x> ^ s) = <x> ^ standardPlays(s)  if userStatus(x.2) = standard
TEXT:                               standardPlays(s)        if userStatus(x.2) = premium
TEXT: (Note: Uses camelCase for fuzz compatibility)

(c)

TEXT: cumulativeLength : seq(Play) -> N
TEXT: cumulativeLength(<>) = 0
TEXT: forall x : Play; s : seq(Play) |
TEXT:     cumulativeLength(<x> ^ s) = length(x.1) + cumulativeLength(s)
TEXT: (Note: Uses camelCase for fuzz compatibility)
