// ============================================================================
// Reference: Compiled Course Solutions
// ============================================================================
// Description:
//   - Complete collection of course solutions
//   - Covers propositional logic, predicate logic, sets, relations, functions
//   - Truth tables, equivalences, proofs
//   - Z notation specifications
//   - Reference implementation for txt2tex features
//
// Topics:
//   - Propositional logic (Solutions 1-3)
//   - Truth tables and equivalences
//   - Predicate logic with quantifiers
//   - Set theory and operations
//   - Z notation definitions
//
// See: docs/USER_GUIDE.md for syntax reference
// ============================================================================

=== Propositional logic ===

** Solution 1 **

(a) false (as (true => false) <=> false)
(b) true (as (false => false) <=> true)
(c) true (as (false => true) <=> true)
(d) true (as (false => false) <=> true)

TEXT: (Assuming that pigs can't fly . . . )

** Solution 2 **

(a) TRUTH TABLE:
p | q | p and q | (p and q) => p
T | T | T | T
T | F | F | T
F | T | F | T
F | F | F | T

(b) TRUTH TABLE:
p | q | p and q | not p | not p => (p and q) | (not p => (p and q)) <=> p
T | T | T | F | T | T
T | F | F | F | T | T
F | T | F | T | F | T
F | F | F | T | F | T

(c) TRUTH TABLE:
p | q | p => q | p and (p => q) | (p and (p => q)) => q
T | T | T | T | T
T | F | F | F | T
F | T | T | F | T
F | F | T | F | T

** Solution 3 **

(a) EQUIV:
p => not p
<=> not p or not p [=>]
<=> not p [idempotence]

(b) EQUIV:
not p => p
<=> not not p or p [=>]
<=> p or p [not not]
<=> p [idempotence]

(c) EQUIV:
p => (q => r)
<=> not p or (q => r) [=>]
<=> not p or (not q or r) [=>]
<=> (not p or not q) or r [associativity]
<=> not (p and q) or r [De Morgan]
<=> (p and q) => r [=>]

(d) EQUIV:
q => (p => r)
<=> not q or (p => r) [=>]
<=> not q or (not p or r) [=>]
<=> not p or (not q or r) [associativity and commutativity]
<=> not p or (q => r) [=>]
<=> p => (q => r) [=>]

(e) EQUIV:
((p and q) <=> p)
<=> ((p and q) => p) and (p => (p and q)) [<=>]
<=> (not (p and q) or p) and (not p or (p and q)) [=>]
<=> ((not p or not q) or p) and (not p or (p and q)) [De Morgan]
<=> (not q or (not p or p)) and (not p or (p and q)) [associativity and comm.]
<=> (not q or true) and (not p or (p and q)) [excluded middle]
<=> true and (not p or (p and q)) [or and true]
<=> not p or (p and q) [and and true]
<=> (not p or p) and (not p or q) [distribution]
<=> true and (not p or q) [excluded middle]
<=> not p or q [and and true]
<=> p => q [=>]

(f) EQUIV:
((p or q) <=> p)
<=> ((p or q) => p) and (p => (p or q)) [<=>]
<=> (not (p or q) or p) and (not p or (p or q)) [=>]
<=> ((not p and not q) or p) and (not p or (p or q)) [De Morgan]
<=> ((not p or p) and (not q or p)) and (not p or (p or q)) [distribution]
<=> (true and (not q or p)) and (not p or (p or q)) [excluded middle]
<=> (not q or p) and (not p or (p or q)) [and and true]
<=> (not q or p) and ((not p or p) or q) [associativity]
<=> (not q or p) and (true or q) [excluded middle]
<=> (not q or p) and true [or and true]
<=> (not q or p) [and and true]
<=> q => p [=>]

** Solution 4 **

(a) TEXT: (p or q) <=> ((not p or not q) and q) is not a tautology. You might illustrate this via a truth table or via a chain of equivalences, showing that the proposition is not equivalent to true. Alternatively, you might try and find a combination of values for which the proposition is false. (In this case, the proposition is false when p and q are both true.)

(b) TEXT: (p or q) <=> ((not p and not q) or q) is not a tautology. In this case, the proposition is false when p is true and q is false.

** Solution 5 **

(a) exists d : Dog | gentle(d) and well_trained(d)
(b) forall d : Dog | neat(d) and well_trained(d) => attractive(d)
(c) exists d : Dog | gentle(d) => forall t : Trainer | groomed(d, t)

** Solution 6 **

(a) TEXT: This is a true proposition: whatever the value of x, the expression x^2 - x + 1 denotes a natural number. If we choose y to be this natural number, we will find that p is true.

(b) TEXT: This is a false proposition. We cannot choose a large enough value for y such that p will hold for any value of x.

(c) TEXT: This is a false proposition. It is an implication whose antecedent part is true and whose consequent part is false.

(d) TEXT: This is a true proposition. It is an implication whose antecedent part is false and whose consequent part is true.

** Solution 7 **

(a) TEXT: We must define a predicate p that is false for at least one value of x, and is true for at least one other value. A suitable solution would be p <=> x > 1.

(b) TEXT: With the above choice of p, we require only that q is sometimes false when p is true (for else the universal quantification would hold). A suitable solution would be q <=> x > 3.

** Solution 8 **

(a) forall x : N | x >= z
(b) forall z : N | z >= x + y
(c) x + 3 > 0 and forall z : N | z >= x + 3

=== Equality ===

** Solution 9 **

(a) EQUIV:
exists y : N | y in {0, 1} and y != 1 and x != y
<=> exists y : N | y = 0 and x != y [arithmetic]
<=> 0 in N and x != 0 [one-point rule]
<=> x != 0

(b) EQUIV:
exists x, y : N | x + y = 4 and x < y
<=> exists x, y : N | y = 4 - x and x < y
<=> exists x : N | 4 - x in N and x < 4 - x
<=> true

TEXT: The final equivalence holds because 0 in N, 4 - 0 in N, and 0 < 4.

(c) EQUIV:
forall x : N | exists y : N | x = y + 1
<=> forall x : N | exists y : N | y = x - 1
<=> forall x : N | x - 1 in N

TEXT: The final equivalence holds because 0 in N and yet 0 - 1 not in N. We may assume that the subtraction operator is defined for all integers.

(d) EQUIV:
exists x : N | (x = 1 and x > y) or (x = 2 and x > z)
<=> (exists x : N | x = 1 and x > y) or (exists x : N | x = 2 and x > z)
<=> (1 in N and 1 > y) or (exists x : N | x = 2 and x > z)
<=> (1 in N and 1 > y) or (2 in N and 2 > z)
<=> 1 > y or 2 > z

** Solution 10 **

TEXT: As discussed, the quantifier exists1 can help give rise to a 'test' or 'precondition' to ensure that an application of mu will work.

TEXT: So, as a simple example, as the proposition

exists1 n : N | (forall m : N | n <= m)

TEXT: is equivalent to true, we can be certain that the statement

(mu n : N | (forall m : N | n <= m))

TEXT: will return a result (which happens to be 0).

** Solution 11 **

(a) (mu a : N | a = a) = 0 
TEXT: is a provable statement, since 0 is the only natural number with the specified property.

(b) (mu b : N | b = b) = 1 
TEXT: is not provable. The specified property is true of both 0 and 1, and thus the value of the mu-expression is undefined.

(c) (mu c : N | c > c) = (mu c : N | c > c) 
TEXT: is a provable statement. Neither expression is properly defined, but we may conclude that they are equal; there is little else that we can prove about them.

(d) (mu d : N | d = d) = 1 
TEXT: is not a provable statement. We cannot confirm that 1 is the only natural number with the specified property; we do not know what value is taken by undefined operations.

** Solution 12 **

(a) (mu m : Mountain | (forall n : Mountain | height(n) <= height(m)) . height(m))

(b) (mu c : Chapter | (exists1 d : Chapter | length(d) > length(c)) . length(c))

(c) TEXT: Assuming the existence of a suitable function, max: (mu n : N | n = max({ m : N | 8 * m < 100 . 8 * m }) . 100 - n)

=== Deductive proofs ===

** Solution 13 **

PROOF:
  (p and (p => q)) => (p and q) [=> intro from 1]
    [1] p and (p => q) [assumption]
    :: p and q [and intro]
      :: p [and elim from 1]
        [1] p and (p => q) [from above]
      :: q [=> elim]
        :: p => q [and elim from 1]
          [1] p and (p => q) [from above]
        :: p [and elim from 1]
          [1] p and (p => q) [from above]

** Solution 14 **

TEXT: In one direction:

PROOF:
  ((p and q) <=> p) => (p => q) [=> intro from 1]
    [1] (p and q) <=> p [assumption]
    :: p => q [=> intro from 2]
      [2] p [assumption]
      :: q [and elim from 3]
        :: p and q [=> elim from 1 and 2]
          [3] p and q [derived]

TEXT: and the other:

PROOF:
  (p => q) => ((p and q) <=> p) [=> intro from 1]
    [1] p => q [assumption]
    :: (p and q) <=> p [<=> intro]
      :: (p and q) => p [=> intro from 2]
        [2] p and q [assumption]
        :: p [and elim from 2]
      :: p => (p and q) [=> intro from 3]
        [3] p [assumption]
        :: p and q [and intro from 1 and 3]

TEXT: We can then combine these two proofs with <=> intro.

** Solution 15 **

PROOF:
  ((p => q) and not q) => not p [=> intro from 1]
    [1] (p => q) and not q [assumption]
    :: not p [false elim from 2]
      [2] p [assumption]
      :: false [false intro]
        :: q [=> elim]
          :: p => q [and elim from 1]
          :: p [from 2]
        :: not q [and elim from 1]

** Solution 16 **

TEXT: In one direction:

PROOF:
  (p and (q or r)) => ((p and q) or (p and r)) [=> intro from 1]
    [1] p and (q or r) [assumption]
    :: (p and q) or (p and r) [or elim from 2]
      [2] q or r [from 1]
      case q:
        :: p and q [and intro]
          :: p [and elim from 1]
          :: q [case assumption]
        :: (p and q) or (p and r) [or intro]
      case r:
        :: p and r [and intro]
          :: p [and elim from 1]
          :: r [case assumption]
        :: (p and q) or (p and r) [or intro]

TEXT: In the other:

PROOF:
  ((p and q) or (p and r)) => (p and (q or r)) [=> intro from 3]
    [3] (p and q) or (p and r) [assumption]
    :: p and (q or r) [or elim from 4]
      [4] case1 or case2 [from 3]
      case p and q:
        :: p [and elim]
        :: q or r [or intro]
        :: p and (q or r) [and intro]
      case p and r:
        :: p [and elim]
        :: q or r [or intro]
        :: p and (q or r) [and intro]

** Solution 17 **

TEXT: In one direction:

PROOF:
  (p or (q and r)) => ((p or q) and (p or r)) [=> intro from 3]
    [3] p or (q and r) [assumption]
    :: (p or q) and (p or r) [or elim and and intro]

TEXT: and the other:

PROOF:
  ((p or q) and (p or r)) => (p or (q and r)) [=> intro from 1]
    [1] (p or q) and (p or r) [assumption]
    :: p or (q and r) [or elim from 2 and 3]

** Solution 18 **

TEXT: In one direction:

PROOF:
  (p => q) => (not p or q) [=> intro from 1]
    [1] p => q [assumption]
    :: not p or q [or elim from excluded middle]

TEXT: and the other:

PROOF:
  (not p or q) => (p => q) [=> intro from 3]
    [3] not p or q [assumption]
    :: p => q [=> intro from 4]
      [4] p [assumption]
      :: q [or elim and false elim from 3]

=== Sets and types ===

** Solution 19 **

(a) TEXT: 1 in {4, 3, 2, 1} is true.

(b) TEXT: {1} in {1, 2, 3, 4} is undefined.

(c) TEXT: {1} in {{1}, {2}, {3}, {4}} is true.

(d) TEXT: The empty set in {1, 2, 3, 4} is undefined.

** Solution 20 **

(a) {1} cross {2, 3}

TEXT: is the set {(1, 2), (1, 3)}

(b) TEXT: The empty set cross {2, 3} is the empty set

(c) (P emptyset) cross {1}

TEXT: is the set {(emptyset, 1)}

(d) TEXT: {(1, 2)} cross {3, 4} is the set {((1, 2), 3), ((1, 2), 4)}

** Solution 21 **

TEXT: There are various ways of describing these sets via set comprehensions. Examples are given below.

(a) { z : Z | 0 <= z and z <= 100 }

(b) { z : Z | z = 10 }

(c) { z : Z | z mod 2 = 0 or z mod 3 = 0 or z mod 5 = 0 }

** Solution 22 **

(a) { n : N | n <= 4 . n^2 }

(b) { n : N | n <= 4 . (n, n^2) }

(c) { n : P {0, 1} }

(d) { n : P {0, 1} | true . (n, # n) }

** Solution 23 **

(a) EQUIV:
x in a intersect a
<=> x in a and x in a
<=> x in a

(b) EQUIV:
x in a union a
<=> x in a or x in a
<=> x in a

** Solution 24 **

given Z

(a) TEXT: The set of all pairs of integers is Z cross Z. To give it a name, we could write:

Pairs == Z cross Z

(b) TEXT: The set of all integer pairs in which each element is strictly greater than zero could be defined by:

StrictlyPositivePairs == { m, n : Z | m > 0 and n > 0 . (m, n) }

(c) TEXT: It is intuitive to use a singular noun for the name of a basic type; we define the set of all people by writing:

given Person

(d) TEXT: The set of all couples could be defined by:

Couples == { s : P Person | # s = 2 }

** Solution 25 **

(a) emptyset[N] in emptyset[P(N)]

(b) emptyset[N cross N] subseteq (emptyset[N] cross emptyset[N])

(c) (emptyset[N] cross {emptyset[N]}) subseteq emptyset[N cross P(N)]

** Solution 26 **

TEXT: We may define notin using our built-in operator (notin is already implemented as a binary operator mapping to \notin)

=== Relations ===

** Solution 27 **

(a) TEXT: The power set of {(0,0), (0,1), (1,0), (1,1)} is:

{ emptyset, {(0, 0)}, {(0, 1)}, {(1, 0)}, {(1, 1)}, {(1, 0), (1, 1)}, {(0, 0), (0, 1)}, {(0, 1), (1, 1)}, {(0, 1), (1, 0)}, {(0, 0), (1, 1)}, {(0, 0), (1, 0)}, {(0, 0), (1, 0), (1, 1)}, {(0, 0), (0, 1), (1, 1)}, {(0, 0), (0, 1), (1, 0)}, {(0, 1), (1, 0), (1, 1)}, {(0, 0), (0, 1), (1, 0), (1, 1)} }

(b) { emptyset, {(0, 0)}, {(0, 1)}, {(0, 0), (0, 1)} }

(c) { emptyset }

(d) { emptyset }

** Solution 28 **

(a) dom R = {0, 1, 2}

(b) ran R = {1, 2, 3}

(c) {1, 2} <| R = {1 |-> 2, 1 |-> 3, 2 |-> 3}

** Solution 29 **

(a) {2 |-> 4, 3 |-> 3, 3 |-> 4, 4 |-> 2}

(b) {1 |-> 3, 2 |-> 2, 2 |-> 3, 3 |-> 1}

(c) {1 |-> 1, 2 |-> 2, 2 |-> 3, 3 |-> 2, 3 |-> 3, 4 |-> 4}

(d) {1 |-> 4, 2 |-> 2, 2 |-> 3, 3 |-> 2, 3 |-> 3, 4 |-> 1}

** Solution 30 **

axdef
  childOf : Person <-> Person
end

(a) parentOf == childOf~

TEXT: This is a good example of how there are many different ways of writing the same thing. An alternative abbreviation would be: parentOf == {x, y : Person | x |-> y in childOf . y |-> x}. Or via an axiomatic definition with parentOf : Person <-> Person and where clause parentOf = childOf~.

(b) siblingOf == (childOf o9 parentOf) \ id Person

(c) cousinOf == childOf o9 siblingOf o9 parentOf

(d) ancestorOf == parentOf+

** Solution 31 **

TEXT: (Requires compound identifiers with operators - R+, R*)

(a) R == {a, b : N | b = a or b = a}

(b) S == {a, b : N | b = a or b = a}

(c) TEXT: R+ == {a, b : N | b > a}

(d) TEXT: R* == {a, b : N | b >= a}

** Solution 32 **

(a) EQUIV:
x |-> y in A <| (B <| R)
<=> x in A and x |-> y in (B <| R)
<=> x in A and x in B and x |-> y in R
<=> x in A intersect B and x |-> y in R
<=> x |-> y in (A intersect B) <| R

(b) EQUIV:
x |-> y in (R union S) |> C
<=> x |-> y in (R union S) and y in C
<=> (x |-> y in R or x |-> y in S) and y in C
<=> (x |-> y in R and y in C) or (x |-> y in S and y in C)
<=> x |-> y in R |> C or x |-> y in S |> C
<=> x |-> y in (R |> C) union (S |> C)

=== Functions ===

** Solution 33 **

TEXT: The set of 9 functions:

{ emptyset, {(0, 0)}, {(0, 1)}, {(1, 1)}, {(1, 0)}, {(0, 0), (1, 1)}, {(0, 1), (1, 1)}, {(1, 0), (0, 0)}, {(0, 1), (1, 0)} }

(a) TEXT: The set of total functions:

{ {(0, 0), (1, 1)}, {(0, 1), (1, 1)}, {(1, 0), (0, 0)}, {(0, 1), (1, 0)} }

(b) TEXT: The set of functions which are neither injective nor surjective:

{ {(0, 1), (1, 1)}, {(0, 0), (1, 0)} }

(c) TEXT: The set of functions which are injective but not surjective:

{ emptyset, {(0, 0)}, {(0, 1)}, {(1, 0)}, {(1, 1)} }

(d) TEXT: There are no functions (of this type) which are surjective but not injective.

(e) TEXT: The set of bijective functions:

{ {(0, 0), (1, 1)}, {(0, 1), (1, 0)} }

** Solution 34 **

(a) {1 |-> a, 2 |-> b, 3 |-> c, 4 |-> b}

(b) {1 |-> c, 2 |-> b, 3 |-> c, 4 |-> d}

(c) {1 |-> c, 2 |-> b, 3 |-> c, 4 |-> b}

(d) {1 |-> c, 2 |-> b, 3 |-> c, 4 |-> b}

** Solution 35 **

(a) axdef
  children : Person -> P Person
where
  children = {p : Person . p |-> parentOf(| {p} |)}
end

(b) axdef
  number_of_grandchildren : Person -> N
where
  number_of_grandchildren = {p : Person . p |-> # (parentOf o9 parentOf)(| {p} |)}
end

** Solution 36 **

TEXT: (Note: This solution demonstrates relation types in quantifier domains)

given Drivers, Cars

axdef
  number_of_drivers : (Drivers <-> Cars) -> (Cars -> N)
where
  number_of_drivers = (lambda r : Drivers <-> Cars . {c : ran r . c |-> #{d : Drivers | d |-> c in r}})
end

=== Sequences ===

** Solution 37 **

(a) <a>

(b) {1 |-> a, 2 |-> b, 2 |-> a, 3 |-> c, 3 |-> b, 4 |-> d}

(c) {2 |-> b, 3 |-> c, 4 |-> d}

(d) {1, 2, 3, 4}

(e) {a, b}

(f) {a |-> 1, b |-> 2, c |-> 3, d |-> 4}

(g) <a, b>

(h) {3 |-> b}

(i) {a}

(j) c

** Solution 38 **

given Place

axdef
  trains : N -> (Place cross Place)
end

(a) axdef
  f : Place -> P(Place)
where
  forall p : Place | f(p) = {q : Place | p |-> q in ran trains}
end

(b) TEXT: {p : Place | (exists1 x : dom trains | snd(trains(x)) = p)}

(c) TEXT: (mu p : Place | forall q : Place | p /= q | # {x : dom trains | snd(trains(x)) = p} > # {x : dom trains | snd(trains(x)) = q})

** Solution 39 **

TEXT: Assuming Collection is defined as a bag (multiset) of coins: Collection == Coin -> N

TEXT: And large is a specific coin denomination.

TEXT: (a) axdef
TEXT:   largeCoins : (Coin -> N) -> N
TEXT: where
TEXT:   forall c : (Coin -> N); large : Coin | largeCoins(c) = c(large)
TEXT: end

TEXT: (b) axdef
TEXT:   addCoin : (Coin -> N) cross Coin -> (Coin -> N)
TEXT: where
TEXT:   forall c : (Coin -> N); d : Coin | addCoin(c, d) = c union [[d]]
TEXT: end

=== Modelling ===

** Solution 40 **

TEXT: Note: Refactored to use schemas with named fields instead of tuples for fuzz compatibility.
TEXT: Changed underscore identifiers to camelCase for fuzz compatibility.

given Title, Viewed

schema Programme
  title: Title
  length: N
  viewed: Viewed
end

axdef
  yes : Viewed
end

axdef
  cumulativeTotal : seq(Programme) -> N
where
  cumulativeTotal(<>) = 0
  forall x : Programme; s : seq(Programme) |
    cumulativeTotal(<x> ^ s) = x.length + cumulativeTotal(s)
end

axdef
  viewedProgrammes : seq(Programme) -> seq(Programme)
where
  viewedProgrammes(<>) = <>
  forall x : Programme; s : seq(Programme) |
    viewedProgrammes(<x> ^ s) = if x.viewed = yes then <x> ^ viewedProgrammes(s) else viewedProgrammes(s)
end

(a) axdef
  hd : seq(Programme)
where
  cumulativeTotal(hd) <= 12000
  forall p : ran hd | p.length <= 360
end

(b) TEXT: Assuming hd is defined as in part (a):

TEXT: {p : ran hd | p.length > 120 . p.title}

(c) TEXT: Definitions of viewedProgrammes and cumulativeTotal moved above for fuzz validation.

(d) TEXT: See definitions above.

(e) TEXT: Assuming hd is defined as in part (a), the title of the longest programme:

TEXT: (mu p : ran hd | forall q : ran hd | p /= q | p.length > q.length | p.title)

TEXT: (This, of course, assumes that there is a unique element with this property.)

(f) TEXT: axdef
TEXT:   totalsByTitle : seq(Programme) -> (Title +-> Length)
TEXT: where
TEXT:   forall s : seq(Programme) |
TEXT:     totalsByTitle(s) = {t : Title | (exists p : ran s | p.title = t) .
TEXT:       t |-> cumulativeTotal(s |> {l : Length; v : Viewed . (t, l, v)})}
TEXT: end
TEXT:
TEXT: (Note: Complex nested set comprehensions - may require simplification for implementation)

axdef
  longestViewed : seq(Programme) +-> Programme
where
  forall s : seq(Programme) | longestViewed(s) = (mu p : ran s | p.viewed = yes and forall q : ran s | p /= q and q.viewed = yes | p.length > q.length)
end

TEXT: longestViewed assumes that there is at least one viewed programme (and one of a unique maximum length).

(g) axdef
  removeTheLongestViewed : seq(Programme) -> seq(Programme)
where
  forall s : seq(Programme) |
    removeTheLongestViewed(s) = s |> {x : ran s | x /= longestViewed(s)}
end

(h) axdef
  sortByLength : seq(Programme) -> seq(Programme)
where
  forall x : seq(Programme); sorted : seq(Programme) | sorted = sortByLength(x) and items(sorted) = items(x) and (forall i, j : dom(sorted); pi, pj : Programme | pi = sorted(i) and pj = sorted(j) and i < j => pi.length >= pj.length)
end

** Solution 41 **

given Course, Lecturer

axdef
  current : N
end

schema Entry
  year: N
  course: Course
  code: N
  lecturer: Lecturer
  enrolled: N
  completed: N
  grade: N
end

Table == N -|> Entry

(a) axdef
  records : N -|> Table
where
  dom(records) = 1993..current
  forall y : dom(records) | # (records(y)) <= 50
  forall y : dom(records) | forall e : ran(records(y)) | e.year = y
end

(b) (i) {e : Entry | (exists r : ran records | e in ran r and e.code = 479)}

(ii) {e : Entry | (exists r : ran records | e in ran r and e.completed > e.enrolled)}

(iii) {e : Entry | (exists r : ran records | e in ran r and e.grade >= 70)}

(iv) {c : Course | (forall r : ran records | (forall e : ran r | e.course = c => e.grade >= 70))}

(v) {y : Year | y in dom records . y |-> {l : Lecturer | # {e : ran (records y) | e.lecturer = l} > 6}}

(c) axdef
  courses479 : seq(Entry) -> seq(Entry)
where
  forall x : Entry; s : seq(Entry) | courses479 (<>) = <> and courses479 (<x> ^ s) = if x.code = 479 then <x> ^ courses479(s) else courses479(s)
end

(d) axdef
  total : seq(Entry) -> N
where
  forall x : Entry; s : seq(Entry) | total(<>) = 0 and total(<x> ^ s) = x.enrolled + total(s)
end

** Solution 42 **

(a) axdef
  State : P(seq(iseq(Person)))
where
  forall s : State | forall i, j : dom(s) | i /= j | ran(s(i)) intersect ran(s(j)) = {}
end

(b) axdef
  add : N cross Person cross State -|> State
where
  forall n : N; p : Person; s : State | n in dom(s) and p notin bigcup {i : dom(s) . ran(s(i))} . add(n, p, s) = s ++ {n |-> s(n) ^ <p>}
end

** Solution 43 **

TEXT: Note: Assuming given types Cinema, Film, Date, Booking and a bookings relation.
TEXT: The problem statement defines: bookings : (Cinema cross Film) +-> seq Booking
TEXT: where Booking is a triple of (bookingRef, startDay, endDay) : (N cross N cross N)

given Cinema, Film, Date

schema Booking
  ref: N
  startDay: N
  endDay: N
end

TEXT: Assuming: bookings : (Cinema cross Film) +-> seq Booking

(a) TEXT: (i) forall i : dom bookings | forall x, y : bookings(i) | x /= y | (x.startDay..x.endDay) intersect (y.startDay..y.endDay) = emptyset

TEXT: (ii) forall i : dom bookings | forall x : bookings(i) | {x.startDay, x.endDay} subseteq 1..max(fst(i))

TEXT: (Note: Assuming max is a function on Cinema that returns the maximum day number)

TEXT: (iii) forall i : dom bookings | forall b : bookings(i) | b.startDay <= b.endDay

TEXT: (iv) This is enforced by the constraint for part (i).

(b) TEXT: Assuming Banbury : Cinema and bookings is defined

TEXT: (i) {i : dom bookings | fst(i) = Banbury . snd(i)}

TEXT: (ii) {i : dom bookings | fst(i) = Banbury and exists b : bookings(i) | 50 in b.startDay..b.endDay}

TEXT: (iii) Assuming Room is Cinema, returning unique cinema/film pairs:

TEXT: {c : Cinema; f : Film | exists i : dom bookings | fst(i) = c and snd(i) = f . (c, f)}

TEXT: (iv) {c : Cinema | exists i : dom bookings | fst(i) = c | # (bookings(i)) >= 10}

=== Free types and induction ===

given N

Tree ::= stalk | leaf⟨N⟩ | branch⟨Tree × Tree⟩

** Solution 44 **

TEXT: The two cases of the proof are established by equational reasoning: the first by
TEXT:
TEXT: reverse (<> ^ t) = reverse t [cat.1a] = (reverse t) ^ <> [cat.1b]
TEXT:
TEXT: where cat.1a is <> ^ s = s and cat.1b is s ^ <> = s
TEXT:
TEXT: and the second by
TEXT:
TEXT: reverse ((<x> ^ u) ^ t) = reverse (<x> ^ (u ^ t)) [cat.2]
TEXT:                          = reverse (u ^ t) ^ <x>    [reverse.2]
TEXT:                          = (reverse t ^ reverse u) ^ <x>  [anti-distributive]
TEXT:                          = reverse t ^ (reverse u ^ <x>)  [cat.2]
TEXT:                          = reverse t ^ reverse (<x> ^ u)  [reverse.2]

** Solution 45 **

TEXT: The base case:
TEXT:
TEXT: reverse (reverse <>) = reverse <> [reverse.1] = <> [reverse.1]
TEXT:
TEXT: The inductive step:
TEXT:
TEXT: reverse (reverse (<x> ^ t))
TEXT:   = reverse ((reverse t) ^ <x>)  [reverse.2]
TEXT:   = reverse (<x>) ^ reverse (reverse t)  [anti-distributive]
TEXT:   = reverse (<x> ^ <>) ^ reverse (reverse t)  [cat.1]
TEXT:   = ((reverse <>) ^ <x>) ^ reverse (reverse t)  [reverse.2]
TEXT:   = (<> ^ <x>) ^ reverse (reverse t)  [reverse.1]
TEXT:   = <x> ^ reverse (reverse t)  [cat.1]
TEXT:   = <x> ^ t  [reverse (reverse t) = t]

** Solution 46 **

(a) axdef
  treeCount : Tree -> N
where
  treeCount(stalk) = 0
  forall n : N | treeCount(leaf(n)) = 1
  forall t1, t2 : Tree | treeCount(branch(t1, t2)) = treeCount(t1) + treeCount(t2)
end

(b) axdef
  flatten : Tree -> seq(N)
where
  flatten(stalk) = <>
  forall n : N | flatten(leaf(n)) = <n>
  forall t1, t2 : Tree | flatten(branch(t1, t2)) = flatten(t1) ^ flatten(t2)
end

** Solution 47 **

TEXT: First, exhibit the induction principle for the free type:
TEXT:
TEXT: P stalk and (forall n : N | P (leaf n)) and (forall t1, t2 : Tree | P t1 and P t2 => P (branch (t1, t2)))
TEXT: implies forall t : Tree | P t
TEXT:
TEXT: This gives three cases for the proof:
TEXT:
TEXT: # (flatten stalk) = # <> [flatten] = 0 [#] = treeCount stalk [treeCount]
TEXT:
TEXT: (Remaining cases omitted - require equational reasoning with recursive functions)

=== Supplementary material: assignment practice ===

** Solution 48 **

given SongId, UserId, PlaylistId

axdef
  songs : F SongId
  users : F UserId
  playlists : PlaylistId +-> seq SongId
  playlistOwner : PlaylistId +-> UserId
  playlistSubscribers : PlaylistId +-> F1 UserId
  nullSong : SongId
where
  forall i : dom(playlists) | ran(playlists(i)) subseteq songs
  dom(playlistOwner) subseteq dom(playlists)
  ran(playlistOwner) subseteq users
  dom(playlistSubscribers) subseteq dom(playlists)
  forall i : dom(playlistSubscribers) | playlistSubscribers(i) subseteq users
  forall i : dom(playlists) | playlistOwner(i) in playlistSubscribers(i)
end

** Solution 49 **

axdef
  hated : UserId +-> F SongId
  loved : UserId +-> F SongId
where
  dom(hated) subseteq users
  forall i : dom(hated) | hated(i) subseteq songs
  dom(loved) subseteq users
  forall i : dom(loved) | loved(i) subseteq songs
  forall i : dom(hated) union dom(loved) | hated(i) intersect loved(i) = emptyset
end

** Solution 50 **

(a) A == users \ bigcup(ran(playlistSubscribers))

(b) B == {p : dom(playlistSubscribers) | # (playlistSubscribers(p)) >= 100}

(c) C == (mu u : dom(loved) | forall v : dom(loved) | u /= v | # (loved(u)) > # (loved(v)))

(d) D == (mu s : songs | forall t : songs | s /= t | # {u : UserId | s in loved(u)} > # {u : UserId | t in loved(u)})

** Solution 51 **

(a) axdef
  loveHateScore : SongId +-> N
where
  forall i : songs | loveHateScore(i) = if # {u : UserId | i in loved(u)} >= # {u : UserId | i in hated(u)} then (# {u : UserId | i in loved(u)}) - (# {u : UserId | i in hated(u)}) else 0
end

axdef
  playlistCount : SongId +-> N
where
  forall i : songs | playlistCount(i) = # {p : dom(playlists) | i in ran(playlists(p))}
end

axdef
  length : SongId +-> N
  popularity : SongId +-> N
where
  dom(length) subseteq songs
  dom(popularity) subseteq songs
  forall i : songs | popularity(i) = loveHateScore(i) + playlistCount(i)
end

(b) axdef
  mostPopular : SongId
where
  mostPopular = if (exists1 i : songs | forall j : songs | i /= j | popularity(i) > popularity(j)) then (mu i : songs | forall j : songs | i /= j | popularity(i) > popularity(j)) else nullSong
end

(c) playlistsContainingMostPopularSong == {i : dom(playlists) | mostPopular in ran(playlists(i))}

** Solution 52 **

TEXT: Assuming Play == SongId cross UserId

TEXT: And functions: userStatus : UserId -> {premium, standard}, fst : X cross Y -> X, snd : X cross Y -> Y

TEXT: (a) premiumPlays filters plays to only premium users
TEXT: (b) standardPlays filters plays to only standard users
TEXT: (c) cumulativeLength sums the lengths of all songs played
