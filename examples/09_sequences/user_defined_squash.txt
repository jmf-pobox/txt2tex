// ============================================================================
// Example: User-Defined Squash Function
// ============================================================================
// Demonstrates:
//   - Axiomatic definition of squash using gendef
//   - Compacting sparse partial functions into sequences
//   - Squash properties (range preservation, length calculation)
//   - Examples with various function types
//   - Relationship between continuous functions and sequences
//   - Preserving injectivity
//
// Features:
//   - gendef [X] squashFunc : (N1 +-> X) -> seq X
//   - ran (squashFunc f) = ran f [range preservation]
//   - # (squashFunc f) = # (ran f) [length property]
//   - Removes gaps in domain
//
// See: docs/USER_GUIDE.md - Sections "Sequences", "Generic Definitions"
// ============================================================================

=== User-Defined Squash Function ===

TEXT: The squash operator appears in the Z notation glossary but is not built into the fuzz type-checker. However, we can define it ourselves as a user-defined function using an axiomatic specification.

TEXT: Squash takes a partial function from N1 (positive naturals) to some type X and compacts it into a sequence by removing gaps in the domain. For example, {1 |-> a, 3 |-> b, 7 |-> c} becomes <a, b, c>.

** Example 1: Axiomatic Definition of Squash **

TEXT: We define squash axiomatically by specifying its key properties using only fuzz-compatible notation.

gendef [X]
  squashFunc : (N1 +-> X) -> seq X
where
  (forall f : (N1 +-> X) | ran (squashFunc f) = ran f land # (squashFunc f) = # (ran f))
end

TEXT: This axiomatically defines squashFunc (a user-defined version of squash) with two key properties that hold for all partial functions f from N1 to X: (1) squashFunc preserves the range: ran (squashFunc f) = ran f, and (2) the resulting sequence length equals the range cardinality: # (squashFunc f) = # (ran f). These properties characterize squashFunc as compacting partial functions by removing domain gaps while preserving all elements and their relative order.

** Example 2: Using Squash on a Simple Function **

TEXT: Demonstrate squash on a sparse partial function.

axdef
  f1 : N1 +-> N
  s1 : seq N
where
  f1 = {1 |-> 10, 3 |-> 30, 5 |-> 50} land s1 = squashFunc f1
end

TEXT: The result s1 is <10, 30, 50>, containing exactly the range elements in the order of their original indices.

** Example 3: Squash with Letters **

zed
  given Letter
end


axdef
  a : Letter
  b : Letter
  c : Letter
  d : Letter
  f2 : N1 +-> Letter
  s2 : seq Letter
where
  f2 = {2 |-> a, 4 |-> b, 7 |-> c, 9 |-> d} land s2 = squashFunc f2
end

TEXT: The result s2 is <a, b, c, d>. The gaps at positions 1, 3, 5, 6, 8 are removed.

** Example 4: Empty Function **

axdef
  f3 : N1 +-> N
  s3 : seq N
where
  f3 = {} land s3 = squashFunc f3
end

TEXT: Squashing an empty function yields an empty sequence: s3 = <>.

** Example 5: Continuous Function (No Gaps) **

axdef
  f4 : N1 +-> N
  s4 : seq N
where
  f4 = {1 |-> 100, 2 |-> 200, 3 |-> 300} land s4 = squashFunc f4
end

TEXT: When the function has no gaps (dom f4 = 1..3), squashFunc simply converts it to a sequence: s4 = <100, 200, 300>.

** Example 6: Relationship Between Function and Sequence **

TEXT: For any partial function f with a continuous domain starting at 1, squashFunc is the identity.

axdef
  continuous_N : N1 +-> N
  s_continuous_N : seq N
where
  dom continuous_N = 1 .. # (ran continuous_N) land s_continuous_N = squashFunc continuous_N
end

TEXT: In this case, continuous_N is already a sequence, and squashFunc continuous_N = continuous_N as a sequence.

** Example 7: Squash Preserves Injectivity **

TEXT: If the input function is injective, the output sequence has no duplicates.

axdef
  inj_func : N1 +-> N
  inj_seq : seq N
where
  (forall i, j : dom inj_func | inj_func i = inj_func j => i = j) land inj_seq = squashFunc inj_func
end

TEXT: Since inj_func is injective (one-to-one), inj_seq contains no duplicate elements.

** Example 8: Practical Use Case - Video Database **

zed
  given VideoID, Title
end


axdef
  sparse_catalog : N1 +-> (VideoID cross Title)
  compact_catalog : seq (VideoID cross Title)
where
  compact_catalog = squashFunc sparse_catalog
end

TEXT: A sparse catalog with gaps (deleted entries) can be compacted into a continuous sequence while preserving the order of remaining entries.
