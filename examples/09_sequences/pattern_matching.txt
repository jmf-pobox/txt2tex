// ============================================================================
// Example: Pattern Matching with Sequences
// ============================================================================
// Demonstrates:
//   - Pattern matching on empty sequences
//   - Cons pattern (<x> ^ s) for decomposition
//   - Recursive functions using pattern matching
//   - Base case and recursive case definitions
//   - Conditional expressions in pattern matching
//
// Features:
//   - f(<>) = 0 [empty sequence base case]
//   - f(<x> ^ s) = expr [cons pattern]
//   - Recursive definitions (total, cumulative_total)
//   - if-then-else in pattern matching
//
// See: docs/USER_GUIDE.md - Section "Sequences" > "Pattern Matching"
// ============================================================================

=== Pattern Matching with Sequences ===

** Example 1: Empty Sequence Pattern **

TEXT: Pattern matching on the empty sequence:

axdef
  f : seq N -> N
where
  f(<>) = 0
end

** Example 2: Cons Pattern (Head land Tail) **

TEXT: Decomposing a sequence into head and tail:

axdef
  g : seq N -> N
where
  g(<>) = 0
  forall x : N; s : seq N | g(<x> ^ s) = x
end

** Example 3: Recursive Sum **

TEXT: Computing the sum of elements using pattern matching:

axdef
  total : seq N -> N
where
  total(<>) = 0
  forall x : N; s : seq N | total(<x> ^ s) = x + total(s)
end

** Example 4: Cumulative Total **

TEXT: A more descriptive example from the solutions:

axdef
  cumulative_total : seq N -> N
where
  cumulative_total(<>) = 0
  forall x : N; s : seq N |
    cumulative_total(<x> ^ s) = x + cumulative_total(s)
end

** Example 5: Filter Pattern **

TEXT: Filtering sequences based on a condition:

axdef
  positives : seq Z -> seq Z
where
  positives(<>) = <>
  forall x : Z; s : seq Z |
    positives(<x> ^ s) =
      if x > 0 \
        then <x> ^ positives(s) \
        else positives(s)
end
