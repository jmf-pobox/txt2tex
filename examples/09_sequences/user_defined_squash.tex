\documentclass[a4paper,10pt,fleqn]{article}
\usepackage[margin=1in]{geometry}
\usepackage{amssymb}
\usepackage{natbib}
\usepackage{fuzz}
\usepackage{zed-maths}
\usepackage{zed-proof}
\begin{document}

\section*{User - Defined Squash Function}

\bigskip

The squash operator appears in the Z notation glossary but is not
built into the fuzz type-checker. However, we can define it ourselves
as a user-defined function using an axiomatic specification.

\bigskip

\bigskip

Squash takes a partial function from N1 (positive naturals) to some
type X and compacts it into a sequence by removing gaps in the
domain. For example, $\{1 \mapsto a, 3 \mapsto b, 7 \mapsto c\}$
becomes $\langle a, b, c \rangle$.

\bigskip

\bigskip
\noindent
\textbf{Example 1 : Axiomatic Definition of Squash}

\medskip

\bigskip

We define squash axiomatically by specifying its key properties using
only fuzz-compatible notation.

\bigskip

\begin{gendef}[X]
  squashFunc: (\nat_1 \pfun X) \fun \seq X
  \where
  \forall f : \nat_1 \pfun X @ \ran (squashFunc(f)) = \ran f \land \#
  (squashFunc(f)) = \# (\ran f)
\end{gendef}

\bigskip

This axiomatically defines squashFunc (a user-defined version of
squash) with two key properties that hold for all partial functions f
from N1 to X: (1) squashFunc preserves the $range : ran (squashFunc
f) $= ran f, and (2) the resulting sequence length equals the range
cardinality: # (squashFunc f) = # (ran f). These properties
characterize squashFunc as compacting partial functions by removing
domain gaps while preserving all elements and their relative order.

\bigskip

\bigskip
\noindent
\textbf{Example 2 : Using Squash on a Simple Function}

\medskip

\bigskip

Demonstrate squash on a sparse partial function.

\bigskip

\begin{axdef}
  f1 : \nat_1 \pfun \nat \\
  s1 : \seq \nat
  \where
  f1 = \{1 \mapsto 10, 3 \mapsto 30, 5 \mapsto 50\} \land s1 = squashFunc(f1)
\end{axdef}

\bigskip

The result s1 is $\langle 10, 30, 50 \rangle$, containing exactly the
range elements in the order of their original indices.

\bigskip

\bigskip
\noindent
\textbf{Example 3 : Squash with Letters}

\medskip

\begin{zed}[Letter]
\end{zed}

\begin{axdef}
  a : Letter \\
  b : Letter \\
  c : Letter \\
  d : Letter \\
  f2 : \nat_1 \pfun Letter \\
  s2 : \seq Letter
  \where
  f2 = \{2 \mapsto a, 4 \mapsto b, 7 \mapsto c, 9 \mapsto d\} \land
  s2 = squashFunc(f2)
\end{axdef}

\bigskip

The result s2 is $\langle a, b, c, d \rangle$. The gaps at positions
1, 3, 5, 6, 8 are removed.

\bigskip

\bigskip
\noindent
\textbf{Example 4 : Empty Function}

\medskip

\begin{axdef}
  f3 : \nat_1 \pfun \nat \\
  s3 : \seq \nat
  \where
  f3 = \{\} \land s3 = squashFunc(f3)
\end{axdef}

\bigskip

Squashing an empty function yields an empty $sequence : s3 $= $\langle \rangle$.

\bigskip

\bigskip
\noindent
\textbf{Example 5 : Continuous Function ( No Gaps )}

\medskip

\begin{axdef}
  f4 : \nat_1 \pfun \nat \\
  s4 : \seq \nat
  \where
  f4 = \{1 \mapsto 100, 2 \mapsto 200, 3 \mapsto 300\} \land s4 = squashFunc(f4)
\end{axdef}

\bigskip

When the function has no gaps (dom $f4 = 1$..3), squashFunc simply
converts it to a $sequence : s4 $= $\langle 100, 200, 300 \rangle$.

\bigskip

\bigskip
\noindent
\textbf{Example 6 : Relationship Between Function and Sequence}

\medskip

\bigskip

For any partial function f with a continuous domain starting at 1,
squashFunc is the identity.

\bigskip

\begin{axdef}
  continuous\_N : \nat_1 \pfun \nat \\
  s\_continuous\_N : \seq \nat
  \where
  \dom continuous\_N = 1 \upto \# (\ran continuous\_N) \land
  s\_continuous\_N = squashFunc(continuous\_N)
\end{axdef}

\bigskip

In this case, continuous\_N is already a sequence, and squashFunc
$continuous\_N = continuous\_N$ as a sequence.

\bigskip

\bigskip
\noindent
\textbf{Example 7 : Squash Preserves Injectivity}

\medskip

\bigskip

If the input function is injective, the output sequence has no duplicates.

\bigskip

\begin{axdef}
  inj\_func : \nat_1 \pfun \nat \\
  inj\_seq : \seq \nat
  \where
  (\forall i, j : \dom inj\_func @ inj\_func(i) = inj\_func(j)
  \implies i = j) \land inj\_seq = squashFunc(inj\_func)
\end{axdef}

\bigskip

Since inj\_func is injective (one-to-one), inj\_seq contains no
duplicate elements.

\bigskip

\bigskip
\noindent
\textbf{Example 8 : Practical Use Case - Video Database}

\medskip

\begin{zed}[VideoID, Title]
\end{zed}

\begin{axdef}
  sparse\_catalog : \nat_1 \pfun (VideoID \cross Title) \\
  compact\_catalog : \seq (VideoID \cross Title)
  \where
  compact\_catalog = squashFunc(sparse\_catalog)
\end{axdef}

\bigskip

A sparse catalog with gaps (deleted entries) can be compacted into a
continuous sequence while preserving the order of remaining entries.

\bigskip

\end{document}
