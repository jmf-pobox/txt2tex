\documentclass[a4paper,10pt,fleqn]{article}
\usepackage[margin=1in]{geometry}
\usepackage{amssymb}
\usepackage{adjustbox}
\usepackage{natbib}
\usepackage[colorlinks=true,linkcolor=blue,citecolor=blue,urlcolor=blue]{hyperref}
\usepackage{fuzz}
\usepackage{zed-maths}
\usepackage{zed-proof}
\newdimen\savedleftskip
\begin{document}

\section*{User - Defined Squash Function}

\noindent The squash operator appears in the Z notation glossary but is not built into the fuzz type-checker. However, we can define it ourselves as a user-defined function using an axiomatic specification.

\bigskip

\noindent Squash takes a partial function from N1 (positive naturals) to some type X and compacts it into a sequence by removing gaps in the domain. For example, $\{1 \mapsto a, 3 \mapsto b, 7 \mapsto c\}$ becomes $\langle a, b, c \rangle$.

\bigskip

\section*{Example 1 : Axiomatic Definition of Squash}
\addcontentsline{toc}{section}{Example 1 : Axiomatic Definition of Squash}

\noindent We define squash axiomatically by specifying its key properties using only fuzz-compatible notation.

\bigskip

\begin{gendef}[X]
  squashFunc: (\nat_1 \pfun X) \fun \seq~X
\where
  \forall f : \nat_1 \pfun X @ \ran (squashFunc(f)) = \ran f \land \# (squashFunc(f)) = \# (\ran f)
\end{gendef}

\noindent This axiomatically defines squashFunc (a user-defined version of squash) with two key properties that hold for all partial functions f from N1 to X: (1) squashFunc preserves the $range : ran$ (squashFunc f) = ran f, and (2) the resulting sequence length equals the range cardinality: # (squashFunc f) = # (ran f). These properties characterize squashFunc as compacting partial functions by removing domain gaps while preserving all elements and their relative order.

\bigskip

\section*{Example 2 : Using Squash on a Simple Function}
\addcontentsline{toc}{section}{Example 2 : Using Squash on a Simple Function}

\noindent Demonstrate squash on a sparse partial function.

\bigskip

\begin{axdef}
f1 : \nat_1 \pfun \nat \\
s1 : \seq~\nat
\where
f1 = \{1 \mapsto 10, 3 \mapsto 30, 5 \mapsto 50\} \land s1 = squashFunc(f1)
\end{axdef}

\noindent The result s1 is $\langle 10, 30, 50 \rangle$, containing exactly the range elements in the order of their original indices.

\bigskip

\section*{Example 3 : Squash with Letters}
\addcontentsline{toc}{section}{Example 3 : Squash with Letters}

\begin{zed}
[Letter]
\end{zed}

\begin{axdef}
a : Letter \\
b : Letter \\
c : Letter \\
d : Letter \\
f2 : \nat_1 \pfun Letter \\
s2 : \seq~Letter
\where
f2 = \{2 \mapsto a, 4 \mapsto b, 7 \mapsto c, 9 \mapsto d\} \land s2 = squashFunc(f2)
\end{axdef}

\noindent The result s2 is $\langle a, b, c, d \rangle$. The gaps at positions 1, 3, 5, 6, 8 are removed.

\bigskip

\section*{Example 4 : Empty Function}
\addcontentsline{toc}{section}{Example 4 : Empty Function}

\begin{axdef}
f3 : \nat_1 \pfun \nat \\
s3 : \seq~\nat
\where
f3 = \{\} \land s3 = squashFunc(f3)
\end{axdef}

\noindent Squashing an empty function yields an empty $sequence : s3$ = $\langle \rangle$.

\bigskip

\section*{Example 5 : Continuous Function ( No Gaps )}
\addcontentsline{toc}{section}{Example 5 : Continuous Function ( No Gaps )}

\begin{axdef}
f4 : \nat_1 \pfun \nat \\
s4 : \seq~\nat
\where
f4 = \{1 \mapsto 100, 2 \mapsto 200, 3 \mapsto 300\} \land s4 = squashFunc(f4)
\end{axdef}

\noindent When the function has no gaps (dom $f4 = 1$..3), squashFunc simply converts it to a $sequence : s4$ = $\langle 100, 200, 300 \rangle$.

\bigskip

\section*{Example 6 : Relationship Between Function land Sequence}
\addcontentsline{toc}{section}{Example 6 : Relationship Between Function land Sequence}

\noindent For any partial function f with a continuous domain starting at 1, squashFunc is the identity.

\bigskip

\begin{axdef}
continuous\_N : \nat_1 \pfun \nat \\
s\_continuous\_N : \seq~\nat
\where
\dom continuous\_N = 1 \upto \# (\ran continuous\_N) \land s\_continuous\_N = squashFunc(continuous\_N)
\end{axdef}

\noindent In this case, continuous\_N is already a sequence, and squashFunc $continuous\_N = continuous\_N$ as a sequence.

\bigskip

\section*{Example 7 : Squash Preserves Injectivity}
\addcontentsline{toc}{section}{Example 7 : Squash Preserves Injectivity}

\noindent If the input function is injective, the output sequence has no duplicates.

\bigskip

\begin{axdef}
inj\_func : \nat_1 \pfun \nat \\
inj\_seq : \seq~\nat
\where
(\forall i, j : \dom inj\_func @ inj\_func(i) = inj\_func(j) \implies i = j) \land inj\_seq = squashFunc(inj\_func)
\end{axdef}

\noindent Since inj\_func is injective (one-to-one), inj\_seq contains no duplicate elements.

\bigskip

\section*{Example 8 : Practical Use Case - Video Database}
\addcontentsline{toc}{section}{Example 8 : Practical Use Case - Video Database}

\begin{zed}
[VideoID, Title]
\end{zed}

\begin{axdef}
sparse\_catalog : \nat_1 \pfun (VideoID \cross Title) \\
compact\_catalog : \seq~(VideoID \cross Title)
\where
compact\_catalog = squashFunc(sparse\_catalog)
\end{axdef}

\noindent A sparse catalog with gaps (deleted entries) can be compacted into a continuous sequence while preserving the order of remaining entries.

\bigskip

\end{document}