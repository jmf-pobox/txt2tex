// ============================================================================
// Example: Sequence Filter Operator
// ============================================================================
// Demonstrates:
//   - Sequence filter operator (filter / ↾)
//   - Filtering sequences to include only elements from a set
//   - Comparison with range restriction (|>)
//   - Multiple filters applied sequentially
//   - Empty filter results
//   - Bag union operator (bag_union / ⊎)
//
// Features:
//   - s filter A [ASCII notation]
//   - s ↾ A [Unicode notation]
//   - Preserves order while filtering
//   - b1 bag_union b2 [bag union with multiplicity]
//
// See: docs/USER_GUIDE.md - Sections "Sequences" > "Filter", "Bags"
// ============================================================================

=== Phase 35: Sequence Filter Operator ===

TEXT: The sequence filter operator restricts a sequence to elements from a specified set. It removes elements not in the filter set while preserving order.

TEXT: ASCII notation: s filter A
TEXT: Unicode alternative: s ↾ A (U+21BE)

** Example 1: Basic Filter Operation **

TEXT: Filter a sequence to only include elements from a set.

axdef
  s1 : seq N
  evens1 : P N
  filtered1 : seq N
where
  s1 = <1, 2, 3, 4, 5, 6> land evens1 = {2, 4, 6, 8} land filtered1 = (s1 filter evens1)
end

TEXT: The filtered sequence is <2, 4, 6>, keeping only elements that are in evens and preserving their original order.

** Example 2: Filter with Set Comprehension **

zed
  given Title2, Length2
end


axdef
  all_titles : seq Title2
  long_titles : P Title2
  filtered_titles : seq Title2
where
  long_titles = {t : Title2 | true} land filtered_titles = all_titles filter long_titles
end

TEXT: This filters a sequence of titles to include only titles with length greater than 120 minutes.

** Example 3: Comparison with Range Restriction **

TEXT: Sequence filter (filter) is different from range restriction (|>):
TEXT: - filter: operates on sequences, preserves order
TEXT: - |>: operates on relations, restricts range

axdef
  s3 : seq N
  R3 : N <-> N
  A3 : P N
  filtered_seq3 : seq N
  restricted_rel3 : N <-> N
where
  s3 = <1, 2, 3, 4, 5> land R3 = {1 |-> 10, 2 |-> 20, 3 |-> 30} land A3 = {2, 3, 4} land filtered_seq3 = s3 filter A3 land restricted_rel3 = R3 |> {10, 20}
end

TEXT: filtered_seq is <2, 3, 4> (sequence elements in A)
TEXT: restricted_rel is {1 |-> 10, 2 |-> 20} (relation pairs with range in {10, 20})

** Example 4: Practical Example - Video Database **

zed
  given Title4, Length4
end


zed
  Rating4 ::= G4 | PG4 | PG13_4 | R4
end


axdef
  catalog4 : seq (Title4 cross Length4 cross Rating4)
  family_friendly4 : P Rating4
where
  family_friendly4 = {G4, PG4}
end

TEXT: The family_friendly set contains ratings G and PG. A filter could be applied to the catalog sequence to only include entries with ratings in this set.

** Example 5: Multiple Filters **

axdef
  s5 : seq N
  evens5 : P N
  large5 : P N
  result5 : seq N
where
  s5 = <1, 2, 3, 4, 5, 6, 7, 8, 9, 10> and evens5 = {2, 4, 6, 8, 10, 12} land large5 = {5, 6, 7, 8, 9, 10, 11} land result5 = (s5 filter evens5) filter large5
end

TEXT: Multiple filters can be applied sequentially. First filter to evens gives <2, 4, 6, 8, 10>, then filter to large gives <6, 8, 10>.

** Example 6: Empty Filter **

axdef
  s6 : seq N
  empty_set6 : P N
  disjoint_set6 : P N
  result6a : seq N
  result6b : seq N
where
  s6 = <1, 2, 3> land empty_set6 = {} land disjoint_set6 = {10, 20, 30} land result6a = s6 filter empty_set6 land result6b = s6 filter disjoint_set6
end

TEXT: Filtering by an empty set or disjoint set results in an empty sequence.
TEXT: result1 = <> land result2 = <>

** Example 7: Bag Union (Related Phase 35 Feature) **

TEXT: Phase 35 also includes the bag union operator.
TEXT: ASCII notation: b1 bag_union b2
TEXT: Unicode alternative: b1 ⊎ b2 (U+228E)

axdef
  b1 : bag N
  b2 : bag N
  combined : bag N
where
  b1 = [[1, 1, 2, 3]] land b2 = [[2, 3, 3, 4]] land combined = b1 bag_union b2
end

TEXT: Bag union adds multiplicities: combined = [[1, 1, 2, 2, 3, 3, 3, 4]]
TEXT: Element 1 appears 2 times (2 from b1), element 2 appears 2 times (1 from each), element 3 appears 3 times (1 from b1, 2 from b2), element 4 appears 1 time (1 from b2).
