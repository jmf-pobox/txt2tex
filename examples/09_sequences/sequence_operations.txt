// ============================================================================
// Example: Sequence Operations
// ============================================================================
// Demonstrates:
//   - Sequence length/cardinality (#)
//   - Pattern matching for head/tail decomposition
//   - User-defined sequence functions
//   - Domain and range of sequences
//
// Note: In Z notation, head/tail are expressed via pattern matching with
// concatenation, not as built-in operators. This example shows how to
// define and use sequence operations properly.
//
// See: docs/USER_GUIDE.md - Section "Sequences" > "Operations"
// ============================================================================

=== Sequence Operations ===

** Example 1: Sequence Length **

TEXT: The cardinality operator gives the length of a sequence:

# <>

# <a, b, c>

# s

** Example 2: Pattern Matching for Head and Tail **

TEXT: In Z, decomposing a sequence uses pattern matching with concatenation.

TEXT: Given a non-empty sequence s, if we have x and t such that:

<x> ^ t = s

TEXT: Then x is the first element (head) and t is the remaining sequence (tail).

** Example 3: User-Defined First and Rest Functions **

TEXT: You can define explicit functions for sequence decomposition:

given X

axdef
  fst : seq1 X -> X
  rest : seq1 X -> seq X
where
  forall x : X; s : seq X | fst(<x> ^ s) = x
  forall x : X; s : seq X | rest(<x> ^ s) = s
end

** Example 4: User-Defined Last and Init Functions **

axdef
  lst : seq1 X -> X
  init : seq1 X -> seq X
where
  forall x : X; s : seq X | lst(s ^ <x>) = x
  forall x : X; s : seq X | init(s ^ <x>) = s
end

** Example 5: Domain land Range **

TEXT: Sequences are functions from indices to elements:

dom <>

dom <a, b, c, d>

ran <a, b, c>

** Example 6: Concatenation **

TEXT: The concatenation operator joins sequences:

s ^ t

<1, 2> ^ <3, 4>

<a> ^ <b, c> ^ <d>

** Example 7: Using Pattern Matching **

TEXT: Pattern matching extracts elements from sequences:

forall s : seq1 N | exists x : N; t : seq N | s = <x> ^ t

TEXT: This asserts that every non-empty sequence can be decomposed.

** Example 8: Recursive Function Example **

TEXT: Define a sum function using pattern matching style:

axdef
  sumSeq : seq N -> N
where
  sumSeq(<>) = 0
  forall x : N; s : seq N | sumSeq(<x> ^ s) = x + sumSeq(s)
end
