// ============================================================================
// Example: Advanced Proof Patterns
// ============================================================================
// Demonstrates:
//   - Complex proof strategies
//   - Proof by cases with multiple branches
//   - Proof by induction
//   - Constructive vs classical proofs
//   - Advanced natural deduction patterns
//
// Features:
//   - Multi-level case analysis
//   - Structural induction
//   - Existential instantiation patterns
//   - Lemma application
//   - Proof composition
//
// See: docs/PROOF_SYNTAX.md
//      examples/04_proof_trees/ - Basic proofs
// ============================================================================

=== Advanced Proof Patterns ===

** Example 1: Proof by Cases (Three-Way Split) **

TEXT: Prove: For all integers n, n < 0 or n = 0 or n > 0

PROOF:
  n < 0 lor n = 0 or n > 0 [trichotomy of integers, axiom]

TEXT: This uses the trichotomy property as an axiom. To prove something about all integers, we can case-analyze on these three possibilities.

** Example 2: Multi-Level Case Analysis **

TEXT: Prove: (p lor q) land (r lor s) => (p land r) lor (p land s) lor (q land r) lor (q land s)

PROOF:
((p lor q) land (r lor s)) => (p land r) lor (p land s) lor (q land r) lor (q land s) [=> intro from 1]
  [1] (p lor q) land (r lor s) [assumption]
      p lor q [and elim 1]
      r lor s [land elim 2]
      (p land r) lor (p land s) lor (q land r) lor (q land s) [lor elim on p lor q]
        case p:
          (p land r) or (p land s) or (q land r) or (q land s) [or elim on r or s]
            case r:
              p land r [land intro]
              (p land r) lor (p land s) lor (q land r) lor (q land s) [lor intro]
            case s:
              p land s [land intro]
              (p land r) lor (p land s) lor (q land r) lor (q land s) [lor intro]
        case q:
          (p land r) or (p land s) or (q land r) or (q land s) [or elim on r or s]
            case r:
              q land r [land intro]
              (p land r) lor (p land s) lor (q land r) lor (q land s) [lor intro]
            case s:
              q land s [land intro]
              (p land r) lor (p land s) lor (q land r) lor (q land s) [lor intro]

TEXT: Nested case analysis on two disjunctions, exploring all four combinations.

** Example 3: Proof by Mathematical Induction (Base and Step) **

TEXT: Prove: For all n ∈ ℕ, sum(1 to n) = n(n+1)/2

TEXT: Base case (n = 0):

PROOF:
true => (sum_to(0) = 0 * (0+1) div 2) [=> intro from 1]
  [1] true [assumption]
      sum_to(0) = 0 [definition]
      0 * (0+1) div 2 = 0 [arithmetic]
      sum_to(0) = 0 * (0+1) div 2 [equality]

TEXT: Inductive step (assume for n, prove for n+1):

PROOF:
(sum_to(n) = n * (n+1) div 2) => (sum_to(n+1) = (n+1) * (n+2) div 2) [=> intro from 1]
  [1] sum_to(n) = n * (n+1) div 2 [assumption]
      sum_to(n+1) = sum_to(n) + (n+1) [definition]
      sum_to(n+1) = n * (n+1) div 2 + (n+1) [substitution]
      sum_to(n+1) = (n * (n+1) + 2 * (n+1)) div 2 [algebra]
      sum_to(n+1) = (n+1) * (n+2) div 2 [factoring]

TEXT: By induction, the formula holds for all natural numbers.

** Example 4: Structural Induction on Lists **

TEXT: Prove: For all sequences s, reverse(reverse(s)) = s

TEXT: Base case (empty sequence):

PROOF:
true => (reverse(reverse(emptyseq)) = emptyseq) [=> intro from 1]
  [1] true [assumption]
      reverse(emptyseq) = emptyseq [definition]
      reverse(reverse(emptyseq)) = reverse(emptyseq) [substitution]
      reverse(reverse(emptyseq)) = emptyseq [definition]

TEXT: Inductive step (assume for s, prove for cons(x, s)):

PROOF:
(reverse(reverse(s)) = s) => (reverse(reverse(cons(x, s))) = cons(x, s)) [=> intro from 1]
  [1] reverse(reverse(s)) = s [assumption]
      reverse(cons(x, s)) = append(reverse(s), x) [definition]
      reverse(reverse(cons(x, s))) = reverse(append(reverse(s), x)) [substitution]
      reverse(append(reverse(s), x)) = cons(x, reverse(reverse(s))) [definition]
      cons(x, reverse(reverse(s))) = cons(x, s) [inductive hypothesis]

TEXT: By structural induction, reverse(reverse(s)) = s for all sequences.

** Example 5: Constructive Existence Proof **

TEXT: Prove: There exists an even number greater than 10

PROOF:
true => (exists n : N | even(n) land n > 10) [=> intro from 1]
  [1] true [assumption]
      12 = 2 * 6 [arithmetic]
      even(12) [definition of even, 12 = 2 * 6]
      12 > 10 [arithmetic]
      even(12) land 12 > 10 [land intro]
      exists n : N | even(n) land n > 10 [exists intro with n = 12]

TEXT: Constructive proof: we exhibit a specific witness (12).

** Example 6: Non-Constructive Existence Proof **

TEXT: Prove: There exist irrational numbers a and b such that a^b is rational

PROOF:
irrational(sqrt(2)) => (exists a, b | irrational(a) land irrational(b) land rational(power(a, b))) [=> intro from 1]
  [1] irrational(sqrt(2)) [assumption]
      rational(power(sqrt(2), sqrt(2))) lor irrational(power(sqrt(2), sqrt(2))) [LEM]
      exists a, b | irrational(a) land irrational(b) land rational(power(a, b)) [lor elim]
        case rational(power(sqrt(2), sqrt(2))):
          irrational(sqrt(2)) land irrational(sqrt(2)) land rational(power(sqrt(2), sqrt(2))) [land intro]
          exists a, b | irrational(a) land irrational(b) land rational(power(a, b)) [exists intro with a = b = sqrt(2)]
        case irrational(power(sqrt(2), sqrt(2))):
          power(power(sqrt(2), sqrt(2)), sqrt(2)) = power(sqrt(2), sqrt(2) * sqrt(2)) [exponent law]
          power(sqrt(2), sqrt(2) * sqrt(2)) = power(sqrt(2), 2) [arithmetic]
          power(sqrt(2), 2) = 2 [simplification]
          rational(2) [known]
          irrational(power(sqrt(2), sqrt(2))) land irrational(sqrt(2)) land rational(power(power(sqrt(2), sqrt(2)), sqrt(2))) [land intro]
          exists a, b | irrational(a) land irrational(b) land rational(power(a, b)) [exists intro]

TEXT: Non-constructive: we don't know which case is true, but both lead to the conclusion.

** Example 7: Proof by Strong Induction **

TEXT: Prove: Every natural number n ≥ 2 has a prime factorization

TEXT: Base case (n = 2):

PROOF:
true => prime_factorization(2) [=> intro from 1]
  [1] true [assumption]
      prime(2) [definition]
      prime_factorization(2) [trivial, singleton factorization]

TEXT: Inductive step (assume for all k < n, prove for n):

PROOF:
(n >= 2) => prime_factorization(n) [=> intro from 1]
  [1] n >= 2 [assumption]
      prime(n) lor composite(n) [dichotomy]
      prime_factorization(n) [or elim]
        case prime(n):
          prime_factorization(n) [trivial, singleton factorization]
        case composite(n):
          exists a, b | 2 <= a land a < n land 2 <= b land b < n land n = a * b [definition of composite]
          prime_factorization(a) [strong IH, a < n]
          prime_factorization(b) [strong IH, b < n]
          prime_factorization(a * b) [multiplication of factorizations]
          prime_factorization(n) [n = a * b]

TEXT: Strong induction: we assume the property for all smaller values, not just n-1.

** Example 8: Proof Using Lemmas **

TEXT: Lemma 1: If n is even, then n^2 is even

PROOF:
even(n) => even(power(n, 2)) [=> intro from 1]
  [1] even(n) [assumption]
      exists k | n = 2 * k [definition of even]
      power(n, 2) = power(2 * k, 2) [substitution]
      power(2 * k, 2) = 4 * power(k, 2) [algebra]
      4 * power(k, 2) = 2 * (2 * power(k, 2)) [factoring]
      exists m | power(n, 2) = 2 * m [exists intro with m = 2 * power(k, 2)]
      even(power(n, 2)) [definition of even]

TEXT: Main theorem: If n^2 is odd, then n is odd

PROOF:
odd(power(n, 2)) => odd(n) [=> intro from 1]
  [1] odd(power(n, 2)) [assumption]
      even(n) lor odd(n) [dichotomy]
      odd(n) [or elim]
        case even(n):
          even(power(n, 2)) [Lemma 1]
          odd(power(n, 2)) land even(power(n, 2)) [contradiction]
          false [contradiction]
          odd(n) [false elim]
        case odd(n):
          odd(n) [identity]

TEXT: Proof by contrapositive using lemma.

** Example 9: Proof by Minimal Counterexample **

TEXT: Prove: All natural numbers n ≥ 1 satisfy P(n)

PROOF:
true => (forall n | n >= 1 => P(n)) [=> intro from 1]
  [1] true [assumption]
      (forall n | n >= 1 => P(n)) [lnot intro from 2]
        [2] lnot (forall n | n >= 1 => P(n)) [assumption]
            exists n | n >= 1 land lnot P(n) [negation of forall]
            smallest_counterexample(m) [well-ordering principle]
            m >= 1 land lnot P(m) [by choice of m]
            false [or elim]
              case m = 1:
                P(1) [base case proved separately]
                lnot P(m) land P(1) [contradiction]
                false [contradiction]
              case m > 1:
                forall k | k >= 1 land k < m => P(k) [minimality of m]
                P(m - 1) [since m - 1 >= 1 and m - 1 < m]
                P(m) [by inductive step from P(m - 1)]
                lnot P(m) land P(m) [contradiction]
                false [contradiction]

TEXT: Minimal counterexample combines well-ordering with contradiction.

** Example 10: Proof by Invariant **

TEXT: Prove: A loop maintains invariant I

TEXT: Initialization:

PROOF:
initial_state => invariant(initial_state) [=> intro from 1]
  [1] initial_state [assumption]
      invariant(initial_state) [verification]

TEXT: Preservation:

PROOF:
(invariant(before_state) land executes_loop_body) => invariant(after_state) [=> intro from 1]
  [1] invariant(before_state) land executes_loop_body [assumption]
      invariant(before_state) [land elim 1]
      executes_loop_body [land elim 2]
      invariant(after_state) [verification]

TEXT: Termination:

PROOF:
loop_terminates => desired_property [=> intro from 1]
  [1] loop_terminates [assumption]
      invariant(termination_state) [by preservation]
      invariant(termination_state) land termination_condition [land intro]
      desired_property [logic]

** Example 11: Proof by Diagonalization **

TEXT: Prove: The set of real numbers is uncountable

PROOF:
true => uncountable(reals) [=> intro from 1]
  [1] true [assumption]
      uncountable(reals) [not intro from 2]
        [2] countable(reals) [assumption]
            exists f | enumeration(f, reals) [definition of countable]
            diagonal_construction(r) [diagonal method]
            forall n | r /= apply(f, n) [by construction, differs at nth digit]
            not_in_range(r, f) [previous line]
            not_in_range(r, f) land enumeration(f, reals) [contradiction]
            false [contradiction]

TEXT: Cantor's diagonal argument (outline).

** Example 12: Constructive Proof Pattern **

TEXT: To constructively prove: exists x | P(x)

TEXT: Strategy:
TEXT: 1. Explicitly construct a witness w
TEXT: 2. Verify P(w) holds
TEXT: 3. Conclude exists x | P(x) with x = w

TEXT: Example: Prove exists n : N | n > 100 land n is even

PROOF:
true => (exists n | n > 100 land even(n)) [=> intro from 1]
  [1] true [assumption]
      witness_construction(102) [construction]
      102 > 100 [arithmetic]
      102 = 2 * 51 [arithmetic]
      even(102) [definition]
      102 > 100 land even(102) [land intro]
      exists n | n > 100 land even(n) [exists intro with n = 102]

** Example 13: Proof Composition **

TEXT: Combine multiple proof techniques:

TEXT: Theorem: Property P holds for all cases

TEXT: Overall strategy: Case analysis + Induction + Contradiction

PROOF:
true => (forall n | P(n)) [=> intro from 1]
  [1] true [assumption]
      forall n | P(n) [lor elim over cases]
        case base:
          P(base) [direct proof]
        case inductive:
          P(n) [lor elim over subcases]
            case subcase_a:
              P(n) [lnot intro from 2]
                [2] lnot P(n) [assumption]
                    contradiction_derived [proof steps]
                    false [contradiction]
            case subcase_b:
              P(n) [=> intro from 3]
                [3] P(n - 1) [assumption]
                    P(n) [inductive step]

** Example 14: Best Practices for Complex Proofs **

TEXT: Guidelines for writing advanced proofs:

TEXT: 1. State strategy at the beginning
TEXT: 2. Label cases clearly
TEXT: 3. Discharge assumptions promptly
TEXT: 4. Reference lemmas explicitly
TEXT: 5. Show key algebraic steps
TEXT: 6. Justify non-obvious steps
TEXT: 7. Use proof by cases when structure suggests it
TEXT: 8. Use induction for recursive definitions
TEXT: 9. Use contradiction for negative conclusions
TEXT: 10. Verify base cases thoroughly

** Example 15: Proof Documentation **

TEXT: Document complex proofs:

TEXT: - **Goal**: State what you're proving
TEXT: - **Strategy**: Explain the proof approach
TEXT: - **Lemmas needed**: List dependencies
TEXT: - **Key insights**: Highlight non-obvious steps
TEXT: - **Pitfalls**: Note where proof could go wrong
TEXT: - **Generalization**: Explain how proof extends

TEXT: Well-documented proofs are maintainable and reusable.
