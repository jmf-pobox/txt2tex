// ============================================================================
// Example: Simple Proof Tree Patterns
// ============================================================================
// Demonstrates:
//   - Basic implication introduction
//   - Sibling premises with :: notation
//   - Case analysis (or-elimination)
//   - Common inference patterns
//
// Features:
//   - and elim 1, and elim 2
//   - => intro, => elim
//   - or elim with case analysis
//   - and intro
//
// See: docs/PROOF_SYNTAX.md, docs/USER_GUIDE.md - Section "Proof Trees"
// ============================================================================

=== Phase 5: Proof Trees ===

** Example 1: Simple Implication **

PROOF:
p land q => q [=> intro from 1]
  [1] p land q [assumption]
      q [land elim 2]

** Example 2: With Sibling Premises **

PROOF:
p land (p => q) => (p land q) [=> intro from 1]
  [1] p land (p => q) [assumption]
      :: p [land elim 1]
      :: p => q [land elim 2]
      q [=> elim]
      p land q [land intro]

** Example 3: Distribution with Cases **

PROOF:
p land (q lor r) => (p land q) lor (p land r) [=> intro from 1]
  [1] p land (q lor r) [assumption]
      p [land elim 1]
      q lor r [land elim 2]
      (p land q) lor (p land r) [lor elim]
        case q:
          :: p [from above]
          :: q [from case]
          p land q [land intro]
          (p land q) lor (p land r) [lor intro 1]
        case r:
          :: p [from above]
          :: r [from case]
          p land r [land intro]
          (p land q) lor (p land r) [lor intro 2]

** Example 4: Modus Tollens **

PROOF:
(p => q) land lnot q => lnot p [=> intro from 1]
  [1] (p => q) land lnot q [assumption]
      :: p => q [land elim 1]
      :: lnot q [land elim 2]
      lnot p [negation intro from 2]
        [2] p [assumption]
            q [=> elim]
            false [contradiction]

** Example 5: Solution 18 Implication to Disjunction **

PROOF:
(p => q) => (lnot p lor q) [=> intro from 1]
  [1] p => q [assumption]
      :: p lor lnot p [excluded middle]
      :: lnot p lor q [lor elim from 2]
        case p:
          [2] p [assumption]
          q [=> elim]
          lnot p lor q [lor intro 2]
        case lnot p:
          [2] lnot p [assumption]
          lnot p lor q [lor intro 1]
